/*
 Navicat Premium Data Transfer

 Source Server         : mysql
 Source Server Type    : MySQL
 Source Server Version : 50640
 Source Host           : localhost:3306
 Source Schema         : geek_blog

 Target Server Type    : MySQL
 Target Server Version : 50640
 File Encoding         : 65001

 Date: 16/06/2020 12:43:10
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for qiniu_config
-- ----------------------------
DROP TABLE IF EXISTS `qiniu_config`;
CREATE TABLE `qiniu_config`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `access_key` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'accessKey',
  `bucket` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Bucket 识别符',
  `host` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '外链域名',
  `secret_key` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'secretKey',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '空间类型',
  `zone` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '机房',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '七牛云配置' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of qiniu_config
-- ----------------------------

-- ----------------------------
-- Table structure for qiniu_content
-- ----------------------------
DROP TABLE IF EXISTS `qiniu_content`;
CREATE TABLE `qiniu_content`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `bucket` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'Bucket 识别符',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件名称',
  `size` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件大小',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件类型：私有或公开',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '上传或同步的时间',
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件url',
  `suffix` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `file_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 50 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '七牛云文件存储' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of qiniu_content
-- ----------------------------

-- ----------------------------
-- Table structure for sys_access_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_access_log`;
CREATE TABLE `sys_access_log`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `create_time` datetime(0) NOT NULL COMMENT '创建时间',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `exception_detail` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '异常详情',
  `log_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '日志类型[info, error...]',
  `method` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '执行方法名称',
  `params` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '参数名称',
  `request_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '请求IP',
  `time` bigint(20) NULL DEFAULT NULL COMMENT '请求耗时',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `browser` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'IP来源',
  `status` tinyint(4) NULL DEFAULT NULL COMMENT '请求结果[0:失败, 1:成功]',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_accessLog_createTime`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1777 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Table structure for sys_local_storage
-- ----------------------------
DROP TABLE IF EXISTS `sys_local_storage`;
CREATE TABLE `sys_local_storage`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `real_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件真实的名称',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件名',
  `suffix` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '后缀',
  `path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '路径',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类型',
  `size` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '大小',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建日期',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新日期',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_localStorage_realName`(`real_name`) USING BTREE,
  UNIQUE INDEX `idx_localStorage_path`(`path`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '本地存储' ROW_FORMAT = Compact;

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `href` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '链接',
  `pid` bigint(20) NOT NULL COMMENT '父级菜单ID',
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图标',
  `authority` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限标识符',
  `sort` smallint(4) NULL DEFAULT NULL COMMENT '排序值',
  `type` tinyint(2) NULL DEFAULT NULL COMMENT '类型[1:目录, 2:菜单, 3:按钮]',
  `status` bit(1) NULL DEFAULT NULL COMMENT '是否显示',
  `remark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '备注',
  `target` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '页面跳转方式',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_menu_title`(`title`) USING BTREE,
  INDEX `idx_menu_pid`(`pid`) USING BTREE,
  INDEX `idx_menu_sort`(`sort`) USING BTREE,
  INDEX `idx_menu_href`(`href`) USING BTREE,
  INDEX `idx_menu_authority`(`authority`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 88 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, '后台系统管理', '', 0, 'fa fa-dashboard', '', 1, 1, b'1', NULL, '_self', '2020-05-11 14:42:32', '2020-05-31 16:57:32');
INSERT INTO `sys_menu` VALUES (2, '用户管理', '/admin/page/user/user-list', 82, 'fa fa-users', '', 1, 2, b'1', NULL, NULL, '2020-05-11 14:42:32', '2020-06-08 16:56:12');
INSERT INTO `sys_menu` VALUES (3, '查询用户', '', 2, NULL, 'sys:user:query', 100, 3, b'0', NULL, NULL, '2020-05-11 14:42:32', '2020-06-08 16:00:30');
INSERT INTO `sys_menu` VALUES (4, '添加用户', '', 2, NULL, 'sys:user:add', 100, 3, b'0', NULL, NULL, '2020-05-11 14:42:32', '2020-06-08 16:05:54');
INSERT INTO `sys_menu` VALUES (5, '修改用户', '', 2, NULL, 'sys:user:edit', 100, 3, b'0', NULL, NULL, '2020-05-11 14:42:32', '2020-06-08 16:06:26');
INSERT INTO `sys_menu` VALUES (6, '删除用户', '', 2, NULL, 'sys:user:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 14:42:32', '2020-06-08 16:06:57');
INSERT INTO `sys_menu` VALUES (7, '角色管理', '/admin/page/role/role-list', 82, 'fa fa-user-secret', '', 2, 2, b'1', NULL, NULL, '2020-05-11 15:19:18', '2020-05-31 16:56:54');
INSERT INTO `sys_menu` VALUES (8, '查询角色', NULL, 7, NULL, 'sys:role:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:20:03', '2020-05-11 15:20:05');
INSERT INTO `sys_menu` VALUES (9, '添加角色', NULL, 7, NULL, 'sys:role:add', 100, 3, b'0', NULL, NULL, '2020-05-11 15:20:47', '2020-05-11 15:20:51');
INSERT INTO `sys_menu` VALUES (10, '修改角色', NULL, 7, NULL, 'sys:role:edit', 100, 3, b'0', NULL, NULL, '2020-05-11 15:21:21', '2020-05-11 15:21:23');
INSERT INTO `sys_menu` VALUES (11, '删除角色', NULL, 7, NULL, 'sys:role:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:21:54', '2020-05-11 15:21:56');
INSERT INTO `sys_menu` VALUES (12, '菜单管理', '/admin/page/menu/menu-list', 82, 'fa fa-bars', '', 3, 2, b'1', NULL, NULL, '2020-05-11 15:23:11', '2020-05-31 16:57:06');
INSERT INTO `sys_menu` VALUES (13, '查询菜单', NULL, 12, NULL, 'sys:menu:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:23:49', '2020-05-11 15:23:51');
INSERT INTO `sys_menu` VALUES (14, '添加菜单', NULL, 12, NULL, 'sys:menu:add', 100, 3, b'0', NULL, NULL, '2020-05-11 15:24:18', '2020-05-11 15:24:20');
INSERT INTO `sys_menu` VALUES (15, '修改菜单', NULL, 12, NULL, 'sys:menu:edit', 100, 3, b'0', NULL, NULL, '2020-05-11 15:25:00', '2020-05-11 15:25:02');
INSERT INTO `sys_menu` VALUES (16, '删除菜单', NULL, 12, NULL, 'sys:menu:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:25:34', '2020-05-11 15:25:36');
INSERT INTO `sys_menu` VALUES (17, '访问日志', '/admin/page/log/access-list', 83, 'fa fa-eye', '', 1, 2, b'1', NULL, NULL, '2020-05-11 15:26:35', '2020-05-31 17:03:23');
INSERT INTO `sys_menu` VALUES (18, '查询访问日志', NULL, 17, NULL, 'sys:accesslog:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:27:37', '2020-05-11 15:27:41');
INSERT INTO `sys_menu` VALUES (19, '删除访问日志', '', 17, NULL, 'sys:accesslog:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:28:22', '2020-05-11 15:28:25');
INSERT INTO `sys_menu` VALUES (20, '操作日志', '/admin/page/log/operation-list', 83, 'fa fa-gear', '', 2, 2, b'1', NULL, NULL, '2020-05-11 15:29:27', '2020-05-31 17:03:33');
INSERT INTO `sys_menu` VALUES (21, '查询操作日志', NULL, 20, NULL, 'sys:operationlog:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:30:06', '2020-05-11 15:30:08');
INSERT INTO `sys_menu` VALUES (22, '删除操作日志', '', 20, NULL, 'sys:operationlog:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:30:47', '2020-05-11 15:30:49');
INSERT INTO `sys_menu` VALUES (23, '数据源监控', '/druid', 83, 'fa fa-database', 'sys:druid', 3, 2, b'1', NULL, NULL, '2020-05-11 15:31:45', '2020-05-31 17:03:51');
INSERT INTO `sys_menu` VALUES (24, '博客管理', NULL, 0, 'fa fa-book', NULL, 8, 1, b'1', NULL, '_self', '2020-05-11 15:32:43', '2020-05-11 15:32:45');
INSERT INTO `sys_menu` VALUES (25, '文章发布', '/admin/page/article/article-add', 24, 'fa fa-pencil-square-o', 'blog:article:add', 1, 2, b'1', NULL, NULL, '2020-05-11 15:34:06', '2020-06-09 09:02:15');
INSERT INTO `sys_menu` VALUES (26, '文章管理', '/admin/page/article/article-list', 24, 'fa fa-file-text', '', 2, 2, b'1', NULL, NULL, '2020-05-11 15:35:48', '2020-06-09 09:02:27');
INSERT INTO `sys_menu` VALUES (27, '查询文章', '', 26, NULL, 'blog:article:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:37:10', '2020-05-11 15:37:12');
INSERT INTO `sys_menu` VALUES (28, '修改文章', NULL, 26, NULL, 'blog:article:edit', 100, 3, b'0', NULL, NULL, '2020-05-11 15:37:45', '2020-05-11 15:37:47');
INSERT INTO `sys_menu` VALUES (29, '删除文章', NULL, 26, NULL, 'blog:article:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:38:18', '2020-05-11 15:38:21');
INSERT INTO `sys_menu` VALUES (30, '分类管理', '/admin/page/category/category-list', 24, 'fa fa-bookmark', '', 3, 2, b'1', NULL, NULL, '2020-05-11 15:39:32', '2020-06-09 09:02:38');
INSERT INTO `sys_menu` VALUES (31, '查询分类', NULL, 30, NULL, 'blog:category:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:40:13', '2020-05-11 15:40:14');
INSERT INTO `sys_menu` VALUES (32, '添加分类', NULL, 30, NULL, 'blog:category:add', 100, 3, b'0', NULL, NULL, '2020-05-11 15:40:45', '2020-05-11 15:40:47');
INSERT INTO `sys_menu` VALUES (33, '修改分类', NULL, 30, NULL, 'blog:category:edit', 100, 3, b'0', NULL, NULL, '2020-05-11 15:41:19', '2020-05-11 15:41:21');
INSERT INTO `sys_menu` VALUES (34, '删除分类', NULL, 30, NULL, 'blog:category:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:41:57', '2020-05-11 15:41:59');
INSERT INTO `sys_menu` VALUES (35, '标签管理', '/admin/page/tag/tag-list', 24, 'fa fa-tags', '', 4, 2, b'1', NULL, NULL, '2020-05-11 15:42:43', '2020-06-09 09:02:54');
INSERT INTO `sys_menu` VALUES (36, '查询标签', NULL, 35, NULL, 'blog:tag:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:43:33', '2020-05-11 15:43:35');
INSERT INTO `sys_menu` VALUES (37, '添加标签', NULL, 35, NULL, 'blog:tag:add', 100, 3, b'0', NULL, NULL, '2020-05-11 15:44:12', '2020-05-11 15:44:13');
INSERT INTO `sys_menu` VALUES (38, '修改标签', NULL, 35, NULL, 'blog:tag:edit', 100, 3, b'0', NULL, NULL, '2020-05-11 15:44:41', '2020-05-11 15:44:43');
INSERT INTO `sys_menu` VALUES (39, '删除标签', NULL, 35, NULL, 'blog:tag:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:45:17', '2020-05-11 15:45:19');
INSERT INTO `sys_menu` VALUES (40, '评论管理', '/admin/page/comment/comment-list', 24, 'fa fa-comments', '', 5, 2, b'1', NULL, NULL, '2020-05-11 15:46:07', '2020-06-09 09:03:03');
INSERT INTO `sys_menu` VALUES (41, '查询评论', NULL, 40, NULL, 'blog:comment:query', 100, 3, b'0', NULL, NULL, '2020-05-11 15:46:51', '2020-05-11 15:46:52');
INSERT INTO `sys_menu` VALUES (42, '删除评论', NULL, 40, NULL, 'blog:comment:delete', 100, 3, b'0', NULL, NULL, '2020-05-11 15:47:19', '2020-05-11 15:47:21');
INSERT INTO `sys_menu` VALUES (43, '回复评论', NULL, 40, NULL, 'blog:comment:reply', 100, 3, b'0', NULL, NULL, '2020-05-19 20:16:52', '2020-05-19 20:16:55');
INSERT INTO `sys_menu` VALUES (44, '审核评论', '', 40, NULL, 'blog:comment:audit', 100, 3, b'0', NULL, NULL, '2020-05-23 13:16:17', '2020-05-23 13:16:19');
INSERT INTO `sys_menu` VALUES (45, '留言管理', '/admin/page/message/message-list', 24, 'fa fa-comments-o ', '', 6, 2, b'1', NULL, NULL, '2020-05-19 20:18:47', '2020-06-09 09:03:15');
INSERT INTO `sys_menu` VALUES (46, '查询留言', NULL, 45, '', 'blog:message:query', 100, 3, b'0', NULL, NULL, '2020-05-23 13:17:35', '2020-05-23 13:17:37');
INSERT INTO `sys_menu` VALUES (47, '删除留言', '', 45, NULL, 'blog:message:delete', 100, 3, b'0', NULL, NULL, '2020-05-23 13:18:09', '2020-05-23 13:18:12');
INSERT INTO `sys_menu` VALUES (48, '回复留言', NULL, 45, NULL, 'blog:message:reply', 100, 3, b'0', NULL, NULL, '2020-05-23 13:18:39', '2020-05-23 13:18:41');
INSERT INTO `sys_menu` VALUES (49, '审核留言', NULL, 45, NULL, 'blog:message:audit', 100, 3, b'0', NULL, NULL, '2020-05-23 13:19:13', '2020-05-23 13:19:15');
INSERT INTO `sys_menu` VALUES (50, '访客管理', '/admin/page/visitor/visitor-list', 82, 'fa fa-user', '', 4, 2, b'1', NULL, NULL, '2020-05-23 16:31:11', '2020-05-31 16:58:39');
INSERT INTO `sys_menu` VALUES (51, '查询访客', NULL, 50, NULL, 'sys:visitor:query', 100, 3, b'0', NULL, NULL, '2020-05-23 16:39:47', '2020-05-23 16:39:48');
INSERT INTO `sys_menu` VALUES (52, '删除访客', NULL, 50, NULL, 'sys:visitor:delete', 100, 3, b'0', NULL, NULL, '2020-05-23 16:40:22', '2020-05-23 16:40:24');
INSERT INTO `sys_menu` VALUES (53, '修改访客状态', NULL, 50, NULL, 'sys:visitor:status', 100, 3, b'0', NULL, NULL, '2020-05-23 16:40:56', '2020-05-23 16:41:00');
INSERT INTO `sys_menu` VALUES (54, '接口文档', '/swagger-ui.html', 84, 'fa fa-file-pdf-o', 'sys:swagger', 3, 2, b'1', NULL, NULL, '2020-05-23 17:24:12', '2020-05-31 17:07:22');
INSERT INTO `sys_menu` VALUES (55, '友链管理', '/admin/page/link/link-list', 24, 'fa fa-unlink', '', 7, 2, b'1', NULL, NULL, '2020-05-24 11:00:45', '2020-06-09 09:03:26');
INSERT INTO `sys_menu` VALUES (56, '查询友链', '', 55, NULL, 'blog:link:query', 100, 3, b'0', NULL, NULL, '2020-05-24 11:01:35', '2020-05-24 16:24:47');
INSERT INTO `sys_menu` VALUES (57, '添加友链', '', 55, NULL, 'blog:link:add', 100, 3, b'0', NULL, NULL, '2020-05-24 11:21:26', '2020-05-24 11:21:26');
INSERT INTO `sys_menu` VALUES (58, '修改友链', '', 55, NULL, 'blog:link:edit', 100, 3, b'0', NULL, NULL, '2020-05-24 11:22:03', '2020-05-24 11:22:48');
INSERT INTO `sys_menu` VALUES (59, '删除友链', '', 55, NULL, 'blog:link:delete', 100, 3, b'0', NULL, NULL, '2020-05-24 11:22:39', '2020-05-24 11:23:02');
INSERT INTO `sys_menu` VALUES (60, '审核友链', '', 55, NULL, 'blog:link:audit', 100, 3, b'0', NULL, NULL, '2020-05-24 11:30:47', '2020-05-24 11:30:47');
INSERT INTO `sys_menu` VALUES (61, '相册管理', '/admin/page/photo/photo-list', 24, 'fa fa-photo', '', 8, 2, b'1', NULL, NULL, '2020-05-26 10:58:59', '2020-06-09 09:03:34');
INSERT INTO `sys_menu` VALUES (62, '查询照片', '', 61, NULL, 'blog:photo:query', 100, 3, b'0', NULL, NULL, '2020-05-26 11:00:10', '2020-05-26 15:13:06');
INSERT INTO `sys_menu` VALUES (63, '添加照片', '', 61, NULL, 'blog:photo:add', 100, 3, b'0', NULL, NULL, '2020-05-26 11:00:39', '2020-05-26 15:13:14');
INSERT INTO `sys_menu` VALUES (64, '修改照片', '', 61, NULL, 'blog:photo:edit', 100, 3, b'0', NULL, NULL, '2020-05-26 11:01:11', '2020-05-26 15:13:22');
INSERT INTO `sys_menu` VALUES (65, '删除照片', '', 61, NULL, 'blog:photo:delete', 100, 3, b'0', NULL, NULL, '2020-05-26 11:01:49', '2020-05-26 15:13:29');
INSERT INTO `sys_menu` VALUES (66, '公告管理', '/admin/page/notice/notice-list', 82, 'fa fa-bullhorn', '', 5, 2, b'1', NULL, NULL, '2020-05-28 10:48:37', '2020-05-31 16:59:28');
INSERT INTO `sys_menu` VALUES (67, '查询公告', '', 66, NULL, 'sys:notice:query', 100, 3, b'0', NULL, NULL, '2020-05-28 10:49:11', '2020-05-28 10:49:11');
INSERT INTO `sys_menu` VALUES (68, '添加公告', '', 66, NULL, 'sys:notice:add', 100, 3, b'0', NULL, NULL, '2020-05-28 10:49:49', '2020-05-28 10:49:49');
INSERT INTO `sys_menu` VALUES (69, '修改公告', '', 66, NULL, 'sys:notice:edit', 100, 3, b'0', NULL, NULL, '2020-05-28 10:50:17', '2020-05-28 10:50:17');
INSERT INTO `sys_menu` VALUES (70, '删除公告', '', 66, NULL, 'sys:notice:delete', 100, 3, b'0', NULL, NULL, '2020-05-28 10:50:51', '2020-05-28 10:50:51');
INSERT INTO `sys_menu` VALUES (71, '本地存储', '/admin/page/localstorage/localstorage-list', 84, 'fa fa-floppy-o', '', 1, 2, b'1', NULL, NULL, '2020-05-29 11:27:10', '2020-05-31 17:06:51');
INSERT INTO `sys_menu` VALUES (72, '查询本地文件', '', 71, NULL, 'sys:localstorage:query', 100, 3, b'0', NULL, NULL, '2020-05-29 11:28:36', '2020-05-29 11:28:36');
INSERT INTO `sys_menu` VALUES (73, '上传本地文件', '', 71, NULL, 'sys:localstorage:add', 100, 3, b'0', NULL, NULL, '2020-05-29 11:29:23', '2020-05-29 11:29:23');
INSERT INTO `sys_menu` VALUES (74, '修改本地文件', '', 71, NULL, 'sys:localstorage:edit', 100, 3, b'0', NULL, NULL, '2020-05-29 11:30:24', '2020-05-29 11:30:24');
INSERT INTO `sys_menu` VALUES (75, '删除本地文件', '', 71, NULL, 'sys:localstorage:delete', 100, 3, b'0', NULL, NULL, '2020-05-29 11:30:54', '2020-05-29 11:30:54');
INSERT INTO `sys_menu` VALUES (76, '七牛云存储', '/admin/page/qiniucontent/qiniucontent-list', 84, 'fa fa-file-zip-o', '', 2, 2, b'1', NULL, NULL, '2020-05-31 09:55:45', '2020-05-31 17:07:06');
INSERT INTO `sys_menu` VALUES (77, '查询文件', '', 76, NULL, 'sys:qiniu:query', 100, 3, b'0', NULL, NULL, '2020-05-31 09:56:42', '2020-05-31 09:57:12');
INSERT INTO `sys_menu` VALUES (78, '上传文件', '', 76, NULL, 'sys:qiniu:add', 100, 3, b'0', NULL, NULL, '2020-05-31 09:57:44', '2020-05-31 09:57:44');
INSERT INTO `sys_menu` VALUES (79, '同步文件', '', 76, NULL, 'sys:qiniu:sync', 100, 3, b'0', NULL, NULL, '2020-05-31 09:58:23', '2020-05-31 09:58:23');
INSERT INTO `sys_menu` VALUES (80, '删除文件', '', 76, NULL, 'sys:qiniu:delete', 100, 3, b'0', NULL, NULL, '2020-05-31 09:58:52', '2020-05-31 09:58:52');
INSERT INTO `sys_menu` VALUES (82, '系统管理', '', 1, 'fa fa-gears', 'sys:sys', 1, 2, b'1', NULL, NULL, '2020-05-31 16:46:37', '2020-05-31 16:58:17');
INSERT INTO `sys_menu` VALUES (83, '系统监控', '', 1, 'fa fa-thermometer', 'sys:monitor', 2, 2, b'1', NULL, NULL, '2020-05-31 17:02:57', '2020-05-31 17:02:57');
INSERT INTO `sys_menu` VALUES (84, '系统工具', '', 1, 'fa fa-wrench', 'sys:tools', 3, 2, b'1', NULL, NULL, '2020-05-31 17:06:32', '2020-05-31 17:06:32');
INSERT INTO `sys_menu` VALUES (86, '配置七牛云', '', 76, NULL, 'sys:qiniu:config', 100, 3, b'0', NULL, NULL, '2020-05-31 20:36:28', '2020-05-31 20:36:28');
INSERT INTO `sys_menu` VALUES (87, ' 审核文章', '', 26, NULL, 'blog:article:audit', 100, 3, b'0', NULL, NULL, '2020-06-12 10:32:49', '2020-06-12 10:32:49');

-- ----------------------------
-- Table structure for sys_notice
-- ----------------------------
DROP TABLE IF EXISTS `sys_notice`;
CREATE TABLE `sys_notice`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容',
  `sort` smallint(4) NULL DEFAULT NULL COMMENT '排序值',
  `display` bit(1) NULL DEFAULT NULL COMMENT '是否显示',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_notice_sort`(`sort`) USING BTREE,
  INDEX `idx_notice_createTime`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_notice
-- ----------------------------
INSERT INTO `sys_notice` VALUES (12, '完成了代码中的常量抽取等', '完成了代码中的常量抽取等', 1, b'1', '2020-06-15 17:00:16', '2020-06-15 17:00:16');
INSERT INTO `sys_notice` VALUES (13, '完善了Swagger文档，重构API等', '完善了Swagger文档，重构API等', 2, b'1', '2020-06-15 17:01:42', '2020-06-15 18:47:28');
INSERT INTO `sys_notice` VALUES (14, '后台弹出层换成了SweetAlert2等', '后台弹出层换成了SweetAlert2等', 4, b'1', '2020-06-15 18:46:14', '2020-06-15 18:47:16');
INSERT INTO `sys_notice` VALUES (15, '前台实现了图片懒加载等', '前台实现了图片懒加载等', 5, b'1', '2020-06-15 18:47:50', '2020-06-15 18:47:50');
INSERT INTO `sys_notice` VALUES (16, '整合了ElasticSearch用于前台搜索等', '整合了ElasticSearch用于前台搜索等', 6, b'1', '2020-06-15 18:48:17', '2020-06-15 18:48:17');
INSERT INTO `sys_notice` VALUES (17, '整合了Redis用作缓存等', '整合了Redis用作缓存等', 6, b'1', '2020-06-15 18:49:03', '2020-06-15 18:49:03');
INSERT INTO `sys_notice` VALUES (18, '后台添加了七牛云存储管理等', '后台添加了七牛云存储管理等', 7, b'1', '2020-06-15 18:49:38', '2020-06-15 18:49:38');
INSERT INTO `sys_notice` VALUES (19, '后台添加了本地存储等', '后台添加了本地存储等', 8, b'1', '2020-06-15 18:49:56', '2020-06-15 18:49:56');
INSERT INTO `sys_notice` VALUES (20, '后台添加了仪表盘等', '后台添加了仪表盘等', 9, b'1', '2020-06-15 18:50:31', '2020-06-15 18:50:31');
INSERT INTO `sys_notice` VALUES (21, '后台添加了相册管理等', '后台添加了相册管理等', 10, b'1', '2020-06-15 18:51:02', '2020-06-15 18:51:02');

-- ----------------------------
-- Table structure for sys_operation_log
-- ----------------------------
DROP TABLE IF EXISTS `sys_operation_log`;
CREATE TABLE `sys_operation_log`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `exception_detail` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '异常详情',
  `log_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类型[info, error...]',
  `method` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '执行方法名称',
  `params` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '参数名称',
  `request_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '请求IP',
  `time` bigint(20) NULL DEFAULT NULL COMMENT '请求耗时',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `browser` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'IP来源',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '请求结果[0:失败, 1:成功]',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_operationLog_createTime`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6308 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `role_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名称',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `rank` smallint(4) NULL DEFAULT NULL COMMENT '级别',
  `color` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '颜色',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '启用状态[0:停用, 1:启用]',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_role_roleName`(`role_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, '管理员', 'admin', 1, 'red', 1, '2020-06-14 18:24:48', '2020-06-14 19:13:37');
INSERT INTO `sys_role` VALUES (2, '审核人员', 'auditor', 2, 'orange', 1, '2020-06-14 19:10:18', '2020-06-15 20:12:24');
INSERT INTO `sys_role` VALUES (3, '作者', 'author', 3, 'green', 1, '2020-06-14 19:16:25', '2020-06-15 20:11:45');

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  `menu_id` bigint(20) NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE,
  INDEX `fk_menu_id`(`menu_id`) USING BTREE,
  CONSTRAINT `fk_menu_id` FOREIGN KEY (`menu_id`) REFERENCES `sys_menu` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `fk_role_id2` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (1, 1);
INSERT INTO `sys_role_menu` VALUES (2, 1);
INSERT INTO `sys_role_menu` VALUES (3, 1);
INSERT INTO `sys_role_menu` VALUES (1, 2);
INSERT INTO `sys_role_menu` VALUES (1, 3);
INSERT INTO `sys_role_menu` VALUES (1, 4);
INSERT INTO `sys_role_menu` VALUES (1, 5);
INSERT INTO `sys_role_menu` VALUES (1, 6);
INSERT INTO `sys_role_menu` VALUES (1, 7);
INSERT INTO `sys_role_menu` VALUES (1, 8);
INSERT INTO `sys_role_menu` VALUES (1, 9);
INSERT INTO `sys_role_menu` VALUES (1, 10);
INSERT INTO `sys_role_menu` VALUES (1, 11);
INSERT INTO `sys_role_menu` VALUES (1, 12);
INSERT INTO `sys_role_menu` VALUES (1, 13);
INSERT INTO `sys_role_menu` VALUES (1, 14);
INSERT INTO `sys_role_menu` VALUES (1, 15);
INSERT INTO `sys_role_menu` VALUES (1, 16);
INSERT INTO `sys_role_menu` VALUES (1, 17);
INSERT INTO `sys_role_menu` VALUES (1, 18);
INSERT INTO `sys_role_menu` VALUES (1, 19);
INSERT INTO `sys_role_menu` VALUES (1, 20);
INSERT INTO `sys_role_menu` VALUES (1, 21);
INSERT INTO `sys_role_menu` VALUES (1, 22);
INSERT INTO `sys_role_menu` VALUES (1, 23);
INSERT INTO `sys_role_menu` VALUES (1, 24);
INSERT INTO `sys_role_menu` VALUES (2, 24);
INSERT INTO `sys_role_menu` VALUES (3, 24);
INSERT INTO `sys_role_menu` VALUES (1, 25);
INSERT INTO `sys_role_menu` VALUES (3, 25);
INSERT INTO `sys_role_menu` VALUES (1, 26);
INSERT INTO `sys_role_menu` VALUES (2, 26);
INSERT INTO `sys_role_menu` VALUES (3, 26);
INSERT INTO `sys_role_menu` VALUES (1, 27);
INSERT INTO `sys_role_menu` VALUES (2, 27);
INSERT INTO `sys_role_menu` VALUES (3, 27);
INSERT INTO `sys_role_menu` VALUES (1, 28);
INSERT INTO `sys_role_menu` VALUES (3, 28);
INSERT INTO `sys_role_menu` VALUES (1, 29);
INSERT INTO `sys_role_menu` VALUES (2, 29);
INSERT INTO `sys_role_menu` VALUES (1, 30);
INSERT INTO `sys_role_menu` VALUES (3, 30);
INSERT INTO `sys_role_menu` VALUES (1, 31);
INSERT INTO `sys_role_menu` VALUES (3, 31);
INSERT INTO `sys_role_menu` VALUES (1, 32);
INSERT INTO `sys_role_menu` VALUES (3, 32);
INSERT INTO `sys_role_menu` VALUES (1, 33);
INSERT INTO `sys_role_menu` VALUES (3, 33);
INSERT INTO `sys_role_menu` VALUES (1, 34);
INSERT INTO `sys_role_menu` VALUES (1, 35);
INSERT INTO `sys_role_menu` VALUES (3, 35);
INSERT INTO `sys_role_menu` VALUES (1, 36);
INSERT INTO `sys_role_menu` VALUES (3, 36);
INSERT INTO `sys_role_menu` VALUES (1, 37);
INSERT INTO `sys_role_menu` VALUES (3, 37);
INSERT INTO `sys_role_menu` VALUES (1, 38);
INSERT INTO `sys_role_menu` VALUES (3, 38);
INSERT INTO `sys_role_menu` VALUES (1, 39);
INSERT INTO `sys_role_menu` VALUES (1, 40);
INSERT INTO `sys_role_menu` VALUES (2, 40);
INSERT INTO `sys_role_menu` VALUES (3, 40);
INSERT INTO `sys_role_menu` VALUES (1, 41);
INSERT INTO `sys_role_menu` VALUES (2, 41);
INSERT INTO `sys_role_menu` VALUES (3, 41);
INSERT INTO `sys_role_menu` VALUES (1, 42);
INSERT INTO `sys_role_menu` VALUES (2, 42);
INSERT INTO `sys_role_menu` VALUES (1, 43);
INSERT INTO `sys_role_menu` VALUES (3, 43);
INSERT INTO `sys_role_menu` VALUES (1, 44);
INSERT INTO `sys_role_menu` VALUES (2, 44);
INSERT INTO `sys_role_menu` VALUES (1, 45);
INSERT INTO `sys_role_menu` VALUES (2, 45);
INSERT INTO `sys_role_menu` VALUES (3, 45);
INSERT INTO `sys_role_menu` VALUES (1, 46);
INSERT INTO `sys_role_menu` VALUES (2, 46);
INSERT INTO `sys_role_menu` VALUES (3, 46);
INSERT INTO `sys_role_menu` VALUES (1, 47);
INSERT INTO `sys_role_menu` VALUES (2, 47);
INSERT INTO `sys_role_menu` VALUES (1, 48);
INSERT INTO `sys_role_menu` VALUES (3, 48);
INSERT INTO `sys_role_menu` VALUES (1, 49);
INSERT INTO `sys_role_menu` VALUES (2, 49);
INSERT INTO `sys_role_menu` VALUES (1, 50);
INSERT INTO `sys_role_menu` VALUES (1, 51);
INSERT INTO `sys_role_menu` VALUES (1, 52);
INSERT INTO `sys_role_menu` VALUES (1, 53);
INSERT INTO `sys_role_menu` VALUES (1, 54);
INSERT INTO `sys_role_menu` VALUES (1, 55);
INSERT INTO `sys_role_menu` VALUES (2, 55);
INSERT INTO `sys_role_menu` VALUES (1, 56);
INSERT INTO `sys_role_menu` VALUES (2, 56);
INSERT INTO `sys_role_menu` VALUES (1, 57);
INSERT INTO `sys_role_menu` VALUES (1, 58);
INSERT INTO `sys_role_menu` VALUES (1, 59);
INSERT INTO `sys_role_menu` VALUES (2, 59);
INSERT INTO `sys_role_menu` VALUES (1, 60);
INSERT INTO `sys_role_menu` VALUES (2, 60);
INSERT INTO `sys_role_menu` VALUES (1, 61);
INSERT INTO `sys_role_menu` VALUES (1, 62);
INSERT INTO `sys_role_menu` VALUES (1, 63);
INSERT INTO `sys_role_menu` VALUES (1, 64);
INSERT INTO `sys_role_menu` VALUES (1, 65);
INSERT INTO `sys_role_menu` VALUES (1, 66);
INSERT INTO `sys_role_menu` VALUES (2, 66);
INSERT INTO `sys_role_menu` VALUES (3, 66);
INSERT INTO `sys_role_menu` VALUES (1, 67);
INSERT INTO `sys_role_menu` VALUES (2, 67);
INSERT INTO `sys_role_menu` VALUES (3, 67);
INSERT INTO `sys_role_menu` VALUES (1, 68);
INSERT INTO `sys_role_menu` VALUES (1, 69);
INSERT INTO `sys_role_menu` VALUES (1, 70);
INSERT INTO `sys_role_menu` VALUES (1, 71);
INSERT INTO `sys_role_menu` VALUES (3, 71);
INSERT INTO `sys_role_menu` VALUES (1, 72);
INSERT INTO `sys_role_menu` VALUES (3, 72);
INSERT INTO `sys_role_menu` VALUES (1, 73);
INSERT INTO `sys_role_menu` VALUES (3, 73);
INSERT INTO `sys_role_menu` VALUES (1, 74);
INSERT INTO `sys_role_menu` VALUES (1, 75);
INSERT INTO `sys_role_menu` VALUES (1, 76);
INSERT INTO `sys_role_menu` VALUES (3, 76);
INSERT INTO `sys_role_menu` VALUES (1, 77);
INSERT INTO `sys_role_menu` VALUES (3, 77);
INSERT INTO `sys_role_menu` VALUES (1, 78);
INSERT INTO `sys_role_menu` VALUES (3, 78);
INSERT INTO `sys_role_menu` VALUES (1, 79);
INSERT INTO `sys_role_menu` VALUES (3, 79);
INSERT INTO `sys_role_menu` VALUES (1, 80);
INSERT INTO `sys_role_menu` VALUES (1, 82);
INSERT INTO `sys_role_menu` VALUES (2, 82);
INSERT INTO `sys_role_menu` VALUES (3, 82);
INSERT INTO `sys_role_menu` VALUES (1, 83);
INSERT INTO `sys_role_menu` VALUES (1, 84);
INSERT INTO `sys_role_menu` VALUES (3, 84);
INSERT INTO `sys_role_menu` VALUES (1, 86);
INSERT INTO `sys_role_menu` VALUES (1, 87);
INSERT INTO `sys_role_menu` VALUES (2, 87);

-- ----------------------------
-- Table structure for sys_role_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_user`;
CREATE TABLE `sys_role_user`  (
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  PRIMARY KEY (`role_id`, `user_id`) USING BTREE,
  INDEX `fk_user_id`(`user_id`) USING BTREE,
  CONSTRAINT `fk_role_id` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `fk_user_id` FOREIGN KEY (`user_id`) REFERENCES `sys_user` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_role_user
-- ----------------------------
INSERT INTO `sys_role_user` VALUES (1, 1);
INSERT INTO `sys_role_user` VALUES (2, 2);
INSERT INTO `sys_role_user` VALUES (3, 3);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `sex` bit(1) NULL DEFAULT NULL COMMENT '性别[0:女, 1:男]',
  `phone` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号码',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '启用状态[0:停用, 1:启用]',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_user_username`(`username`) USING BTREE,
  UNIQUE INDEX `idx_user_email`(`email`) USING BTREE,
  UNIQUE INDEX `idx_user_phone`(`phone`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'admin', '$2a$10$VScwIR7yyX1qn26gLnLMueui1hjqBitSJSTgyP8bj3aQhcUTKL0DS', '管理员1', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', 'm18600000000@163.com', b'1', '18600000000', 1, '2020-06-14 18:23:46', '2020-06-14 18:23:49');
INSERT INTO `sys_user` VALUES (2, 'auditor001', '$2a$10$5Lrp77eKEBX.8Wm9SJ4hLedB7/bjEU8NyvDClShNhY695JZGiUWR6', '审核人员1', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', 'm18600000001@163.com', b'1', '18600000001', 1, '2020-06-14 19:20:24', '2020-06-14 19:20:24');
INSERT INTO `sys_user` VALUES (3, 'author001', '$2a$10$nvQmOp1mJIPZFAxvbf0Rf.gKnFPHtjgaE3ZnGkT6CwKIiYM9UkxaW', '作者1', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', 'm18600000002@163.com', b'0', '18600000002', 1, '2020-06-14 19:21:01', '2020-06-14 19:21:01');

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '摘要',
  `content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'html内容',
  `text_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'markdown内容',
  `cover` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '封面',
  `type` tinyint(2) NULL DEFAULT NULL COMMENT '类型[1:原创, 2:转载, 3:翻译]',
  `views` int(11) NULL DEFAULT NULL COMMENT '浏览量',
  `likes` int(11) NULL DEFAULT NULL COMMENT '点赞量',
  `comments` int(11) NULL DEFAULT NULL COMMENT '评论量',
  `appreciable` bit(1) NULL DEFAULT NULL COMMENT '开启赞赏',
  `commentable` bit(1) NULL DEFAULT NULL COMMENT '开启评论',
  `top` bit(1) NULL DEFAULT NULL COMMENT '开启置顶',
  `recommend` bit(1) NULL DEFAULT NULL COMMENT '开启推荐',
  `published` bit(1) NULL DEFAULT NULL COMMENT '是否发布',
  `sort` tinyint(2) NULL DEFAULT NULL COMMENT '排序评分',
  `author_id` bigint(20) NULL DEFAULT NULL COMMENT '作者ID',
  `category_id` bigint(20) NULL DEFAULT NULL COMMENT '分类ID',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '审核状态[0:审核未过, 1:等待审核, 2:审核通过]',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_article_category`(`category_id`) USING BTREE,
  INDEX `idx_article_title`(`title`) USING BTREE,
  INDEX `idx_article_createTime`(`create_time`) USING BTREE,
  INDEX `idx_article_summary`(`summary`) USING BTREE,
  INDEX `idx_article_cover`(`cover`) USING BTREE,
  INDEX `idx_article_sort`(`sort`) USING BTREE,
  INDEX `fk_article_user`(`author_id`) USING BTREE,
  CONSTRAINT `fk_article_category` FOREIGN KEY (`category_id`) REFERENCES `t_category` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `fk_article_user` FOREIGN KEY (`author_id`) REFERENCES `sys_user` (`id`) ON DELETE SET NULL ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (1, '认识SSM框架和Redis', 'JavaEE互联网轻量级框架整合开发第一章', '<h2 id=\"h2-spring-\"><a name=\"Spring框架：应用最广泛的框架\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring框架：应用最广泛的框架</h2><p>成功来自于理念：</p>\n<ul>\n<li>IoC（Inversion of Control，控制反转）</li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul>\n<h3 id=\"h3-spring-ioc\"><a name=\"Spring IoC\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring IoC</h3><p>IoC是一个容器，容器的目标是管理Java Bean和他们之间的关系。</p>\n<p>JavaBean之间存在一定的依赖关系，比如班级是依赖学生和老师组成的。</p>\n<p>Spring Ioc管理对象及其依赖关系，采用的不是人为的主动创建，而是由Spring IoC自己通过描述创建的，也就是说Spring是依靠描述来完成对象的创建及其依赖关系的。</p>\n<p>例子：使用插座</p>\n<p><img src=\"http://cdn.alanliang.site/note/使用插座图.jpg\" alt=\"使用插座\"></p>\n<p>用传统的方式管理对象</p>\n<p>现在使用插座1,代码如下：</p>\n<pre><code class=\"lang-java\">Socket socket = new Socket1();\nuser.setSocket(socket);\nuser.userSocket;\n</code></pre>\n<p>这样会使接口Socket和实现类Socket1捆绑起来，即发生了耦合。如果想要使用其他插座，就要修改代码。比如现在换成使用插座2，代码如下：</p>\n<pre><code class=\"lang-java\">Socket socket = new Socket2();\nuser.setSocket(socket);\nuser.userSocket;\n</code></pre>\n<p>可以看出，每一次更换插座都需要修改源代码。一个大型的互联网项目中的对象成千上万，修改源代码会使得项目难以维护。</p>\n<p>用Spring IoC容器管理对象</p>\n<p>现在，我们不用new的方式创建对象了，而是使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。先用一段XML描述插座和用户的引用插座1，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;socket&quot; class=&quot;Socket1&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;user&quot; class=&quot;User&quot;&gt;\n    &lt;property name=&quot;socket&quot; ref=&quot;socket&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>当我们想要更换成使用插座2时，只需要修改上面的配置文件，就可以向用户注入插座2，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;socket&quot; class=&quot;Socket2&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;user&quot; class=&quot;User&quot;&gt;\n    &lt;property name=&quot;socket&quot; ref=&quot;socket&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>这个时候Socket接口就可以不依赖于任何插座了，而是通过配置进行切换，如图所示：</p>\n<p><img src=\"http://cdn.alanliang.site/note/Spring的控制反转.png\" alt=\"Spring的控制反转\"></p>\n<p>图中的配置信息是“我要插座2”，相当于XML依赖关系配置，这个时候Spring IoC只会拿到插座2，然后通过国家插座标准接口注入给使用者，提供给使用者使用。</p>\n<p>这样，你不需要去找资源，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源。</p>\n<h3 id=\"h3-spring-aop\"><a name=\"Spring AOP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring AOP</h3><p>订单超预算例子：</p>\n<p><img src=\"http://cdn.alanliang.site/note/订单超预算.png\" alt=\"订单超预算\"></p>\n<p>实线是订单提交的流程，需显示订单驳回的流程，影响他们的条件是预算超额，这是一个切面条件。</p>\n<p>Spring AOP常用于数据库事务的编程，很多情况像上面的例子一样，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失败，会使用数据库事务回滚功能去回滚事务，使得第一步的数据库操作更新也作废。Spring AOP实现了当Spring接收到了异常信息，就会回滚事务，不需要代码实现。伪代码如下：</p>\n<pre><code class=\"lang-java\">/**\n* Spring AOP处理订单伪代码\n* @param order 订单\n**/\nprivate void proceed(Order order){\n    //判断生产部门是否通过订单，数据库记录订单\n    boolean pflag = productionDept.isPass(order);\n    if(pflag){//如果生产部门通过进行财务部门审批\n        if(financialDept.isOverBudget(order)){//财务审批是否超限\n            throw new RuntimeException(&quot;预算超限！！！&quot;);\n        }\n    }\n}\n</code></pre>\n<p>这里我们完全看不到数据库代码，也没有复杂的try…catch…finally…语句。有了Spring AOP，我们只需要关注业务代码，知道只要发生了异常，Spring会回滚事务就足够了。</p>\n<h2 id=\"h2-mybatis\"><a name=\"MyBatis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MyBatis</h2><p>一个基于Java的持久层框架。提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性。</p>\n<h2 id=\"h2-hibernate\"><a name=\"Hibernate\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Hibernate</h2><p>完全面向POJO</p>\n<p>Hibernate和Mybatis的区别</p>\n<ul>\n<li><p>Hibernate不需要接口和SQL，而Mybatis需要，因此Mybatis的工作量较大；</p>\n</li><li><p>Hibernate性能较低，但在管理系统时代发挥巨大作用。而Mybatis性能较高，更适合于当今性能要求高、响应快的互联网时代。</p>\n</li><li><p>Mybatis较Hibernate更加灵活，可以自由书写SQL、支持动态SQL、支持存储过程等</p>\n</li></ul>\n<h2 id=\"h2-spring-mvc\"><a name=\"Spring MVC\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring MVC</h2><p>结构层次清晰，与Spring的IoC和AOP无缝对接，成为了互联网时代的主流框架。</p>\n<h2 id=\"h2-redis\"><a name=\"Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis</h2><p>最为流行的NoSQL，将常用数据放在内存中，可以大幅度提高互联网系统性能。</p>\n', '##Spring框架：应用最广泛的框架\n\n成功来自于理念：\n\n- IoC（Inversion of Control，控制反转）\n- AOP（Aspect Oriented Programming，面向切面编程）\n\n###Spring IoC\n\nIoC是一个容器，容器的目标是管理Java Bean和他们之间的关系。\n\nJavaBean之间存在一定的依赖关系，比如班级是依赖学生和老师组成的。\n\nSpring Ioc管理对象及其依赖关系，采用的不是人为的主动创建，而是由Spring IoC自己通过描述创建的，也就是说Spring是依靠描述来完成对象的创建及其依赖关系的。\n\n例子：使用插座\n\n![使用插座](http://cdn.alanliang.site/note/使用插座图.jpg)\n\n用传统的方式管理对象\n\n现在使用插座1,代码如下：\n\n```java\nSocket socket = new Socket1();\nuser.setSocket(socket);\nuser.userSocket;\n```\n\n这样会使接口Socket和实现类Socket1捆绑起来，即发生了耦合。如果想要使用其他插座，就要修改代码。比如现在换成使用插座2，代码如下：\n\n```java\nSocket socket = new Socket2();\nuser.setSocket(socket);\nuser.userSocket;\n```\n\n可以看出，每一次更换插座都需要修改源代码。一个大型的互联网项目中的对象成千上万，修改源代码会使得项目难以维护。\n\n用Spring IoC容器管理对象\n\n现在，我们不用new的方式创建对象了，而是使用配置的方式，然后让Spring IoC容器自己通过配置去找到插座。先用一段XML描述插座和用户的引用插座1，代码如下：\n\n```xml\n<bean id=\"socket\" class=\"Socket1\"></bean>\n<bean id=\"user\" class=\"User\">\n	<property name=\"socket\" ref=\"socket\"></property>\n</bean>\n```\n\n当我们想要更换成使用插座2时，只需要修改上面的配置文件，就可以向用户注入插座2，代码如下：\n\n```xml\n<bean id=\"socket\" class=\"Socket2\"></bean>\n<bean id=\"user\" class=\"User\">\n	<property name=\"socket\" ref=\"socket\"></property>\n</bean>\n```\n\n这个时候Socket接口就可以不依赖于任何插座了，而是通过配置进行切换，如图所示：\n\n![Spring的控制反转](http://cdn.alanliang.site/note/Spring的控制反转.png)\n\n图中的配置信息是“我要插座2”，相当于XML依赖关系配置，这个时候Spring IoC只会拿到插座2，然后通过国家插座标准接口注入给使用者，提供给使用者使用。\n\n这样，你不需要去找资源，只要向Spring IoC容器描述所需资源，Spring IoC自己会找到你所需要的资源。\n\n###Spring AOP\n\n订单超预算例子：\n\n![订单超预算](http://cdn.alanliang.site/note/订单超预算.png)\n\n实线是订单提交的流程，需显示订单驳回的流程，影响他们的条件是预算超额，这是一个切面条件。\n\nSpring AOP常用于数据库事务的编程，很多情况像上面的例子一样，我们在做完第一步数据库数据更新后，不知道下一步是否会成功，如果下一步失败，会使用数据库事务回滚功能去回滚事务，使得第一步的数据库操作更新也作废。Spring AOP实现了当Spring接收到了异常信息，就会回滚事务，不需要代码实现。伪代码如下：\n\n```java\n/**\n* Spring AOP处理订单伪代码\n* @param order 订单\n**/\nprivate void proceed(Order order){\n    //判断生产部门是否通过订单，数据库记录订单\n    boolean pflag = productionDept.isPass(order);\n    if(pflag){//如果生产部门通过进行财务部门审批\n        if(financialDept.isOverBudget(order)){//财务审批是否超限\n            throw new RuntimeException(\"预算超限！！！\");\n        }\n    }\n}\n```\n\n这里我们完全看不到数据库代码，也没有复杂的try...catch...finally...语句。有了Spring AOP，我们只需要关注业务代码，知道只要发生了异常，Spring会回滚事务就足够了。\n\n##MyBatis\n\n一个基于Java的持久层框架。提供自动映射、动态SQL、级联、缓存、注解、代码和SQL分离等特性。\n\n##Hibernate\n\n完全面向POJO\n\nHibernate和Mybatis的区别\n\n- Hibernate不需要接口和SQL，而Mybatis需要，因此Mybatis的工作量较大；\n\n- Hibernate性能较低，但在管理系统时代发挥巨大作用。而Mybatis性能较高，更适合于当今性能要求高、响应快的互联网时代。\n\n- Mybatis较Hibernate更加灵活，可以自由书写SQL、支持动态SQL、支持存储过程等\n\n##Spring MVC\n\n结构层次清晰，与Spring的IoC和AOP无缝对接，成为了互联网时代的主流框架。\n\n##Redis\n\n最为流行的NoSQL，将常用数据放在内存中，可以大幅度提高互联网系统性能。\n\n', 'http://cdn.alanliang.site/note/oilpainting1.jpg', 1, 0, 0, 0, b'0', b'1', b'0', b'0', b'1', 1, 3, 1, 2, '2020-06-14 19:39:08', '2020-06-15 10:42:27');
INSERT INTO `t_article` VALUES (2, 'Java设计模式', 'JavaEE互联网轻量级框架整合开发第二章', '<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>在Java框架中运用了很多的设计模式，常见的包括<strong>代理模式</strong>、<strong>责任链模式</strong>、<strong>观察者模式</strong>、<strong>普通工厂模式</strong>、<strong>抽象工厂模式</strong>和<strong>建造者模式</strong>等，那么下面让我们一起来了解一下。</p>\n<h2 id=\"h2-1-\"><a name=\"1    什么是设计模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1    什么是设计模式</h2><blockquote>\n<p><strong>设计模式</strong>（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n</blockquote>\n<h2 id=\"h2-2-java-\"><a name=\"2    Java反射技术\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2    Java反射技术</h2><p>Java反射技术应用广泛，能够配置类的<strong>全限定名</strong>、<strong>方法</strong>和<strong>参数</strong>，<strong>完成对象的初始化</strong>等，增强了Java的可配置性，绝大数框架的基本原理也是基于这个技术。</p>\n<p>我们简单了解一下反射的应用：</p>\n<h3 id=\"h3-2-1-\"><a name=\"2.1    通过反射构建对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1    通过反射构建对象</h3><p>（1）通过<strong>无参构造</strong>方式构建对象，代码如下：</p>\n<pre><code class=\"lang-java\">public class ReflectServiceImpl {\n    public void sayHello(String name) {\n        System.err.println(&quot;Hello &quot; + name);\n    }\n\n    public ReflectServiceImpl getInstance(){\n        ReflectServiceImpl object =null;\n        try {\n            //通过反射生成对象\n            object= (ReflectServiceImpl) Class.forName(&quot;com.ssm.learn.chapter2.reflect.ReflectServiceImpl&quot;).newInstance();\n\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return object;\n    }\n}\n</code></pre>\n<p>（2）通过<strong>有参构造</strong>方式构建对象，代码如下：</p>\n<pre><code class=\"lang-java\">public class ReflectServiceImpl2 {\n\n    private String name;\n\n    public ReflectServiceImpl2(String name) {\n        this.name = name;\n    }\n\n    public void sayHello(String name) {\n        System.err.println(&quot;Hello &quot; + name);\n    }\n\n    public ReflectServiceImpl2 getInstance(){\n        ReflectServiceImpl2 object =null;\n        try {\n             //通过反射生成对象\n            object= (ReflectServiceImpl2) Class.forName(&quot;com.ssm.learn.chapter2.reflect.ReflectServiceImpl2&quot;)\n                    .getConstructor(String.class)\n                    .newInstance(&quot;张三&quot;);\n\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return object;\n    }\n}\n</code></pre>\n<ul>\n<li><p>反射的<strong>优点</strong>：只要配置就可以生成对象，可以解除程序的耦合度。</p>\n</li><li><p>反射的<strong>缺点</strong>：运行较慢。</p>\n</li></ul>\n<p>Spring IoC大部分情况下为了灵活度、降低耦合度，而使用反射是值得的。</p>\n<h3 id=\"h3-2-2-\"><a name=\"2.2    反射方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2    反射方法</h3><p>代码如下：</p>\n<pre><code class=\"lang-java\">public Object reflectMethod() {\n        Object returnObj = null;\n        ReflectServiceImpl target = new ReflectServiceImpl();\n        try {\n            //Method method = ReflectServiceImpl.class.getMethod(&quot;sayHello&quot;, String.class);\n\n            //当有具体对象target但不知道它是哪个类的可以这样写\n            Method method = target.getClass().getMethod(&quot;sayHello&quot;, String.class);\n            //调用方法，相当于target.sayHello(&quot;张三&quot;)\n            returnObj = method.invoke(target, &quot;张三&quot;);\n\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return returnObj;\n    }\n</code></pre>\n<h3 id=\"h3-2-3-\"><a name=\"2.3    实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3    实例</h3><p>代码如下：</p>\n<pre><code class=\"lang-java\">public static Object reflect() {\n    ReflectServiceImpl object = null;\n    try {\n        object = (ReflectServiceImpl) Class.forName(&quot;com.ssm.learn.chapter2.reflect.ReflectServiceImpl&quot;)\n                .newInstance();\n        Method method = object.getClass().getMethod(&quot;sayHello&quot;, String.class);\n        method.invoke(object,&quot;张三&quot;);\n    } catch (InstantiationException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchMethodException e) {\n        e.printStackTrace();\n    } catch (InvocationTargetException e) {\n        e.printStackTrace();\n    }\n    return object;\n}\n\npublic static void main(String[] args) {\n    ReflectServiceImpl.reflect();\n}\n</code></pre>\n<p>运行程序，得到以下结果：</p>\n<pre><code>Hello 张三\n</code></pre><h2 id=\"h2-3-\"><a name=\"3    动态代理模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3    动态代理模式</h2><p><strong>动态代理的意义在于生成一个占位（又称为代理对象），来代理真实对象，从而控制真实对象的访问。</strong></p>\n<p>举个例子：客户来软件公司谈需求不会直接跟软件工程师谈，而是去找商务谈，客户认为商务代表了公司。如下图所示：</p>\n<p><img src=\"http://cdn.alanliang.site/note/代理模式示意图.png\" alt=\"代理模式示意图\"></p>\n<p><strong>代理的作用：在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象。</strong></p>\n<p>代理分为两个步骤：</p>\n<ol>\n<li><p><strong>代理对象和真实对象之间建立代理关系</strong></p>\n</li><li><p><strong>实现代理对象的代理逻辑方法</strong></p>\n</li></ol>\n<p>Java中最常用的动态代理技术有：</p>\n<ul>\n<li><p><strong>JDK动态代理</strong>。JDK自带功能，必须使用接口，比较复杂</p>\n</li><li><p><strong>CGLIB</strong>。第三方提供技术，不必使用接口，比较简单</p>\n<h3 id=\"h3-3-1jdk-\"><a name=\"3.1JDK动态代理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1JDK动态代理</h3></li></ul>\n<p>首先定义<code>HelloWorld</code>接口，代码如下：</p>\n<pre><code class=\"lang-java\">public interface HelloWorld{\n    public void sayHelloWorld();\n}\n</code></pre>\n<p>然后提供实现类<code>HelloWorldImp</code>l来实现接口，代码如下：</p>\n<pre><code class=\"lang-java\">public class HelloWorldImpl implements HelloWorld{\n    @Override\n    public void sayHelloWorld(){\n        System.out.println(&quot;Hello World&quot;);\n    }\n}\n</code></pre>\n<p>动态代理绑定和代理逻辑实现，代码如下：</p>\n<pre><code class=\"lang-java\">public class JdkProxyExample implements InvocationHandler {\n\n    //真实对象\n    private Object target = null;\n\n    /**\n     * 建立代理对象和真实对象的代理关系\n     *\n     * @param target 真实对象\n     * @return 代理对象\n     */\n    public Object bind(Object target) {\n        this.target = target;\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    }\n\n    /**\n     * 代理方法逻辑\n     * @param proxy 代理对象\n     * @param method 当前调度方法\n     * @param args 当前方法参数\n     * @return 代理结果返回\n     * @throws Throwable 异常\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(&quot;进入代理逻辑方法&quot;);\n        System.out.println(&quot;在调用真实对象之前的服务&quot;);\n        Object obj = method.invoke(target, args);//相当于调用sayHelloWord方法\n        System.out.println(&quot;在调用真实对象之后的服务&quot;);\n        return obj;\n    }\n}\n</code></pre>\n<p>测试JDK动态代理，代码如下：</p>\n<pre><code class=\"lang-java\">public class TestProxy {\n\n    @Test\n    public void testJdkProxy() {\n        JdkProxyExample jdkProxy = new JdkProxyExample();\n        //绑定关系，因为挂在接口HelloWorld下，所以声明代理对象HelloWorld proxy\n        HelloWorld proxy = (HelloWorld) jdkProxy.bind(new HelloWorldImpl());\n        //注意，此时proxy对象已经是一个代理对象，他会进入代理的逻辑方法invoke里\n        proxy.sayHelloWorld();\n    }\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code>进入代理逻辑方法\n在调度真实对象之前的服务\nHello World\n在调用真实对象之后的服务\n</code></pre><h3 id=\"h3-3-2-cglib-\"><a name=\"3.2    CGLIB动态代理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2    CGLIB动态代理</h3><p>代码如下：</p>\n<pre><code class=\"lang-java\">public class CglibProxyExample implements MethodInterceptor {\n\n    /**\n     * 生成CGLIB代理对象\n     * @param clazz Class类\n     * @return Class类的CGLIB对象\n     */\n    public Object getProxy(Class clazz) {\n        //CGLIB enhancer增强类对象\n        Enhancer enhancer = new Enhancer();\n        //设置增强类型\n        enhancer.setSuperclass(clazz);\n        //定义代理逻辑对象为当前对象，要求当前对象实现MethodInterceptor的方法\n        enhancer.setCallback(this);\n        //生成并返回代理对象\n        return enhancer.create();\n    }\n\n    /**\n     * 代理逻辑方法\n     * @param proxy 代理对象\n     * @param method 执行方法\n     * @param args 方法参数\n     * @param methodProxy 方法代理\n     * @return 代理逻辑返回\n     * @throws Throwable 异常\n     */\n    @Override\n    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(&quot;调用真实对象前&quot;);\n        Object result = methodProxy.invokeSuper(proxy, args);\n        System.out.println(&quot;调用真实对象后&quot;);\n        return result;\n    }\n}\n</code></pre>\n<p>测试CGLIB动态代理，代码如下：</p>\n<pre><code class=\"lang-java\">public class TestProxy {\n\n    @Test\n    public void testCGLIBProxy(){\n        CglibProxyExample cglibProxyExample = new CglibProxyExample();\n        ReflectServiceImpl obj = (ReflectServiceImpl) cglibProxyExample.getProxy(ReflectServiceImpl.class);\n        obj.sayHello(&quot;张三&quot;);\n    }\n}\n</code></pre>\n<p>测试结果如下：</p>\n<pre><code>调用真实对象前\nHello 张三\n调用真实对象后\n</code></pre><h3 id=\"h3-3-3-\"><a name=\"3.3    拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3    拦截器</h3><p>由于动态代理一般比较难理解，程序开发者会设计一个拦截器接口供开发者使用，开发者只需要知道拦截器接口的方法、含义和作用即可，无须知道动态代理是如何实现的。</p>\n<h3 id=\"h3-3-4-\"><a name=\"3.4    实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4    实例</h3><p>用JDK动态代理来实现一个拦截器的逻辑，为此先定义拦截器接口<code>Interceptor</code>，代码如下：</p>\n<pre><code class=\"lang-java\">public interface Interceptor {\n    /**\n     * 在真实对象前调用\n     * @param proxy 代理对象\n     * @param target 真实对象\n     * @param method 调用方法\n     * @param args 方法参数\n     * @return 当返回true时则反射真实对象的方法，当返回false时则调用around方法\n     * 当返回真实对象方法或者around方法执行后，调用after方法\n     */\n    public boolean before(Object proxy, Object target, Method method,Object[] args);\n\n    public void around(Object proxy, Object target, Method method,Object[] args);\n\n    public void after(Object proxy, Object target, Method method,Object[] args);\n}\n</code></pre>\n<p>实现这个接口，代码如下：</p>\n<pre><code class=\"lang-java\">public class MyInterceptor implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;反射方法前逻辑&quot;);\n        return false;//不反射被代理对象原有方法\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;反射方法后逻辑&quot;);\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;取代了被代理对象的方法&quot;);\n    }\n}\n</code></pre>\n<p>在JDK动态代理中使用拦截器，代码如下：</p>\n<pre><code class=\"lang-java\">public class InterceptorJdkProxy implements InvocationHandler {\n    //真实对象\n    private Object target = null;\n    //拦截器全限定名\n    private String interceptorClass = null;\n\n    public InterceptorJdkProxy(Object target, String interceptorClass) {\n        this.target = target;\n        this.interceptorClass = interceptorClass;\n    }\n\n\n    /**\n     * 绑定委托对象并返回一个[代理占位]\n     *\n     * @param target 真实对象\n     * @return 代理对象[占位]\n     */\n    public static Object bind(Object target, String InterceptorClass) {\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InterceptorJdkProxy(target, InterceptorClass));\n    }\n\n    /**\n     * 通过代理对象调用方法，首先进入这个方法\n     *\n     * @param proxy  代理对象\n     * @param method 被调用方法\n     * @param args   方法参数\n     * @return 代理结果返回\n     * @throws Throwable 异常\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (interceptorClass == null) {\n            //没有设置拦截器则直接反射原有方法\n            return method.invoke(target, args);\n        }\n        Object result = null;\n        //通过反射生成拦截器\n        Interceptor interceptor = (Interceptor) Class.forName(interceptorClass).newInstance();\n        //调用前置方法\n        if (interceptor.before(proxy, target, method, args)) {\n            //返回true反射原有对象方法\n            result = method.invoke(target, args);\n        } else {\n            //返回false执行around方法\n            interceptor.around(proxy, target, method, args);\n        }\n        //调用后置方法\n        interceptor.after(proxy, target, method, args);\n        return result;\n    }\n}\n</code></pre>\n<p>代码的执行步骤：</p>\n<ol>\n<li>在bind方法中用JDK动态代理绑定了一个对象，然后返回代理对象。</li><li>如果没有设置拦截器，则直接反射真实对象的方法，然后结束。否则，进行第三步。</li><li>通过反射生成拦截器，并准备使用它。</li><li>调用拦截器的<code>before</code>方法，如果返回true则反射原来的方法；否则运行拦截器的<code>around</code>方法。</li><li>调用拦截器的<code>after</code>方法</li><li>返回结果</li></ol>\n<p>测试拦截器，代码如下：</p>\n<pre><code class=\"lang-java\">public class TestInterceptor {\n\n    @Test\n    public void testInterceptor(){\n       HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(new HelloWorldImpl(),&quot;com.ssm.learn.chapter2.interceptor.MyInterceptor&quot;);\n       proxy.sayHelloWorld();\n    }\n}\n</code></pre>\n<p>测试结果如下：</p>\n<pre><code>反射方法前逻辑\n反射方法后逻辑\n取代了被代理对象的方法\n</code></pre><h2 id=\"h2-4-\"><a name=\"4    责任链模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4    责任链模式</h2><p>举个例子，一个程序员需要请假一周。如果把请假申请单看成是一个对象，那么它需要经过项目经理、部门经理、人事经理等多个角色的审批，每个角色都有机会通过拦截这个申请单进行审批或者修改。这个时候就要考虑提供项目经理、部门经理和人事经理的处理逻辑了，所以需要提供3个拦截器，而传递的则是请假申请单，请假示例如图所示：</p>\n<p><img src=\"http://cdn.alanliang.site/note/请假示例.png\" alt=\"请假示例\"></p>\n<p><strong>当一个对象在一条链上被多个拦截器拦截处理（拦截器也可以不拦截）时，我们把这样的设计模式称为责任链模式，它用于一个对象在多个角色中传递的场景。</strong></p>\n<p>回到刚才的例子，申请单来到项目经理那，经理可能把申请时间“一周”改为“5天”，从而影响到后面的审批，因为后面的审批会依据前面的结果进行。这时候考虑采用层层代理来实现，就是当申请单（<code>target</code>）来到项目经理处时，使用第一个动态代理<code>proxy1</code>，当他来到部门经理处时，部门经理会得到一个在项目经理的代理<code>proxy1</code>基础上生成的第二个动态代理<code>proxy2</code>来处理部门经理的逻辑，以此类推。</p>\n<p>拦截逻辑如下图：</p>\n<p><img src=\"http://cdn.alanliang.site/note/拦截逻辑.png\" alt=\"拦截逻辑\"></p>\n<h3 id=\"h3-4-1-\"><a name=\"4.1    实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1    实例</h3><p>定义三个拦截器，代码如下：</p>\n<pre><code class=\"lang-java\">public class Interceptor1 implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;【拦截器1】的before方法&quot;);\n        return true;\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;【拦截器1】的after方法&quot;);\n    }\n}\n/************************************拦截器2*************************************/\npublic class Interceptor2 implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;【拦截器2】的before方法&quot;);\n        return true;\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;【拦截器2】的after方法&quot;);\n    }\n}\n/************************************拦截器3*************************************/\npublic class Interceptor3 implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;【拦截器3】的before方法&quot;);\n        return true;\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(&quot;【拦截器3】的after方法&quot;);\n    }\n}\n</code></pre>\n<p>测试责任链模式，代码如下：</p>\n<pre><code class=\"lang-java\">@Test\npublic void testInterceptors() {\n    HelloWorld proxy1 = (HelloWorld) InterceptorJdkProxy.bind(new HelloWorldImpl(), &quot;com.ssm.learn.chapter2.interceptor.Interceptor1&quot;);\n    HelloWorld proxy2 = (HelloWorld) InterceptorJdkProxy.bind(proxy1, &quot;com.ssm.learn.chapter2.interceptor.Interceptor2&quot;);\n    HelloWorld proxy3 = (HelloWorld) InterceptorJdkProxy.bind(proxy2, &quot;com.ssm.learn.chapter2.interceptor.Interceptor3&quot;);\n    proxy3.sayHelloWorld();\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code>【拦截器3】的before方法\n【拦截器2】的before方法\n【拦截器1】的before方法\nHello World\n【拦截器1】的after方法\n【拦截器2】的after方法\n【拦截器3】的after方法\n</code></pre><p><strong>由此可见，责任链模式的优点是我们可以在传递链上加入新的拦截器，增加拦截逻辑，其缺点是会增加代理和反射，而代理和反射的性能不高。</strong></p>\n<h2 id=\"h2-5-observer-\"><a name=\"5    观察者（Observer）模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5    观察者（Observer）模式</h2><p><strong>观察者模式又称为发布订阅模式，它定义了一种一对多的依赖关系，让多个观察者同时监视着被观察者的状态，当观察者的状态发生改变时，会通知所有观察者，并让其自动更新自己。</strong></p>\n<p>例子1：微博推送机制。当作者发布一条新微博时，所有关注了该作者的粉丝都会收到推送。</p>\n<p>例子2：一个商家有一些产品，他和一些电商合作，每当有新产品时，就会把这些产品推送到电商，现在只和淘宝、京东合作，于是有这样的伪代码：</p>\n<pre><code>if(产品库有新产品){\n    推送新产品到淘宝;\n    推送新产品到京东；\n}\n</code></pre><p>如果公司又和国美、苏宁、当当、唯品会签订合作协议，那么就需要时改变这段伪代码了：</p>\n<pre><code>if(产品库有新产品){\n    推送新产品到淘宝;\n    推送新产品到京东；\n    推送新产品到国美;\n    推送新产品到苏宁；\n    推送新产品到当当;\n    推送新产品到唯品会；\n}\n</code></pre><p>按照这种做法，如果还有其他电商合作，那么还要继续在if语句中增加逻辑。首先，如果电商越来越多，那么if语句的逻辑就越来越复杂。而且，如果推送商品给淘宝发生异常，需要捕捉异常，避免影响之后的电商接口，导致其不能往下进行，这样代码耦合就会增多。其次，if语句堆砌太多代码不利于维护和扩展。</p>\n<p><strong>而观察者模式更利用扩展，责任也更加清晰。</strong>首先，把每一个电商接口看成一个观察者，每一个观察者都能观察到产品列表（被监听对象）。当公司发布新产品时，就会发送到这个产品列表上，于是产品列表就发生了变化，这时就可以触发各个电商接口（观察者）发送新产品到对应的合作电商那里，观察者模式示例如图所示：</p>\n<p>​    <img src=\"http://cdn.alanliang.site/note/观察者模式示例.jpg\" alt=\"观察者模式示例\"></p>\n<p><strong>类似这样，一个对象（电商接口）会去监听另外一个对象（产品列表），当被监听对象（产品列表）发生变化时，对象（电商接口）就会触发一定的行为，以适合变化的逻辑模式，我们称为观察者模式。</strong></p>\n<p><strong>这样的好处在于，程序不再出现if语句，观察者会根据被观察者对象的变化而做出对应的行为，无论是淘宝、京东或者其他电商团队只要维护自己的逻辑，而无须耦合在一起。同时责任是明确的，产品团队只需要维护产品列表，电商团队可以增加观察者去监听产品的电商接口。</strong></p>\n<h3 id=\"h3-5-1-\"><a name=\"5.1    实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1    实例</h3><p>被观察者——产品列表，继承<code>Observable</code>类，代码如下：</p>\n<pre><code class=\"lang-java\">public class ProductList extends Observable {\n    //产品列表\n    private List&lt;String&gt; productList = null;\n    //类的唯一实例\n    private static ProductList instance;\n\n    //构造方法私有化\n    private ProductList() {\n    }\n\n    /**\n     * 取得唯一实例\n     *\n     * @return 产品列表唯一实例\n     */\n    public static ProductList getInstance() {\n        if (instance == null) {\n            instance = new ProductList();\n            instance.productList = new ArrayList&lt;&gt;();\n        }\n        return instance;\n    }\n\n    /**\n     * 增加观察者（电商接口）\n     * @param observer 观察者\n     */\n    public void addProductListObserver(Observer observer) {\n        this.addObserver(observer);\n    }\n\n    /**\n     * 新增产品\n     * @param newProduct 新产品\n     */\n    public void addProduct(String newProduct){\n        productList.add(newProduct);\n        System.out.println(&quot;产品列表增加了新的产品 &quot;+newProduct);\n        this.setChanged();//设置被观察对象发生变化\n        this.notifyObservers(newProduct);//通知观察者，并传递新产品\n    }\n}\n</code></pre>\n<p>这里的使用了构造方法私有化，避免通过new方式创建对象，而是通过<code>getInstance()</code>方法获得产品列表单例，这里使用了单例模式。</p>\n<p>观察者——以淘宝和京东为例，实现他们的电商接口，作为观察者需要实现<code>Observer</code>接口的<code>update</code>方法，代码如下：</p>\n<pre><code class=\"lang-java\">public class TaoBaoObserver implements Observer {\n    @Override\n    public void update(Observable o, Object product) {\n        String newProduct = (String) product;\n        System.out.println(&quot;发送新产品【&quot; + newProduct + &quot;】同步到淘宝商城&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class JingDongObserver implements Observer {\n    @Override\n    public void update(Observable o, Object product) {\n        String newProduct = (String) product;\n        System.out.println(&quot;发送新产品【&quot; + newProduct + &quot;】同步到京东商城&quot;);\n    }\n}\n</code></pre>\n<p>测试观察者模式，代码如下：</p>\n<pre><code class=\"lang-java\">ublic class TestObserver {\n    @Test\n    public void testObserver() {\n        ProductList observable = ProductList.getInstance();\n        TaoBaoObserver taoBaoObserver = new TaoBaoObserver();\n        JingDongObserver jingDongObserver = new JingDongObserver();\n        observable.addObserver(taoBaoObserver);\n        observable.addObserver(jingDongObserver);\n        observable.addProduct(&quot;新增产品1&quot;);\n    }\n}\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code>产品列表增加了新的产品 新增产品1\n发送新产品【新增产品1】同步到京东商城\n发送新产品【新增产品1】同步到淘宝商城\n</code></pre><h2 id=\"h2-6-\"><a name=\"6    工厂模式和抽象工厂模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6    工厂模式和抽象工厂模式</h2><p>在大部分情况下，我们都是以new方式来创建对象。举个例子，现实中车子的种类可能很多，有大巴车、轿车、救护车、越野车、卡车等，每个种类下面还有具体的型号，一个工厂生产如此多的车会难以管理，所以往往要进一步拆分为各个分工厂：大巴车、轿车等分工厂。但是客户不需要知道工厂如何拆分，他只会告诉客服需要什么样的车，客服就会根据客户的要求找到对应的工厂去生产车。对客户而言，车厂只是抽象概念，他只是大概知道有这样的一个工厂能够满足他的需要。</p>\n<h3 id=\"h3-6-1-simple-factory-\"><a name=\"6.1    普通工厂（Simple Factory）模式：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1    普通工厂（Simple Factory）模式：</h3><p>例如，有个<code>IProduct</code>的产品接口，它下面有5个实现类<code>Product1</code>、<code>Product2</code>、<code>Product3</code>、<code>Product4</code>和<code>Product5</code>。它们属于一个大类，可以通过产品工厂去管理它们的生成，但是由于类型不同，所以初始化有所不同。为了方便使用产品工厂（<code>ProductFactory</code>）类来创建这些产品的对象，用户可以通过产品号来确定需要哪种产品，如图所示：    </p>\n<p><img src=\"http://cdn.alanliang.site/note/产品工厂模式.jpg\" alt=\"产品工厂模式\"></p>\n<p><code>ProductFactory</code>的伪代码如下：</p>\n<pre><code class=\"lang-java\">public class ProductFactory{\n    public static IProduct createProduct(String productNo){\n        switch(productNo){\n            case &quot;1&quot;:return new Product1(XXX);\n            case &quot;2&quot;:return new Product2(XXX);\n            case &quot;3&quot;:return new Product3(XXX);\n            case &quot;4&quot;:return new Product4(XXX);\n            case &quot;5&quot;:return new Product5(XXX);\n            default:\n                throw new NotSupprotedException(&quot;未支持此编号产品生产。&quot;);\n        }\n    }\n}\n</code></pre>\n<p>对于程序调用者而言，他只需要知道通过工厂的<code>createProduct</code>方法，指定产品编号——<code>productNo</code>可以得到对应的产品，而产品满足接口<code>IProduct</code>的规范，所以初始化就简单了许多。对于产品对象的创建，可以把一些特有产品规则写入工厂类中。</p>\n<h3 id=\"h3-6-2-abstract-factory-\"><a name=\"6.2    抽象工厂（Abstract Factory）模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2    抽象工厂（Abstract Factory）模式</h3><p>抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体情况下，创建多个产品族中的产品对象。有时候对象很复杂，有几十种，又分为几个类别，如果使用简单工厂会使得这个工厂的逻辑过于复杂。所以把工厂分为好几个，这样便于工厂产品规则的维护。抽象工厂示意图如图所示：</p>\n<p><img src=\"http://cdn.alanliang.site/note/抽象工厂示意图.jpg\" alt=\"抽象工厂示意图\"></p>\n<p>为了统一，需要制定一个接口规范（<code>IProductFactory</code>），所有的具体工厂和抽象工厂都要实现这一个接口，代码如下：</p>\n<pre><code class=\"lang-java\">public interface IProductFactory {\n    public IProduct createProduct(String productNo);\n}\n</code></pre>\n<p>现在再实现3个工厂类，代码如下：</p>\n<pre><code class=\"lang-java\">public class ProductFactory1 implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        IProduct product = XXX;//工厂1生成产品对象规则，可以是一类产品的规则\n        return product;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class ProductFactory2 implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        IProduct product = XXX;//工厂2生成产品对象规则，可以是一类产品的规则\n        return product;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class ProductFactory3 implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        IProduct product = XXX;//工厂3生成产品对象规则，可以是一类产品的规则\n        return product;\n    }\n}\n</code></pre>\n<p>使用一个公共的工厂，由它提供规则选择工厂，我们做如下业务约定：产品编号以x开头的用工厂<code>ProductFactory</code>x创建对象。代码如下：</p>\n<pre><code class=\"lang-java\">public class ProductFactory implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        char ch = productNo.charAt(0);\n        IProductFactory factory = null;\n        if (ch == &#39;1&#39;) {\n            factory = new ProductFactory1();\n        } else if (ch == &#39;2&#39;) {\n            factory = new ProductFactory2();\n        } else if (ch == &#39;3&#39;) {\n            factory = new ProductFactory3();\n        }\n        if (factory != null) {\n            return factory.createProduct(productNo);\n        }\n        return null;\n    }\n}\n</code></pre>\n<p><strong>对于设计者而言，<code>ProductFactory</code>就是一个抽象工厂，这样创建对象对调用者而言就简单多了。每一个工厂也只要维护其类型产品对象的生成，具体的工厂规则也不会特别复杂，难以维护。</strong></p>\n<h2 id=\"h2-7-builder-\"><a name=\"7    建造者（Builder）模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7    建造者（Builder）模式</h2><p><strong>建造者模式可以将一个产品的内部表象（属性）与产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。</strong></p>\n<p>比如一些旅游套票可以分为：普通成年人、退休老年人、半票有座小孩、免费无座小孩、军人及其家属等，他们有不同的规定和优惠。如果通过new或者工厂模式来创建对象会造成不便，因为参数过多，对象也复杂。</p>\n<p><code>Builder</code>模式是一种分步构建对象的模式。用一个配置类对各步进行统筹，然后将所有信息交由构造器来完成构造对象。</p>\n<h3 id=\"h3-7-1-\"><a name=\"7.1    实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.1    实例</h3><p>创建一个配置类的对象<code>TickerHelper</code>，它能够帮助我们一步步构建对象。代码如下所示：</p>\n<pre><code class=\"lang-java\">public class TicketHelper {\n    public void buildAdult(String info) {\n        System.out.println(&quot;构建成年人票逻辑：&quot; + info);\n    }\n\n    public void buildChildrenForSeat(String info) {\n        System.out.println(&quot;构建有座儿童票逻辑：&quot; + info);\n    }\n\n    public void buildChildrenForNoSeat(String info) {\n        System.out.println(&quot;构建无座儿童票逻辑：&quot; + info);\n    }\n\n    public void buildElderly(String info) {\n        System.out.println(&quot;构建老年人票逻辑：&quot; + info);\n    }\n\n    public void buildSoldier(String info) {\n        System.out.println(&quot;构建军人及其家属票逻辑：&quot; + info);\n    }\n}\n</code></pre>\n<p>然后，需要一个构造类——<code>TicketBuilder</code>，代码如下：</p>\n<pre><code class=\"lang-java\">public class TicketBuilder {\n    public static Object builder(TicketHelper helper){\n        System.out.println(&quot;通过TicketHelper构建套票信息&quot;);\n        return null;\n    }\n}\n</code></pre>\n<p>通过这两个类就可以构建出套票，代码如下：</p>\n<pre><code class=\"lang-java\">public class TestBuilder {\n    @Test\n    public void testBuilder() {\n        TicketHelper helper = new TicketHelper();\n        helper.buildAdult(&quot;成人票&quot;);\n        helper.buildChildrenForSeat(&quot;有座儿童&quot;);\n        helper.buildChildrenForNoSeat(&quot;无座儿童&quot;);\n        helper.buildElderly(&quot;老年人票&quot;);\n        helper.buildSoldier(&quot;军人票&quot;);\n        Object ticket = TicketBuilder.builder(helper);\n    }\n}\n</code></pre>\n<p>本文参考杨开振的《JavaEE互联网轻量级框架整合开发》</p>\n', '##前言\n\n在Java框架中运用了很多的设计模式，常见的包括**代理模式**、**责任链模式**、**观察者模式**、**普通工厂模式**、**抽象工厂模式**和**建造者模式**等，那么下面让我们一起来了解一下。\n\n##1	什么是设计模式\n\n> **设计模式**（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n##2	Java反射技术\n\nJava反射技术应用广泛，能够配置类的**全限定名**、**方法**和**参数**，**完成对象的初始化**等，增强了Java的可配置性，绝大数框架的基本原理也是基于这个技术。\n\n我们简单了解一下反射的应用：\n\n### 2.1	通过反射构建对象\n\n（1）通过**无参构造**方式构建对象，代码如下：\n\n```java\npublic class ReflectServiceImpl {\n    public void sayHello(String name) {\n        System.err.println(\"Hello \" + name);\n    }\n\n    public ReflectServiceImpl getInstance(){\n        ReflectServiceImpl object =null;\n        try {\n            //通过反射生成对象\n            object= (ReflectServiceImpl) Class.forName(\"com.ssm.learn.chapter2.reflect.ReflectServiceImpl\").newInstance();\n            \n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return object;\n    }\n}\n\n```\n\n（2）通过**有参构造**方式构建对象，代码如下：\n\n```java\npublic class ReflectServiceImpl2 {\n\n    private String name;\n\n    public ReflectServiceImpl2(String name) {\n        this.name = name;\n    }\n\n    public void sayHello(String name) {\n        System.err.println(\"Hello \" + name);\n    }\n\n    public ReflectServiceImpl2 getInstance(){\n        ReflectServiceImpl2 object =null;\n        try {\n             //通过反射生成对象\n            object= (ReflectServiceImpl2) Class.forName(\"com.ssm.learn.chapter2.reflect.ReflectServiceImpl2\")\n                    .getConstructor(String.class)\n                    .newInstance(\"张三\");\n            \n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return object;\n    }\n}\n\n```\n\n- 反射的**优点**：只要配置就可以生成对象，可以解除程序的耦合度。\n\n- 反射的**缺点**：运行较慢。\n\nSpring IoC大部分情况下为了灵活度、降低耦合度，而使用反射是值得的。\n\n### 2.2	反射方法\n\n代码如下：\n\n```java\npublic Object reflectMethod() {\n        Object returnObj = null;\n        ReflectServiceImpl target = new ReflectServiceImpl();\n        try {\n            //Method method = ReflectServiceImpl.class.getMethod(\"sayHello\", String.class);\n            \n            //当有具体对象target但不知道它是哪个类的可以这样写\n            Method method = target.getClass().getMethod(\"sayHello\", String.class);\n            //调用方法，相当于target.sayHello(\"张三\")\n            returnObj = method.invoke(target, \"张三\");\n            \n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return returnObj;\n    }\n```\n\n### 2.3	实例\n\n代码如下：\n\n```java\npublic static Object reflect() {\n    ReflectServiceImpl object = null;\n    try {\n        object = (ReflectServiceImpl) Class.forName(\"com.ssm.learn.chapter2.reflect.ReflectServiceImpl\")\n                .newInstance();\n        Method method = object.getClass().getMethod(\"sayHello\", String.class);\n        method.invoke(object,\"张三\");\n    } catch (InstantiationException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    } catch (NoSuchMethodException e) {\n        e.printStackTrace();\n    } catch (InvocationTargetException e) {\n        e.printStackTrace();\n    }\n    return object;\n}\n\npublic static void main(String[] args) {\n    ReflectServiceImpl.reflect();\n}\n```\n\n运行程序，得到以下结果：\n\n```\nHello 张三\n```\n\n##3	动态代理模式\n\n**动态代理的意义在于生成一个占位（又称为代理对象），来代理真实对象，从而控制真实对象的访问。**\n\n举个例子：客户来软件公司谈需求不会直接跟软件工程师谈，而是去找商务谈，客户认为商务代表了公司。如下图所示：\n\n![代理模式示意图](http://cdn.alanliang.site/note/代理模式示意图.png)\n\n**代理的作用：在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象。**\n\n代理分为两个步骤：\n\n1. **代理对象和真实对象之间建立代理关系**\n\n2. **实现代理对象的代理逻辑方法**\n\nJava中最常用的动态代理技术有：\n\n- **JDK动态代理**。JDK自带功能，必须使用接口，比较复杂\n\n- **CGLIB**。第三方提供技术，不必使用接口，比较简单\n\n  ###3.1JDK动态代理\n\n首先定义`HelloWorld`接口，代码如下：\n\n```java\npublic interface HelloWorld{\n    public void sayHelloWorld();\n}\n```\n\n然后提供实现类`HelloWorldImp`l来实现接口，代码如下：\n\n```java\npublic class HelloWorldImpl implements HelloWorld{\n    @Override\n    public void sayHelloWorld(){\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n动态代理绑定和代理逻辑实现，代码如下：\n\n```java\npublic class JdkProxyExample implements InvocationHandler {\n\n    //真实对象\n    private Object target = null;\n\n    /**\n     * 建立代理对象和真实对象的代理关系\n     *\n     * @param target 真实对象\n     * @return 代理对象\n     */\n    public Object bind(Object target) {\n        this.target = target;\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    }\n\n    /**\n     * 代理方法逻辑\n     * @param proxy 代理对象\n     * @param method 当前调度方法\n     * @param args 当前方法参数\n     * @return 代理结果返回\n     * @throws Throwable 异常\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"进入代理逻辑方法\");\n        System.out.println(\"在调用真实对象之前的服务\");\n        Object obj = method.invoke(target, args);//相当于调用sayHelloWord方法\n        System.out.println(\"在调用真实对象之后的服务\");\n        return obj;\n    }\n}\n```\n\n测试JDK动态代理，代码如下：\n\n```java\npublic class TestProxy {\n\n    @Test\n    public void testJdkProxy() {\n        JdkProxyExample jdkProxy = new JdkProxyExample();\n        //绑定关系，因为挂在接口HelloWorld下，所以声明代理对象HelloWorld proxy\n        HelloWorld proxy = (HelloWorld) jdkProxy.bind(new HelloWorldImpl());\n        //注意，此时proxy对象已经是一个代理对象，他会进入代理的逻辑方法invoke里\n        proxy.sayHelloWorld();\n    }\n}\n```\n\n运行结果如下：\n\n```\n进入代理逻辑方法\n在调度真实对象之前的服务\nHello World\n在调用真实对象之后的服务\n```\n\n###3.2	CGLIB动态代理\n\n代码如下：\n\n```java\npublic class CglibProxyExample implements MethodInterceptor {\n\n    /**\n     * 生成CGLIB代理对象\n     * @param clazz Class类\n     * @return Class类的CGLIB对象\n     */\n    public Object getProxy(Class clazz) {\n        //CGLIB enhancer增强类对象\n        Enhancer enhancer = new Enhancer();\n        //设置增强类型\n        enhancer.setSuperclass(clazz);\n        //定义代理逻辑对象为当前对象，要求当前对象实现MethodInterceptor的方法\n        enhancer.setCallback(this);\n        //生成并返回代理对象\n        return enhancer.create();\n    }\n\n    /**\n     * 代理逻辑方法\n     * @param proxy 代理对象\n     * @param method 执行方法\n     * @param args 方法参数\n     * @param methodProxy 方法代理\n     * @return 代理逻辑返回\n     * @throws Throwable 异常\n     */\n    @Override\n    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"调用真实对象前\");\n        Object result = methodProxy.invokeSuper(proxy, args);\n        System.out.println(\"调用真实对象后\");\n        return result;\n    }\n}\n\n```\n\n测试CGLIB动态代理，代码如下：\n\n```java\npublic class TestProxy {\n\n    @Test\n    public void testCGLIBProxy(){\n        CglibProxyExample cglibProxyExample = new CglibProxyExample();\n        ReflectServiceImpl obj = (ReflectServiceImpl) cglibProxyExample.getProxy(ReflectServiceImpl.class);\n        obj.sayHello(\"张三\");\n    }\n}\n```\n\n测试结果如下：\n\n```\n调用真实对象前\nHello 张三\n调用真实对象后\n```\n\n###3.3	拦截器\n\n由于动态代理一般比较难理解，程序开发者会设计一个拦截器接口供开发者使用，开发者只需要知道拦截器接口的方法、含义和作用即可，无须知道动态代理是如何实现的。\n\n###3.4	实例\n\n用JDK动态代理来实现一个拦截器的逻辑，为此先定义拦截器接口`Interceptor`，代码如下：\n\n```java\npublic interface Interceptor {\n    /**\n     * 在真实对象前调用\n     * @param proxy 代理对象\n     * @param target 真实对象\n     * @param method 调用方法\n     * @param args 方法参数\n     * @return 当返回true时则反射真实对象的方法，当返回false时则调用around方法\n     * 当返回真实对象方法或者around方法执行后，调用after方法\n     */\n    public boolean before(Object proxy, Object target, Method method,Object[] args);\n\n    public void around(Object proxy, Object target, Method method,Object[] args);\n\n    public void after(Object proxy, Object target, Method method,Object[] args);\n}\n```\n\n实现这个接口，代码如下：\n\n```java\npublic class MyInterceptor implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"反射方法前逻辑\");\n        return false;//不反射被代理对象原有方法\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"反射方法后逻辑\");\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"取代了被代理对象的方法\");\n    }\n}\n```\n\n在JDK动态代理中使用拦截器，代码如下：\n\n```java\npublic class InterceptorJdkProxy implements InvocationHandler {\n    //真实对象\n    private Object target = null;\n    //拦截器全限定名\n    private String interceptorClass = null;\n\n    public InterceptorJdkProxy(Object target, String interceptorClass) {\n        this.target = target;\n        this.interceptorClass = interceptorClass;\n    }\n\n\n    /**\n     * 绑定委托对象并返回一个[代理占位]\n     *\n     * @param target 真实对象\n     * @return 代理对象[占位]\n     */\n    public static Object bind(Object target, String InterceptorClass) {\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InterceptorJdkProxy(target, InterceptorClass));\n    }\n\n    /**\n     * 通过代理对象调用方法，首先进入这个方法\n     *\n     * @param proxy  代理对象\n     * @param method 被调用方法\n     * @param args   方法参数\n     * @return 代理结果返回\n     * @throws Throwable 异常\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (interceptorClass == null) {\n            //没有设置拦截器则直接反射原有方法\n            return method.invoke(target, args);\n        }\n        Object result = null;\n        //通过反射生成拦截器\n        Interceptor interceptor = (Interceptor) Class.forName(interceptorClass).newInstance();\n        //调用前置方法\n        if (interceptor.before(proxy, target, method, args)) {\n            //返回true反射原有对象方法\n            result = method.invoke(target, args);\n        } else {\n            //返回false执行around方法\n            interceptor.around(proxy, target, method, args);\n        }\n        //调用后置方法\n        interceptor.after(proxy, target, method, args);\n        return result;\n    }\n}\n```\n\n代码的执行步骤：\n\n1. 在bind方法中用JDK动态代理绑定了一个对象，然后返回代理对象。\n2. 如果没有设置拦截器，则直接反射真实对象的方法，然后结束。否则，进行第三步。\n3. 通过反射生成拦截器，并准备使用它。\n4. 调用拦截器的`before`方法，如果返回true则反射原来的方法；否则运行拦截器的`around`方法。\n5. 调用拦截器的`after`方法\n6. 返回结果\n\n测试拦截器，代码如下：\n\n```java\npublic class TestInterceptor {\n\n    @Test\n    public void testInterceptor(){\n       HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(new HelloWorldImpl(),\"com.ssm.learn.chapter2.interceptor.MyInterceptor\");\n       proxy.sayHelloWorld();\n    }\n}\n\n```\n\n测试结果如下：\n\n```\n反射方法前逻辑\n反射方法后逻辑\n取代了被代理对象的方法\n```\n\n##4	责任链模式\n\n举个例子，一个程序员需要请假一周。如果把请假申请单看成是一个对象，那么它需要经过项目经理、部门经理、人事经理等多个角色的审批，每个角色都有机会通过拦截这个申请单进行审批或者修改。这个时候就要考虑提供项目经理、部门经理和人事经理的处理逻辑了，所以需要提供3个拦截器，而传递的则是请假申请单，请假示例如图所示：\n\n![请假示例](http://cdn.alanliang.site/note/请假示例.png)\n\n**当一个对象在一条链上被多个拦截器拦截处理（拦截器也可以不拦截）时，我们把这样的设计模式称为责任链模式，它用于一个对象在多个角色中传递的场景。**\n\n回到刚才的例子，申请单来到项目经理那，经理可能把申请时间“一周”改为“5天”，从而影响到后面的审批，因为后面的审批会依据前面的结果进行。这时候考虑采用层层代理来实现，就是当申请单（`target`）来到项目经理处时，使用第一个动态代理`proxy1`，当他来到部门经理处时，部门经理会得到一个在项目经理的代理`proxy1`基础上生成的第二个动态代理`proxy2`来处理部门经理的逻辑，以此类推。\n\n拦截逻辑如下图：\n\n![拦截逻辑](http://cdn.alanliang.site/note/拦截逻辑.png)\n\n###4.1	实例\n\n定义三个拦截器，代码如下：\n\n```java\npublic class Interceptor1 implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"【拦截器1】的before方法\");\n        return true;\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"【拦截器1】的after方法\");\n    }\n}\n/************************************拦截器2*************************************/\npublic class Interceptor2 implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"【拦截器2】的before方法\");\n        return true;\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"【拦截器2】的after方法\");\n    }\n}\n/************************************拦截器3*************************************/\npublic class Interceptor3 implements Interceptor{\n    @Override\n    public boolean before(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"【拦截器3】的before方法\");\n        return true;\n    }\n\n    @Override\n    public void around(Object proxy, Object target, Method method, Object[] args) {\n\n    }\n\n    @Override\n    public void after(Object proxy, Object target, Method method, Object[] args) {\n        System.out.println(\"【拦截器3】的after方法\");\n    }\n}\n```\n\n测试责任链模式，代码如下：\n\n```java\n@Test\npublic void testInterceptors() {\n    HelloWorld proxy1 = (HelloWorld) InterceptorJdkProxy.bind(new HelloWorldImpl(), \"com.ssm.learn.chapter2.interceptor.Interceptor1\");\n    HelloWorld proxy2 = (HelloWorld) InterceptorJdkProxy.bind(proxy1, \"com.ssm.learn.chapter2.interceptor.Interceptor2\");\n    HelloWorld proxy3 = (HelloWorld) InterceptorJdkProxy.bind(proxy2, \"com.ssm.learn.chapter2.interceptor.Interceptor3\");\n    proxy3.sayHelloWorld();\n}\n```\n\n运行结果如下：\n\n```\n【拦截器3】的before方法\n【拦截器2】的before方法\n【拦截器1】的before方法\nHello World\n【拦截器1】的after方法\n【拦截器2】的after方法\n【拦截器3】的after方法\n```\n\n**由此可见，责任链模式的优点是我们可以在传递链上加入新的拦截器，增加拦截逻辑，其缺点是会增加代理和反射，而代理和反射的性能不高。**\n\n##5	观察者（Observer）模式\n\n**观察者模式又称为发布订阅模式，它定义了一种一对多的依赖关系，让多个观察者同时监视着被观察者的状态，当观察者的状态发生改变时，会通知所有观察者，并让其自动更新自己。**\n\n例子1：微博推送机制。当作者发布一条新微博时，所有关注了该作者的粉丝都会收到推送。\n\n例子2：一个商家有一些产品，他和一些电商合作，每当有新产品时，就会把这些产品推送到电商，现在只和淘宝、京东合作，于是有这样的伪代码：\n\n```\nif(产品库有新产品){\n	推送新产品到淘宝;\n	推送新产品到京东；\n}\n```\n\n如果公司又和国美、苏宁、当当、唯品会签订合作协议，那么就需要时改变这段伪代码了：\n\n```\nif(产品库有新产品){\n	推送新产品到淘宝;\n	推送新产品到京东；\n	推送新产品到国美;\n	推送新产品到苏宁；\n	推送新产品到当当;\n	推送新产品到唯品会；\n}\n```\n\n按照这种做法，如果还有其他电商合作，那么还要继续在if语句中增加逻辑。首先，如果电商越来越多，那么if语句的逻辑就越来越复杂。而且，如果推送商品给淘宝发生异常，需要捕捉异常，避免影响之后的电商接口，导致其不能往下进行，这样代码耦合就会增多。其次，if语句堆砌太多代码不利于维护和扩展。\n\n**而观察者模式更利用扩展，责任也更加清晰。**首先，把每一个电商接口看成一个观察者，每一个观察者都能观察到产品列表（被监听对象）。当公司发布新产品时，就会发送到这个产品列表上，于是产品列表就发生了变化，这时就可以触发各个电商接口（观察者）发送新产品到对应的合作电商那里，观察者模式示例如图所示：\n\n​	![观察者模式示例](http://cdn.alanliang.site/note/观察者模式示例.jpg)\n\n**类似这样，一个对象（电商接口）会去监听另外一个对象（产品列表），当被监听对象（产品列表）发生变化时，对象（电商接口）就会触发一定的行为，以适合变化的逻辑模式，我们称为观察者模式。**\n\n**这样的好处在于，程序不再出现if语句，观察者会根据被观察者对象的变化而做出对应的行为，无论是淘宝、京东或者其他电商团队只要维护自己的逻辑，而无须耦合在一起。同时责任是明确的，产品团队只需要维护产品列表，电商团队可以增加观察者去监听产品的电商接口。**\n\n###5.1	实例\n\n被观察者——产品列表，继承`Observable`类，代码如下：\n\n```java\npublic class ProductList extends Observable {\n    //产品列表\n    private List<String> productList = null;\n    //类的唯一实例\n    private static ProductList instance;\n\n    //构造方法私有化\n    private ProductList() {\n    }\n\n    /**\n     * 取得唯一实例\n     *\n     * @return 产品列表唯一实例\n     */\n    public static ProductList getInstance() {\n        if (instance == null) {\n            instance = new ProductList();\n            instance.productList = new ArrayList<>();\n        }\n        return instance;\n    }\n\n    /**\n     * 增加观察者（电商接口）\n     * @param observer 观察者\n     */\n    public void addProductListObserver(Observer observer) {\n        this.addObserver(observer);\n    }\n\n    /**\n     * 新增产品\n     * @param newProduct 新产品\n     */\n    public void addProduct(String newProduct){\n        productList.add(newProduct);\n        System.out.println(\"产品列表增加了新的产品 \"+newProduct);\n        this.setChanged();//设置被观察对象发生变化\n        this.notifyObservers(newProduct);//通知观察者，并传递新产品\n    }\n}\n```\n\n这里的使用了构造方法私有化，避免通过new方式创建对象，而是通过`getInstance()`方法获得产品列表单例，这里使用了单例模式。\n\n观察者——以淘宝和京东为例，实现他们的电商接口，作为观察者需要实现`Observer`接口的`update`方法，代码如下：\n\n```java\npublic class TaoBaoObserver implements Observer {\n    @Override\n    public void update(Observable o, Object product) {\n        String newProduct = (String) product;\n        System.out.println(\"发送新产品【\" + newProduct + \"】同步到淘宝商城\");\n    }\n}\n```\n\n```java\npublic class JingDongObserver implements Observer {\n    @Override\n    public void update(Observable o, Object product) {\n        String newProduct = (String) product;\n        System.out.println(\"发送新产品【\" + newProduct + \"】同步到京东商城\");\n    }\n}\n```\n\n测试观察者模式，代码如下：\n\n```java\nublic class TestObserver {\n    @Test\n    public void testObserver() {\n        ProductList observable = ProductList.getInstance();\n        TaoBaoObserver taoBaoObserver = new TaoBaoObserver();\n        JingDongObserver jingDongObserver = new JingDongObserver();\n        observable.addObserver(taoBaoObserver);\n        observable.addObserver(jingDongObserver);\n        observable.addProduct(\"新增产品1\");\n    }\n}\n```\n\n运行结果如下：\n\n```\n产品列表增加了新的产品 新增产品1\n发送新产品【新增产品1】同步到京东商城\n发送新产品【新增产品1】同步到淘宝商城\n```\n\n##6	工厂模式和抽象工厂模式\n\n在大部分情况下，我们都是以new方式来创建对象。举个例子，现实中车子的种类可能很多，有大巴车、轿车、救护车、越野车、卡车等，每个种类下面还有具体的型号，一个工厂生产如此多的车会难以管理，所以往往要进一步拆分为各个分工厂：大巴车、轿车等分工厂。但是客户不需要知道工厂如何拆分，他只会告诉客服需要什么样的车，客服就会根据客户的要求找到对应的工厂去生产车。对客户而言，车厂只是抽象概念，他只是大概知道有这样的一个工厂能够满足他的需要。\n\n###6.1	普通工厂（Simple Factory）模式：\n\n例如，有个`IProduct`的产品接口，它下面有5个实现类`Product1`、`Product2`、`Product3`、`Product4`和`Product5`。它们属于一个大类，可以通过产品工厂去管理它们的生成，但是由于类型不同，所以初始化有所不同。为了方便使用产品工厂（`ProductFactory`）类来创建这些产品的对象，用户可以通过产品号来确定需要哪种产品，如图所示：	\n\n![产品工厂模式](http://cdn.alanliang.site/note/产品工厂模式.jpg)\n\n`ProductFactory`的伪代码如下：\n\n```java\npublic class ProductFactory{\n    public static IProduct createProduct(String productNo){\n        switch(productNo){\n            case \"1\":return new Product1(XXX);\n            case \"2\":return new Product2(XXX);\n            case \"3\":return new Product3(XXX);\n            case \"4\":return new Product4(XXX);\n            case \"5\":return new Product5(XXX);\n            default:\n                throw new NotSupprotedException(\"未支持此编号产品生产。\");\n        }\n    }\n}\n```\n\n对于程序调用者而言，他只需要知道通过工厂的`createProduct`方法，指定产品编号——`productNo`可以得到对应的产品，而产品满足接口`IProduct`的规范，所以初始化就简单了许多。对于产品对象的创建，可以把一些特有产品规则写入工厂类中。\n\n###6.2	抽象工厂（Abstract Factory）模式\n\n抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体情况下，创建多个产品族中的产品对象。有时候对象很复杂，有几十种，又分为几个类别，如果使用简单工厂会使得这个工厂的逻辑过于复杂。所以把工厂分为好几个，这样便于工厂产品规则的维护。抽象工厂示意图如图所示：\n\n![抽象工厂示意图](http://cdn.alanliang.site/note/抽象工厂示意图.jpg)\n\n为了统一，需要制定一个接口规范（`IProductFactory`），所有的具体工厂和抽象工厂都要实现这一个接口，代码如下：\n\n```java\npublic interface IProductFactory {\n    public IProduct createProduct(String productNo);\n}\n```\n\n现在再实现3个工厂类，代码如下：\n\n```java\npublic class ProductFactory1 implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        IProduct product = XXX;//工厂1生成产品对象规则，可以是一类产品的规则\n        return product;\n    }\n}\n```\n\n```java\npublic class ProductFactory2 implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        IProduct product = XXX;//工厂2生成产品对象规则，可以是一类产品的规则\n        return product;\n    }\n}\n```\n\n```java\npublic class ProductFactory3 implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        IProduct product = XXX;//工厂3生成产品对象规则，可以是一类产品的规则\n        return product;\n    }\n}\n```\n\n使用一个公共的工厂，由它提供规则选择工厂，我们做如下业务约定：产品编号以x开头的用工厂`ProductFactory`x创建对象。代码如下：\n\n```java\npublic class ProductFactory implements IProductFactory {\n    @Override\n    public IProduct createProduct(String productNo) {\n        char ch = productNo.charAt(0);\n        IProductFactory factory = null;\n        if (ch == \'1\') {\n            factory = new ProductFactory1();\n        } else if (ch == \'2\') {\n            factory = new ProductFactory2();\n        } else if (ch == \'3\') {\n            factory = new ProductFactory3();\n        }\n        if (factory != null) {\n            return factory.createProduct(productNo);\n        }\n        return null;\n    }\n}\n```\n\n**对于设计者而言，`ProductFactory`就是一个抽象工厂，这样创建对象对调用者而言就简单多了。每一个工厂也只要维护其类型产品对象的生成，具体的工厂规则也不会特别复杂，难以维护。**\n\n##7	建造者（Builder）模式\n\n**建造者模式可以将一个产品的内部表象（属性）与产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。**\n\n比如一些旅游套票可以分为：普通成年人、退休老年人、半票有座小孩、免费无座小孩、军人及其家属等，他们有不同的规定和优惠。如果通过new或者工厂模式来创建对象会造成不便，因为参数过多，对象也复杂。\n\n`Builder`模式是一种分步构建对象的模式。用一个配置类对各步进行统筹，然后将所有信息交由构造器来完成构造对象。\n\n###7.1	实例\n\n创建一个配置类的对象`TickerHelper`，它能够帮助我们一步步构建对象。代码如下所示：\n\n```java\npublic class TicketHelper {\n    public void buildAdult(String info) {\n        System.out.println(\"构建成年人票逻辑：\" + info);\n    }\n\n    public void buildChildrenForSeat(String info) {\n        System.out.println(\"构建有座儿童票逻辑：\" + info);\n    }\n\n    public void buildChildrenForNoSeat(String info) {\n        System.out.println(\"构建无座儿童票逻辑：\" + info);\n    }\n\n    public void buildElderly(String info) {\n        System.out.println(\"构建老年人票逻辑：\" + info);\n    }\n\n    public void buildSoldier(String info) {\n        System.out.println(\"构建军人及其家属票逻辑：\" + info);\n    }\n}\n```\n\n然后，需要一个构造类——`TicketBuilder`，代码如下：\n\n```java\npublic class TicketBuilder {\n    public static Object builder(TicketHelper helper){\n        System.out.println(\"通过TicketHelper构建套票信息\");\n        return null;\n    }\n}\n```\n\n通过这两个类就可以构建出套票，代码如下：\n\n```java\npublic class TestBuilder {\n    @Test\n    public void testBuilder() {\n        TicketHelper helper = new TicketHelper();\n        helper.buildAdult(\"成人票\");\n        helper.buildChildrenForSeat(\"有座儿童\");\n        helper.buildChildrenForNoSeat(\"无座儿童\");\n        helper.buildElderly(\"老年人票\");\n        helper.buildSoldier(\"军人票\");\n        Object ticket = TicketBuilder.builder(helper);\n    }\n}\n```\n\n本文参考杨开振的《JavaEE互联网轻量级框架整合开发》', 'http://cdn.alanliang.site/note/oilpainting2.jpg', 1, 0, 0, 0, b'0', b'1', b'1', b'1', b'1', 5, 3, 1, 2, '2020-06-15 10:45:55', '2020-06-15 11:43:25');
INSERT INTO `t_article` VALUES (3, '认识Mybatis核心组件', 'JavaEE互联网轻量级框架整合开发第三章', '<h2 id=\"h2-1-mybatis-\"><a name=\"1    持久层的概念和MyBatis的特点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1    持久层的概念和MyBatis的特点</h2><p>持久层可以将业务数据存储到磁盘，具有长期存储能力。</p>\n<p>Mybatis成功的原因：</p>\n<ul>\n<li>不屏蔽SQL，有对其进行优化的空间，有利于系统性能提高，符合互联网需要性能优化的特点；</li><li>提供灵活、强大的映射机制，方便Java开发者使用。提供动态SQL的功能，满足互联网应用需求经常变化的要求；</li><li>提供了使用Mapper的接口编程，简化了工作，开发者能够更集中于业务逻辑。</li></ul>\n<h2 id=\"h2-2-mybatis-\"><a name=\"2    MyBatis的核心组件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2    MyBatis的核心组件</h2><p>Mybatis的核心组件分为4个部分：</p>\n<ul>\n<li><code>SqlSessionFactoryBuilder</code>（构造器）:它会根据配置或者代码来生成<code>SqlSessionFactory</code>，采用的是分步构建的建造者模式。</li><li><code>SqlSessionFactory</code>（工厂接口）：依靠它来生成<code>SqlSession</code>，使用的是工厂模式。</li><li><code>SqlSession</code>（会话）：既可以发送SQL执行返回结果，也可以获取Mapper的接口。</li><li><code>SQL Mapper</code>（映射器）：Mybatis新设计存在的组件，它由一个Java接口和XML（或注解）构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。</li></ul>\n<p>MyBatis核心组件如图1所示:</p>\n<p><img src=\"http://cdn.alanliang.site/note/Mybatis核心组件.jpg\" alt=\"Mybatis核心组件\"></p>\n<p>&lt;center&gt;图1 MyBatis核心组件&lt;/center&gt;\n\n</p>\n<h2 id=\"h2-3-code-sqlsessionfactory-code-\"><a name=\"3    <code>SqlSessionFactory</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3    <code>SqlSessionFactory</code></h2><p>为了生成<code>SqlSessionFactory</code>，MyBatis提供了构造器<code>SqlSessionFactoryBuilder</code>，它提供了一个类<code>Configuration</code>作为引导类，采用了<code>builder</code>模式，具体的分步则是在<code>Configuration</code>类中完成。</p>\n<p>当配置了XML或者提供了代码后，MyBatis会读取配置文件，通过<code>Configuration</code>类对象构建整个MyBatis的上下文。<code>SqlSessionFactory</code>是一个接口，有两个实现类，一般由<code>DefaultSqlSessionFactory</code>去实现，它们之间的关系如图2所示：</p>\n<p><img src=\"http://cdn.alanliang.site/note/SqlSessionFactory的生成.jpg\" alt=\"SqlSessionFactory的生成\"></p>\n<p>&lt;center&gt;图1 SqlSessionFactory与其实现类&lt;/center&gt;\n\n</p>\n<h4 id=\"h4-3-1-xml-code-sqlsessionfactory-code-\"><a name=\"3.1    使用XML构建<code>SqlSessionFactory</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1    使用XML构建<code>SqlSessionFactory</code></h4><p>在MyBatis中的XML分为两类：</p>\n<ul>\n<li>一类是基础配置文件，通常只有一个，主要是配置一些上下文参数和运行环境</li><li>一类是映射文件，用来配置映射关系、SQL、参数等信息</li></ul>\n<p>创建一份简易的基础配置文件，我们把它命名为<code>mybatis-config.xml</code>，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;!--别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias alias=&quot;role&quot; type=&quot;com.ssm.learn.chapter3.pojo.Role&quot;/&gt;\n    &lt;/typeAliases&gt;\n    &lt;!--数据库环境--&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm_learn/&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/ssm/learn/chapter3/mapper/RoleMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>生成<code>SqlSessionFactory</code>，代码如下：</p>\n<pre><code class=\"lang-java\">public class TestMyBatis {\n    SqlSessionFactory sqlSessionFactory = null;\n\n    String resource = &quot;mybatis-config.xml&quot;;\n\n    InputStream inputStream;\n\n    @Test\n    public void testSqlSessionFactory() {\n        try {\n            //读取mybatis-config.xml\n            inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<h2 id=\"h2-4-code-sqlsession-code-\"><a name=\"4    <code>SqlSession</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4    <code>SqlSession</code></h2><p>在MyBatis中，<code>SqlSession</code>是其核心接口，作用类似于<code>JDBC</code>中的<code>Connnection</code>对象，代表一个连接资源的启用。</p>\n<p>具体而言，它的作用有3个：</p>\n<ul>\n<li>获取Mapper接口。</li><li>发送SQL给数据库。</li><li>控制数据库事务。</li></ul>\n<p>创建方法如下：</p>\n<pre><code class=\"lang-java\">SqlSession sqlSession = SqlSessionFactory.openSession();\n</code></pre>\n<p><code>SqlSession</code>控制数据库事务的方法，代码如下：</p>\n<pre><code class=\"lang-java\">SqlSession sqlSession = null;\ntry {\n    //打开SqlSession会话\n    sqlSession = sqlSessionFactory.openSession();\n    //some code...\n    sqlSession.commit();//提交事务\n} catch (Exception e) {\n    sqlSession.rollback();//回滚事务\n} finally {\n    //在finally语句中确保资源被顺利关闭\n    if (sqlSession != null) {\n        sqlSession.close();\n    }\n}\n</code></pre>\n<h2 id=\"h2-5-\"><a name=\"5    映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5    映射器</h2><p>映射器是MyBatis中最重要、最复杂的组件，它由一个接口和对应的XML文件（或注解）组成。它可以配置以下内容：</p>\n<ul>\n<li>描述映射规则</li><li>提供SQL语句。并可以配置SQL参数类型、返回类型、缓存刷新等信息</li><li>配置缓存</li><li>提供动态SQL</li></ul>\n<p>映射器的主要作用就是将SQL查询到的结果映射成一个POJO，或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。需要注意的是，需要开发的是一个接口，MyBatis采用了动态代理技术，会为这个接口生成一个代理对象，由这个代理对象处理相关逻辑。</p>\n<h3 id=\"h3-5-1-xml-\"><a name=\"5.1    用XML实现映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1    用XML实现映射器</h3><p>定义接口，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter3.mapper.RoleMapper&quot;&gt;&lt;!--namespace对应接口的全限定名--&gt;\n   &lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultType=&quot;role&quot;&gt;\n       select id,role_name as roleName,note from t_role where id = #{id}\n   &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<ul>\n<li>mapper中namespace的值对应于所映射接口的全限定名</li><li>select标签表明这是一条查询语句，其中id的值标识了这条SQL语句，parameterType表明了所需要传递的参数类型，resultType表明了返回的结果类型</li><li>#{id}表示传递进去的参数</li></ul>\n<p>MyBatis在默认情况下采用自动映射，只要SQL返回的列名能和POJO的属性对应起来即可。这里，表里的列role_name通过SQL别名的改写返回roleName，也能和POJO对应起来。</p>\n<h3 id=\"h3-5-2-\"><a name=\"5.2    用注解实现映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2    用注解实现映射器</h3><pre><code class=\"lang-java\">public interface RoleMapper2 {\n    @Select(&quot;select id, role_name as roleName, note from t_role where id = #{id}&quot;)\n    public Role getRole(Long id);\n}\n</code></pre>\n<h3 id=\"h3-5-3-xml-\"><a name=\"5.3    对比XML方式和注解方式实现映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3    对比XML方式和注解方式实现映射器</h3><p>注解方式在比较简单的表和应用中使用起来比较简单方便，但在Java代码中加入SQL语句会使可读性下降，不利于维护；XML代码冗长复杂，但在比较复杂的场景下比较灵活。因此简单场景下用注解方式，复杂场景下用XML方式</p>\n<p>这个接口也可以在XML中定义，例如只需将<code>mybatis-config.xml</code>中配置XML语句：</p>\n<pre><code class=\"lang-xml\">  &lt;mapper resource=&quot;com/ssm/learn/chapter3/mapper/RoleMapper.xml&quot;/&gt;\n</code></pre>\n<p>修改成下面的形式即可：</p>\n<pre><code class=\"lang-xml\">&lt;mapper class=&quot;com.ssm.learn.chapter3.mapper.RoleMapper2&quot;/&gt;\n</code></pre>\n<p>也可以使用<code>configuration</code>对象注册这个接口，比如：</p>\n<pre><code class=\"lang-java\">configuration.addMapper(RoleMapper2.class)；\n</code></pre>\n<h3 id=\"h3-5-4-code-sqlsession-code-sql\"><a name=\"5.4    <code>SqlSession</code>发送SQL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4    <code>SqlSession</code>发送SQL</h3><pre><code class=\"lang-java\">Role role = (Role)sqlSession.selectOne(&quot;com.ssm.learn.chapter3.mapper.RoleMapper.getRole&quot;, 1L);\n</code></pre>\n<p><code>selectOne</code>方法表示使用查询并且只返回一个对象，它接收两个参数，第一个参数是SQL语句的位置，由名称空间和SQL语句的id组成，第二个参数是主键id值。如果MyBatis中只有一个id为<code>getRole</code>的SQL，则可以简写为：</p>\n<pre><code class=\"lang-java\">Role role = (Role)sqlSession.selectOne(&quot;getRole&quot;, 1L);\n</code></pre>\n<h3 id=\"h3-5-5-code-mapper-code-sql\"><a name=\"5.5    用<code>Mapper</code>接口发送SQL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.5    用<code>Mapper</code>接口发送SQL</h3><p><code>SqlSession</code>还可以获取<code>Mapper</code>接口，通过<code>Mapper</code>接口发送SQL，代码如下：</p>\n<pre><code class=\"lang-java\">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\nRole role = roleMapper.getRole(1L);\n</code></pre>\n<p>因为XML文件或者接口注解定义的SQL都可以通过“类的全限定名+方法名”查找，所以MyBatis会找到相应的SQL执行，并返回结果。</p>\n<h3 id=\"h3-5-6-sql-\"><a name=\"5.6    对比两种发送SQL的方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.6    对比两种发送SQL的方式</h3><ul>\n<li><p>使用<code>SqlSession</code>直接发送</p>\n</li><li><p><code>SqlSession</code>获取<code>Mapper</code>接口，再通过<code>Mapper</code>发送</p>\n</li></ul>\n<p>使用<code>Mapper</code>接口编程可以消除<code>SqlSession</code>带来的功能性代码，提高可读性。<code>SqlSession</code>需要<code>SQLid</code>，晦涩难懂，而<code>Mapper</code>更能体现业务逻辑，而且出错时IDE会提示和校验。因此，建议使用<code>Mapper</code>接口编程。</p>\n<h2 id=\"h2-6-\"><a name=\"6    生命周期\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6    生命周期</h2><p>所谓生命周期就是每一个对象应该存活的时间。</p>\n<h3 id=\"h3-6-1-code-sqlsessionfactorybuilder-code-\"><a name=\"6.1    <code>SqlSessionFactoryBuilder</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1    <code>SqlSessionFactoryBuilder</code></h3><p>其作用在于创建<code>SqlSessionFactory</code>，创建成功后就失去作用，所以它只能存在于创建<code>SqlSessionFactory</code>的方法中，而不能让其长期存在。</p>\n<h3 id=\"h3-6-2-code-sqlsessionfactory-code-\"><a name=\"6.2    <code>SqlSessionFactory</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2    <code>SqlSessionFactory</code></h3><p>可以被认为是数据库连接池，其作用是创建<code>SqlSession</code>接口对象。因为MyBatis的本质就是Java对数据库的操作，因此它的生命周期存在整个MyBatis的应用之中。所以一旦创建就要长期保存它，直到不再使用MyBatis应用。创建多个<code>SqlSessionFactory</code>可能会导致数据库连接资源耗尽而出现系统宕机的情况，因此一般作为单例存在。</p>\n<h3 id=\"h3-6-3-code-sqlsession-code-\"><a name=\"6.3    <code>SqlSession</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3    <code>SqlSession</code></h3><p>相当于一个数据库连接（Connection对象），可以在一个事务中执行多条SQL语句，然后通过它提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后应该关闭这条连接，归还至<code>SqlSessionFactory</code>，否则可能会导致数据库资源耗尽。</p>\n<h3 id=\"h3-6-4-code-mapper-code-\"><a name=\"6.4    <code>Mapper</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.4    <code>Mapper</code></h3><p>它由<code>SqlSession</code>创建，所以它的生命周期至多和<code>SqlSession</code>保持一致。Mapper代表的是一个请求中的业务处理，所以它应该在一个请求中，一旦处理完相关业务，就应该销毁它。</p>\n<h2 id=\"h2-7-\"><a name=\"7    实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7    实例</h2><p>项目结构如图：</p>\n<p><img src=\"http://cdn.alanliang.site/note/项目结构.png\" alt=\"项目结构\"></p>\n<p><code>log4j.properties</code>文件，代码如下：</p>\n<pre><code class=\"lang-properties\">log4j.rootLogger=DEBUG, stdout\nlog4j.logger.org.mybatis=DEBUG\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n\n</code></pre>\n<p><code>Role</code>类，代码如下：</p>\n<pre><code class=\"lang-java\">public class Role {\n    private Long id;\n    private String roleName;\n    private String note;\n\n    public Role() {}\n    /*setter and getter*/\n}\n</code></pre>\n<p><code>RoleMapper</code>接口，代码如下：</p>\n<pre><code class=\"lang-java\">public interface RoleMapper {\n    int insertRole(Role role);\n    int deleteRole(Long id);\n    int updateROle(Role role);\n    Role getRole(Long id);\n    List&lt;Role&gt; findRoles(String roleName);\n}\n</code></pre>\n<p><code>RoleMapper.xml</code>文件，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter3.mapper.RoleMapper&quot;&gt;&lt;!--namespace对应接口的全限定名--&gt;\n    &lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot;&gt;\n        insert into t_role(role_name,note)  values (#{roleName},#{note});\n    &lt;/insert&gt;\n    &lt;delete id=&quot;deleteRole&quot; parameterType=&quot;long&quot;&gt;\n        delete from t_role where id = #{id};\n    &lt;/delete&gt;\n    &lt;update id=&quot;updateRole&quot; parameterType=&quot;role&quot;&gt;\n        update t_role set role_name=#{roleName},set note=#{note} where id=#{id};\n    &lt;/update&gt;\n    &lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultType=&quot;role&quot;&gt;\n       select id,role_name as roleName,note from t_role where id = #{id};\n   &lt;/select&gt;\n    &lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultType=&quot;role&quot;&gt;\n        select id,role_name as roleName,note from t_role where role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p><code>SqlSessionFactoryUtils</code>工具类，代码如下：</p>\n<pre><code class=\"lang-java\">public class SqlSessionFactoryUtils {\n    private final static Class&lt;SqlSessionFactoryUtils&gt; LOCK = SqlSessionFactoryUtils.class;\n\n    private static SqlSessionFactory sqlSessionFactory = null;\n\n    private SqlSessionFactoryUtils() {\n\n    }\n\n    public static SqlSessionFactory getSqlSessionFactory() {\n        synchronized (LOCK) {\n            if (sqlSessionFactory != null) {\n                return sqlSessionFactory;\n            } else {\n                String resource = &quot;mybatis-config.xml&quot;;\n                InputStream inputStream;\n                try {\n                    inputStream = Resources.getResourceAsStream(resource);\n                    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n                return sqlSessionFactory;\n            }\n        }\n    }\n\n    public static SqlSession openSqlSession() {\n        if (sqlSessionFactory == null) {\n            getSqlSessionFactory();\n        }\n        return sqlSessionFactory.openSession();\n    }\n}\n</code></pre>\n<p>其中，构造方法私有化使得其它方法不能通过new方式来创建它。而加入<code>synchronized</code>关键字加锁，主要是防止在多线程中多次实例化<code>SqlSessionFactory</code>对象，保证唯一性。</p>\n<p><code>mybatis-config.xml</code>文件，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;!--别名--&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias alias=&quot;role&quot; type=&quot;com.ssm.learn.chapter3.pojo.Role&quot;/&gt;\n    &lt;/typeAliases&gt;\n    &lt;!--数据库环境--&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;!--配置事务管理器--&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;\n            &lt;!--配置数据源--&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!--type=&quot;POOLED&quot;表示采用MyBatis内部连接池--&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm_learn&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/ssm/learn/chapter3/mapper/RoleMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p><code>Chapter3Main</code>类，代码如下：</p>\n<pre><code class=\"lang-java\">public class Chapter3Main {\n    public static void main(String[] args) {\n        Logger logger = Logger.getLogger(Chapter3Main.class);\n        SqlSession sqlSession = null;\n        try {\n            sqlSession = SqlSessionFactoryUtils.openSqlSession();\n            RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);\n            Role role = mapper.getRole(1L);\n            logger.info(role.getRoleName());\n        } finally {\n            if (sqlSession != null) {\n                sqlSession.close();\n            }\n        }\n\n    }\n}\n</code></pre>\n<p>本文参考杨开振的《JavaEE互联网轻量级框架整合开发》</p>\n', '\n\n##1	持久层的概念和MyBatis的特点\n\n持久层可以将业务数据存储到磁盘，具有长期存储能力。\n\nMybatis成功的原因：\n\n- 不屏蔽SQL，有对其进行优化的空间，有利于系统性能提高，符合互联网需要性能优化的特点；\n- 提供灵活、强大的映射机制，方便Java开发者使用。提供动态SQL的功能，满足互联网应用需求经常变化的要求；\n- 提供了使用Mapper的接口编程，简化了工作，开发者能够更集中于业务逻辑。\n\n##2    MyBatis的核心组件\n\nMybatis的核心组件分为4个部分：\n\n- `SqlSessionFactoryBuilder`（构造器）:它会根据配置或者代码来生成`SqlSessionFactory`，采用的是分步构建的建造者模式。\n- `SqlSessionFactory`（工厂接口）：依靠它来生成`SqlSession`，使用的是工厂模式。\n- `SqlSession`（会话）：既可以发送SQL执行返回结果，也可以获取Mapper的接口。\n- `SQL Mapper`（映射器）：Mybatis新设计存在的组件，它由一个Java接口和XML（或注解）构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。\n\nMyBatis核心组件如图1所示:\n\n![Mybatis核心组件](http://cdn.alanliang.site/note/Mybatis核心组件.jpg)\n\n<center>图1 MyBatis核心组件</center>\n\n##3	`SqlSessionFactory`\n\n为了生成`SqlSessionFactory`，MyBatis提供了构造器`SqlSessionFactoryBuilder`，它提供了一个类`Configuration`作为引导类，采用了`builder`模式，具体的分步则是在`Configuration`类中完成。\n\n当配置了XML或者提供了代码后，MyBatis会读取配置文件，通过`Configuration`类对象构建整个MyBatis的上下文。`SqlSessionFactory`是一个接口，有两个实现类，一般由`DefaultSqlSessionFactory`去实现，它们之间的关系如图2所示：\n\n![SqlSessionFactory的生成](http://cdn.alanliang.site/note/SqlSessionFactory的生成.jpg)\n\n<center>图1 SqlSessionFactory与其实现类</center>\n\n####3.1	使用XML构建`SqlSessionFactory`\n\n在MyBatis中的XML分为两类：\n\n- 一类是基础配置文件，通常只有一个，主要是配置一些上下文参数和运行环境\n- 一类是映射文件，用来配置映射关系、SQL、参数等信息\n\n创建一份简易的基础配置文件，我们把它命名为`mybatis-config.xml`，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--别名-->\n    <typeAliases>\n        <typeAlias alias=\"role\" type=\"com.ssm.learn.chapter3.pojo.Role\"/>\n    </typeAliases>\n    <!--数据库环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_learn/\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"1234\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--映射文件-->\n    <mappers>\n        <mapper resource=\"com/ssm/learn/chapter3/mapper/RoleMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n生成`SqlSessionFactory`，代码如下：\n\n```java\npublic class TestMyBatis {\n    SqlSessionFactory sqlSessionFactory = null;\n\n    String resource = \"mybatis-config.xml\";\n\n    InputStream inputStream;\n\n    @Test\n    public void testSqlSessionFactory() {\n        try {\n            //读取mybatis-config.xml\n            inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n##4	`SqlSession`\n\n在MyBatis中，`SqlSession`是其核心接口，作用类似于`JDBC`中的`Connnection`对象，代表一个连接资源的启用。\n\n具体而言，它的作用有3个：\n\n- 获取Mapper接口。\n- 发送SQL给数据库。\n- 控制数据库事务。\n\n创建方法如下：\n\n```java\nSqlSession sqlSession = SqlSessionFactory.openSession();\n```\n\n`SqlSession`控制数据库事务的方法，代码如下：\n\n```java\nSqlSession sqlSession = null;\ntry {\n    //打开SqlSession会话\n    sqlSession = sqlSessionFactory.openSession();\n    //some code...\n    sqlSession.commit();//提交事务\n} catch (Exception e) {\n    sqlSession.rollback();//回滚事务\n} finally {\n    //在finally语句中确保资源被顺利关闭\n    if (sqlSession != null) {\n        sqlSession.close();\n    }\n}\n```\n\n##5	映射器\n\n映射器是MyBatis中最重要、最复杂的组件，它由一个接口和对应的XML文件（或注解）组成。它可以配置以下内容：\n\n- 描述映射规则\n- 提供SQL语句。并可以配置SQL参数类型、返回类型、缓存刷新等信息\n- 配置缓存\n- 提供动态SQL\n\n映射器的主要作用就是将SQL查询到的结果映射成一个POJO，或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。需要注意的是，需要开发的是一个接口，MyBatis采用了动态代理技术，会为这个接口生成一个代理对象，由这个代理对象处理相关逻辑。\n\n###5.1	用XML实现映射器\n\n定义接口，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter3.mapper.RoleMapper\"><!--namespace对应接口的全限定名-->\n   <select id=\"getRole\" parameterType=\"long\" resultType=\"role\">\n       select id,role_name as roleName,note from t_role where id = #{id}\n   </select>\n</mapper>\n```\n\n- mapper中namespace的值对应于所映射接口的全限定名\n- select标签表明这是一条查询语句，其中id的值标识了这条SQL语句，parameterType表明了所需要传递的参数类型，resultType表明了返回的结果类型\n- \\#{id}表示传递进去的参数\n\nMyBatis在默认情况下采用自动映射，只要SQL返回的列名能和POJO的属性对应起来即可。这里，表里的列role_name通过SQL别名的改写返回roleName，也能和POJO对应起来。\n\n###5.2	用注解实现映射器\n\n```java\npublic interface RoleMapper2 {\n    @Select(\"select id, role_name as roleName, note from t_role where id = #{id}\")\n    public Role getRole(Long id);\n}\n```\n\n###5.3	对比XML方式和注解方式实现映射器\n\n注解方式在比较简单的表和应用中使用起来比较简单方便，但在Java代码中加入SQL语句会使可读性下降，不利于维护；XML代码冗长复杂，但在比较复杂的场景下比较灵活。因此简单场景下用注解方式，复杂场景下用XML方式\n\n这个接口也可以在XML中定义，例如只需将`mybatis-config.xml`中配置XML语句：\n\n```xml\n  <mapper resource=\"com/ssm/learn/chapter3/mapper/RoleMapper.xml\"/>\n```\n\n修改成下面的形式即可：\n\n```xml\n<mapper class=\"com.ssm.learn.chapter3.mapper.RoleMapper2\"/>\n```\n\n也可以使用`configuration`对象注册这个接口，比如：\n\n```java\nconfiguration.addMapper(RoleMapper2.class)；\n```\n\n###5.4	`SqlSession`发送SQL\n\n```java\nRole role = (Role)sqlSession.selectOne(\"com.ssm.learn.chapter3.mapper.RoleMapper.getRole\", 1L);\n```\n\n`selectOne`方法表示使用查询并且只返回一个对象，它接收两个参数，第一个参数是SQL语句的位置，由名称空间和SQL语句的id组成，第二个参数是主键id值。如果MyBatis中只有一个id为`getRole`的SQL，则可以简写为：\n\n```java\nRole role = (Role)sqlSession.selectOne(\"getRole\", 1L);\n```\n\n###5.5	用`Mapper`接口发送SQL\n\n`SqlSession`还可以获取`Mapper`接口，通过`Mapper`接口发送SQL，代码如下：\n\n```java\nRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\nRole role = roleMapper.getRole(1L);\n```\n\n因为XML文件或者接口注解定义的SQL都可以通过“类的全限定名+方法名”查找，所以MyBatis会找到相应的SQL执行，并返回结果。\n\n###5.6	对比两种发送SQL的方式\n\n- 使用`SqlSession`直接发送\n\n- `SqlSession`获取`Mapper`接口，再通过`Mapper`发送\n\n使用`Mapper`接口编程可以消除`SqlSession`带来的功能性代码，提高可读性。`SqlSession`需要`SQLid`，晦涩难懂，而`Mapper`更能体现业务逻辑，而且出错时IDE会提示和校验。因此，建议使用`Mapper`接口编程。\n\n##6	生命周期\n\n所谓生命周期就是每一个对象应该存活的时间。\n\n###6.1	`SqlSessionFactoryBuilder`\n\n其作用在于创建`SqlSessionFactory`，创建成功后就失去作用，所以它只能存在于创建`SqlSessionFactory`的方法中，而不能让其长期存在。\n\n###6.2	`SqlSessionFactory`\n\n可以被认为是数据库连接池，其作用是创建`SqlSession`接口对象。因为MyBatis的本质就是Java对数据库的操作，因此它的生命周期存在整个MyBatis的应用之中。所以一旦创建就要长期保存它，直到不再使用MyBatis应用。创建多个`SqlSessionFactory`可能会导致数据库连接资源耗尽而出现系统宕机的情况，因此一般作为单例存在。\n\n###6.3	`SqlSession`\n\n相当于一个数据库连接（Connection对象），可以在一个事务中执行多条SQL语句，然后通过它提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后应该关闭这条连接，归还至`SqlSessionFactory`，否则可能会导致数据库资源耗尽。\n\n###6.4	`Mapper`\n\n它由`SqlSession`创建，所以它的生命周期至多和`SqlSession`保持一致。Mapper代表的是一个请求中的业务处理，所以它应该在一个请求中，一旦处理完相关业务，就应该销毁它。\n\n##7	实例\n\n项目结构如图：\n\n![项目结构](http://cdn.alanliang.site/note/项目结构.png)\n\n`log4j.properties`文件，代码如下：\n\n```properties\nlog4j.rootLogger=DEBUG, stdout\nlog4j.logger.org.mybatis=DEBUG\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n\n```\n\n`Role`类，代码如下：\n\n```java\npublic class Role {\n    private Long id;\n    private String roleName;\n    private String note;\n    \n    public Role() {}\n    /*setter and getter*/\n}\n```\n\n`RoleMapper`接口，代码如下：\n\n```java\npublic interface RoleMapper {\n    int insertRole(Role role);\n    int deleteRole(Long id);\n    int updateROle(Role role);\n    Role getRole(Long id);\n    List<Role> findRoles(String roleName);\n}\n```\n\n`RoleMapper.xml`文件，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter3.mapper.RoleMapper\"><!--namespace对应接口的全限定名-->\n    <insert id=\"insertRole\" parameterType=\"role\">\n        insert into t_role(role_name,note)  values (#{roleName},#{note});\n    </insert>\n    <delete id=\"deleteRole\" parameterType=\"long\">\n        delete from t_role where id = #{id};\n    </delete>\n    <update id=\"updateRole\" parameterType=\"role\">\n        update t_role set role_name=#{roleName},set note=#{note} where id=#{id};\n    </update>\n    <select id=\"getRole\" parameterType=\"long\" resultType=\"role\">\n       select id,role_name as roleName,note from t_role where id = #{id};\n   </select>\n    <select id=\"findRoles\" parameterType=\"string\" resultType=\"role\">\n        select id,role_name as roleName,note from t_role where role_name like concat(\'%\',#{roleName},\'%\')\n    </select>\n</mapper>\n```\n\n`SqlSessionFactoryUtils`工具类，代码如下：\n\n```java\npublic class SqlSessionFactoryUtils {\n    private final static Class<SqlSessionFactoryUtils> LOCK = SqlSessionFactoryUtils.class;\n\n    private static SqlSessionFactory sqlSessionFactory = null;\n\n    private SqlSessionFactoryUtils() {\n\n    }\n\n    public static SqlSessionFactory getSqlSessionFactory() {\n        synchronized (LOCK) {\n            if (sqlSessionFactory != null) {\n                return sqlSessionFactory;\n            } else {\n                String resource = \"mybatis-config.xml\";\n                InputStream inputStream;\n                try {\n                    inputStream = Resources.getResourceAsStream(resource);\n                    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n                return sqlSessionFactory;\n            }\n        }\n    }\n\n    public static SqlSession openSqlSession() {\n        if (sqlSessionFactory == null) {\n            getSqlSessionFactory();\n        }\n        return sqlSessionFactory.openSession();\n    }\n}\n```\n\n其中，构造方法私有化使得其它方法不能通过new方式来创建它。而加入`synchronized`关键字加锁，主要是防止在多线程中多次实例化`SqlSessionFactory`对象，保证唯一性。\n\n`mybatis-config.xml`文件，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--别名-->\n    <typeAliases>\n        <typeAlias alias=\"role\" type=\"com.ssm.learn.chapter3.pojo.Role\"/>\n    </typeAliases>\n    <!--数据库环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <!--配置事务管理器-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源-->\n            <dataSource type=\"POOLED\"><!--type=\"POOLED\"表示采用MyBatis内部连接池-->\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_learn\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"1234\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--映射文件-->\n    <mappers>\n        <mapper resource=\"com/ssm/learn/chapter3/mapper/RoleMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n`Chapter3Main`类，代码如下：\n\n```java\npublic class Chapter3Main {\n    public static void main(String[] args) {\n        Logger logger = Logger.getLogger(Chapter3Main.class);\n        SqlSession sqlSession = null;\n        try {\n            sqlSession = SqlSessionFactoryUtils.openSqlSession();\n            RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);\n            Role role = mapper.getRole(1L);\n            logger.info(role.getRoleName());\n        } finally {\n            if (sqlSession != null) {\n                sqlSession.close();\n            }\n        }\n\n    }\n}\n```\n\n本文参考杨开振的《JavaEE互联网轻量级框架整合开发》', 'http://cdn.alanliang.site/note/oilpainting3.jpg', 1, 0, 0, 0, b'0', b'1', b'0', b'0', b'1', 3, 3, 1, 2, '2020-06-15 11:02:52', '2020-06-15 11:02:52');
INSERT INTO `t_article` VALUES (4, 'MyBatis配置', 'JavaEE互联网轻量级框架整合开发第四章', '<h2 id=\"h2-4-1-\"><a name=\"4.1    概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1    概述</h2><p>Mybatis配置文件的主要元素如表所示：</p>\n<pre><code class=\"lang-xml\">&lt;configuration&gt;&lt;!--配置--&gt;\n    &lt;properties/&gt;&lt;!--属性--&gt;\n    &lt;settings/&gt;&lt;!--设置--&gt;\n    &lt;typeAliases/&gt;&lt;!--类型命名--&gt;\n    &lt;typeHandler&gt;&lt;!--类型处理器--&gt;\n    &lt;objectFactory/&gt;&lt;!--对象工厂--&gt;\n    &lt;plugins/&gt;&lt;!--插件--&gt;\n    &lt;environments&gt;&lt;!--配置环境--&gt;\n        &lt;environment&gt;&lt;!--环境变量--&gt;\n            &lt;transactionManager /&gt;&lt;!--事务处理器--&gt;\n            &lt;dataSource /&gt;&lt;!--数据源--&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;databaseIdProvider /&gt;&lt;!--数据库厂商标识--&gt;\n    &lt;mappers/&gt;&lt;!--映射器--&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>需要注意的是，MyBatis对配置项的顺序有一定要求，如果不符合就会出错。</p>\n<p>接下来我们一起了解MyBatis配置项的作用，其中properties、settings、typeAliases、typeHandlers、environments、mappers的使用。</p>\n<h2 id=\"h2-4-2-properties-\"><a name=\"4.2    properties属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2    properties属性</h2><p>properties属性可以给系统配置一些运行参数，可以放在xml文件或者properties文件中，以方便修改参数，而不建议放在Java编码中。</p>\n<p>一般而言，MyBatis提供了3种方式来使用properties：</p>\n<ul>\n<li>property子元素</li><li>properties文件</li><li>程序代码传递</li></ul>\n<h3 id=\"h3-4-2-1-property-\"><a name=\"4.2.1    property子元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2.1    property子元素</h3><p>以使用property子元素封装数据库连接的相关配置为例，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;!--别名--&gt;\n    &lt;properties&gt;\n        &lt;property name=&quot;database.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;database.url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm_learn&quot;/&gt;\n        &lt;property name=&quot;database.username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;database.password&quot; value=&quot;1234&quot;/&gt;\n    &lt;/properties&gt;\n    &lt;typeAliases&gt;\n        &lt;typeAlias alias=&quot;role&quot; type=&quot;com.ssm.learn.chapter3.pojo.Role&quot;/&gt;\n    &lt;/typeAliases&gt;\n    &lt;!--数据库环境--&gt;\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;!--配置事务管理器--&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;\n            &lt;!--配置数据源--&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!--type=&quot;POOLED&quot;表示采用MyBatis内部连接池--&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;${database.driver}&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;${database.url}&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;${database.username}&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;${database.password}&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;!--映射文件--&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=&quot;com/ssm/learn/chapter3/mapper/RoleMapper.xml&quot;/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>在properties的子元素property定义好的属性参数可以通过${属性名称}的形式获取，这样定义一次就可以到处引用了。</p>\n<h2 id=\"h2-4-2-2-properties-\"><a name=\"4.2.2    使用properties文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2.2    使用properties文件</h2><p>使用properties文件是比较简单普遍的方法。首先，创建一个文件<code>jdbc.properties</code>放到classpath路径下，代码如下：</p>\n<pre><code class=\"lang-properties\">database.driver=com.mysql.jdbc.Driver\ndatabase.url=jdbc:mysql://localhost:3306/ssm_learn\ndatabase.username=root\ndatabase.password=1234\n</code></pre>\n<p>然后，在MyBatis中通过properties标签的属性resource来引入properties文件，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;properties resource=&quot;jdbc.properties&quot; /&gt;\n</code></pre>\n<p>引入后，同样可以通过${属性名称}的形式将properties文件的属性参数引入到MyBatis配置文件中。以后，我们只要维护properties文件就可以维护配置内容了。</p>\n<h3 id=\"h3-4-2-3-\"><a name=\"4.2.3    使用程序传递方式传递参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2.3    使用程序传递方式传递参数</h3><p>在真实的生产环境中，数据库的用户名和密码需要被加密成密文后再配置到properties文件中。连接时再通过工具类，这里使用 CodeUtils.decode()进行解密。那么我们在创建SqlSessionFactory时，就需要把用户名和密码解密后重置到properties属性中，如代码所示：</p>\n<pre><code class=\"lang-java\">public class MyTest {\n    @Test\n    public void test() throws IOException {\n        String resource = &quot;mybatis-config.xml&quot;;\n        InputStream inputStream;\n        InputStream in = Resources.getResourceAsStream(&quot;jdbc.properties&quot;);\n        Properties props = new Properties();\n        props.load(in);\n        String username = props.getProperty(&quot;database.username&quot;);\n        String password = props.getProperty(&quot;database.password&quot;);\n        //解密用户和密码，并在属性中重置\n        props.put(&quot;database.username&quot;, CodeUtils.decode(username));\n        props.put(&quot;database.password&quot;, CodeUtils.decode(password));\n        inputStream = Resources.getResourceAsStream(resource);\n        //使用程序传递的方式覆盖原有的properties属性参数\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, props);\n    }\n}\n</code></pre>\n<h3 id=\"h3-4-2-4-\"><a name=\"4.2.4    总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2.4    总结</h3><p>使用properties的3种方式是有优先级的，程序传递方式 &gt; 使用properties文件方式 &gt; 使用property子元素，MyBatis会根据优先级覆盖原先配置的属性值。建议使用properties文件方式，这种方式简单方便，如果存在需要加密的场景，可以参考以上代码。</p>\n<h2 id=\"h2-4-3-settings-\"><a name=\"4.3    settings设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3    settings设置</h2><p>settings设置是MyBatis中最复杂的配置，但是大部分情况下使用默认值即可，只需要修改一些常用规则即可，比如自动映射、驼峰命名映射、级联规则、是否启用缓存、执行器（Executor）类型等，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用</th>\n<th>配置选项说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>autoMappingBehavior</td>\n<td>指定MyBatis应如何自动映射列到字段或属性。&lt;br /&gt;1、NONE表示取消自动映射&lt;br /&gt;2、PARTIAL表示只会自动映射，没有定义嵌套结果集和映射结果集&lt;br /&gt;3、FULL表示会自动映射任何复杂结果集（无论是否嵌套）</td>\n<td>NONE&lt;br /&gt;PARTIAL&lt;br /&gt;FULL</td>\n<td>PARTIAL</td>\n</tr>\n<tr>\n<td>mapUnderscoreToCamelCase</td>\n<td>是否开启自动驼峰命名规则映射，即从经典数据库列名A_COLUMN到经典Java属性名aColumn的类似映射</td>\n<td>true\\</td>\n<td>false</td>\n<td>false</td>\n</tr>\n<tr>\n<td>lazyLoadingEnabled</td>\n<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</td>\n<td>true\\</td>\n<td>false</td>\n<td>false</td>\n</tr>\n<tr>\n<td>aggressiveLazyLoading</td>\n<td>当启用时，对任意延迟属性的调用都会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载</td>\n<td>true\\</td>\n<td>false</td>\n<td>false</td>\n</tr>\n<tr>\n<td>cacheEnabled</td>\n<td>该配置影响所有映射器中配置缓存的全局开关</td>\n<td>true\\</td>\n<td>false</td>\n<td>true</td>\n</tr>\n<tr>\n<td>defaultExecutorType</td>\n<td>配置默认的执行器。SIMPLE是普通的执行器；REUSE会重用预处理语句（prepared statements）；BATCH执行器将重用语句并执行批量更新</td>\n<td>true\\</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-4-4-typealiases-\"><a name=\"4.4    typeAliases别名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4    typeAliases别名</h2><p>由于类的全限定名称很长，为了简化使用，在MyBatis中允许定义一个别名代表这个类。别名分为系统定义别名和自定义别名。注意，在MyBatis中别名不区分大小写。</p>\n<h3 id=\"h3-4-4-1-\"><a name=\"4.4.1    系统定义别名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4.1    系统定义别名</h3><table>\n<thead>\n<tr>\n<th>别名</th>\n<th>Java类型</th>\n<th>是否支持数组</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_byte</td>\n<td>byte</td>\n<td>y</td>\n</tr>\n<tr>\n<td>_short</td>\n<td>short</td>\n<td>y</td>\n</tr>\n<tr>\n<td>_int</td>\n<td>int</td>\n<td>y</td>\n</tr>\n<tr>\n<td>_integer</td>\n<td>int</td>\n<td>y</td>\n</tr>\n<tr>\n<td>_double</td>\n<td>double</td>\n<td>y</td>\n</tr>\n<tr>\n<td>_float</td>\n<td>float</td>\n<td>y</td>\n</tr>\n<tr>\n<td>_boolean</td>\n<td>boolean</td>\n<td>y</td>\n</tr>\n<tr>\n<td>string</td>\n<td>String</td>\n<td>y</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>Byte</td>\n<td>y</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n<td>y</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n<td>y</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n<td>y</td>\n</tr>\n<tr>\n<td>integer</td>\n<td>Integer</td>\n<td>y</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n<td>y</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n<td>y</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n<td>y</td>\n</tr>\n<tr>\n<td>date</td>\n<td>Date</td>\n<td>y</td>\n</tr>\n<tr>\n<td>decimal</td>\n<td>BigDecimal</td>\n<td>y</td>\n</tr>\n<tr>\n<td>bigdecimal</td>\n<td>BigDecimal</td>\n<td>y</td>\n</tr>\n<tr>\n<td>object</td>\n<td>Object</td>\n<td>y</td>\n</tr>\n<tr>\n<td>map</td>\n<td>Map</td>\n<td>n</td>\n</tr>\n<tr>\n<td>hashmap</td>\n<td>HashMap</td>\n<td>n</td>\n</tr>\n<tr>\n<td>list</td>\n<td>List</td>\n<td>n</td>\n</tr>\n<tr>\n<td>arraylist</td>\n<td>ArrayList</td>\n<td>n</td>\n</tr>\n<tr>\n<td>collection</td>\n<td>Collection</td>\n<td>n</td>\n</tr>\n<tr>\n<td>iterator</td>\n<td>Iterator</td>\n<td>n</td>\n</tr>\n<tr>\n<td>ResultSet</td>\n<td>ResultSet</td>\n<td>n</td>\n</tr>\n</tbody>\n</table>\n<p>如果需要使用对应类型的数据型，要看其是否能支持数据，如果支持只需要使用别名+[]即可，比如_int数据的别名就是_int[]。而类似list这样不支持数据的别名，则不能这样写。</p>\n<p>事实上Configuration对象也对一些常用的配置项配置了别名，如下所示：</p>\n<pre><code class=\"lang-java\">//事务方式别名\ntypeAliasRegistry.registerAlias(&quot;JDBC&quot;,JdbcTransactionFactory.class);\ntypeAliasRegistry.registerAlias(&quot;MANAGED&quot;,\n                                ManagedTransactionFactory.class);\n//数据源类型别名\ntypeAliasRegistry.registerAlias(&quot;JNDI&quot;,JndiDataSourceFactory.class);\ntypeAliasRegistry.registerAlias(&quot;POOLED&quot;,\n                                PooledDataSourceFactory.class);\ntypeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;,\n                                UnpooledDataSourceFactory.class);\n//缓存策略别名\ntypeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;,PerpetualCache.class);\ntypeAliasRegistry.registerAlias(&quot;FIFO&quot;,FifoCache.class);\ntypeAliasRegistry.registerAlias(&quot;LRU&quot;,LruCache.class);\ntypeAliasRegistry.registerAlias(&quot;SOFT&quot;,SoftCache.class);\ntypeAliasRegistry.registerAlias(&quot;WEAK&quot;,WeakCache.class);\n//数据库标识别名\ntypeAliasRegistry.registerAlias(&quot;DB VENDOR&quot;,\n                                VendorDatabaseIdProvider.class);\n//语言驱动类别名\ntypeAliasRegistry.registerAlias(&quot;XML&quot;,XMLLanguageDriver.class);\ntypeAliasRegistry.registerAlias(&quot;RAW&quot;,RawLanguageDriver.class);\n//日志类别名\ntypeAliasRegistry.registerAlias(&quot;SLF4J&quot;,Slf4jImpl.class);\ntypeAliasRegistry.registerAlias(&quot;COMMONS LOGGING&quot;,\n                                JakartaCommonsLoggingImpl.class);\ntypeAliasRegistry.registerAlias(&quot;LOG4J&quot;,Log4jImpl.class);\ntypeAliasRegistry.registerAlias(&quot;LOG4J2&quot;,Log4j2Impl.class);\ntypeAliasRegistry.registerAlias(&quot;JDK LOGGING&quot;,Jdk14LoggingImpl.class\n                                typeAliasRegistry.registerAlias(&quot;STDOUT LOGGING&quot;,StdOutImpl.class);\n                                typeAliasRegistry.registerAlias(&quot;NO_LOGGING&quot;,NoLoggingImpl.class);\n                                //动态代理別名\n                                typeAliasRegistry.registerAlias(&quot;CGLIB&quot;,CglibProxyFactory.class);\n                                typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;,\n                                                                JavassistProxyFactory.class);\n</code></pre>\n<h3 id=\"h3-4-4-2-\"><a name=\"4.4.2    自定义别名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4.2    自定义别名</h3><p>我们可以使用TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义别名。</p>\n<p>使用配置文件定义很简单，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;typeAliases&gt;\n    &lt;typeAlias alias=&quot;role&quot; type=&quot;com.ssm.learn.chapter4.pojo.Role&quot;/&gt;\n    &lt;typeAlias alias=&quot;user&quot; type=&quot;com.ssm.learn.chapter4.pojo.User&quot;/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<p>但是如果很多类需要定义别名，使用以上方式很麻烦。MyBatis还支持扫描别名，比如上面的两个类都在包com.ssm.learn.chapter4.pojo下的话，就可以这样定义，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;typeAliases&gt;\n    &lt;package name=&quot;com.ssm.learn.chapter4.pojo&quot;/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<p>MyBatis将扫描这个包里的所有类，将其第一个字母变成小写作为其别名，比如类Role的别名会变成role。但如果MyBatis扫描了多个包，不同的包中存在相同的类名时将会出现异常。这个时候可以使用注解<a href=\"https://github.com/Alias\" title=\"&#64;Alias\" class=\"at-link\">@Alias</a>进行区分，如下所示：</p>\n<pre><code class=\"lang-java\">package com.learn.ssm.chapter3.pojo;\n@Alias(&quot;user3&quot;)\npublic class User{\n    ......\n}\n</code></pre>\n<h2 id=\"h2-4-5-typehandler-\"><a name=\"4.5    typeHandler类型转换器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5    typeHandler类型转换器</h2><p>在typeHandler中，分为jdbcType和javaType，其中jdbcType用于定义数据库类型，javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和javaType之间的相互转换。如图所示：<img src=\"http://cdn.alanliang.site/note/typeHandler.jpg\" alt=\"typeHandler\"></p>\n<p>因为MyBatis自动探测应该使用什么类型的typeHandler进行处理，所以并不需要我们配置typeHandler、javaType和jdbcType。但是有些场景无法探测，例如使用自定义枚举或者数据库使用特殊数据类型的场景，这时候需要使用自定义的typeHandler去处理类型之间的转换问题。</p>\n<p>和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。</p>\n<h3 id=\"h3-4-5-1-typehandler\"><a name=\"4.5.1    系统定义的typeHandler\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5.1    系统定义的typeHandler</h3><p>MyBatis内部定义了许多有用的typeHandler，在大部分情况下无须显示声明。但有时候需要修改一些转换规则，比如枚举类型。</p>\n<h3 id=\"h3-4-5-2-typehandler\"><a name=\"4.5.2    自定义typeHandler\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5.2    自定义typeHandler</h3><p>要实现typeHandler就需要去实现接口typeHandler，或者继承BaseTypeHandler。这里我们仿造一个StringTypeHandler来实现一个自定义的typeHandler——MyTypeHandler，它只是用于实现接口typeHandler，代码如下：</p>\n<pre><code class=\"lang-java\">//启用扫描注册的时候需要注解\n@MappedTypes(String.class)\n@MappedJdbcTypes(JdbcType.VARCHAR)\npublic class MyTypeHandler implements TypeHandler&lt;String&gt; {\n\n    Logger logger = Logger.getLogger(MyTypeHandler.class);\n\n    @Override    \n    public void setParameter(PreparedStatement ps, int i, String parameter,\n            JdbcType jdbcType) throws SQLException {\n        logger.info(&quot;设置string参数【&quot; + parameter+&quot;】&quot;);\n        ps.setString(i, parameter);\n    }\n\n    @Override    \n    public String getResult(ResultSet rs, String columnName)\n            throws SQLException {\n        String result = rs.getString(columnName);\n        logger.info(&quot;读取string参数1【&quot; + result+&quot;】&quot;);\n        return result;\n    }\n\n    @Override\n    public String getResult(ResultSet rs, int columnIndex) throws SQLException {\n        String result = rs.getString(columnIndex);\n        logger.info(&quot;读取string参数2【&quot; + result+&quot;】&quot;);\n        return result;\n    }\n\n    @Override\n    public String getResult(CallableStatement cs, int columnIndex)\n            throws SQLException {\n        String result = cs.getString(columnIndex);\n        logger.info(&quot;读取string参数3【&quot; + result+&quot;】&quot;);\n        return result;\n    }\n}\n</code></pre>\n<p>定义的typeHandler泛型为String，显然我们要把数据库的数据类型转化为String型，然后实现设置参数和获取结果集的方法。此时还需要启动typeHandler，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;typeHandlers&gt;\n    &lt;typeHandler jdbcType=&quot;VARCHAR&quot; javaType=&quot;string&quot; handler=&quot;com.ssm.learn.chapter4.typeHandler.MyTypeHandler&quot;/&gt;\n&lt;/typeHandlers&gt;\n</code></pre>\n<p>有时候还可以显示启用typeHandler，一般有两种方式，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.learn.ssm.chapter4.mapper.RoleMapper&quot;&gt;\n\n    &lt;resultMap id=&quot;roleMapper&quot; type=&quot;role&quot;&gt;\n        &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt;\n        &lt;!--注意到下面的jdbcType属性和javaType属性--&gt;\n        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot; jdbcType=&quot;VARCHAR&quot;\n            javaType=&quot;string&quot; /&gt;\n\n        &lt;!--注意到下面的typeHandler属性--&gt;\n        &lt;result property=&quot;note&quot; column=&quot;note&quot;\n            typeHandler=&quot;com.learn.ssm.chapter4.typehandler.MyTypeHandler&quot; /&gt;\n    &lt;/resultMap&gt;\n\n    &lt;!--注意到下面的#{roleName, jdbcType=VARCHAR,javaType=string}--&gt;\n    &lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultMap=&quot;roleMapper&quot;&gt;\n        select id, role_name, note from t_role\n        where role_name like concat(&#39;%&#39;, #{roleName, jdbcType=VARCHAR,\n        javaType=string}, &#39;%&#39;)\n    &lt;/select&gt;\n\n    &lt;select id=&quot;findRoles2&quot; parameterType=&quot;string&quot; resultMap=&quot;roleMapper&quot;&gt;\n        select id, role_name, note from t_role\n        where note like concat(&#39;%&#39;, #{note,\n        typeHandler=com.learn.ssm.chapter4.typehandler.MyTypeHandler}, &#39;%&#39;)\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>注意，要么指定了与自定义typeHandler一致的javaType和jdbcType，要么直接使用typeHandler指定具体的实现类。</p>\n', '## 4.1	概述\n\nMybatis配置文件的主要元素如表所示：\n\n```xml\n<configuration><!--配置-->\n    <properties/><!--属性-->\n    <settings/><!--设置-->\n    <typeAliases/><!--类型命名-->\n    <typeHandler><!--类型处理器-->\n    <objectFactory/><!--对象工厂-->\n    <plugins/><!--插件-->\n    <environments><!--配置环境-->\n        <environment><!--环境变量-->\n            <transactionManager /><!--事务处理器-->\n            <dataSource /><!--数据源-->\n        </environment>\n    </environments>\n    <databaseIdProvider /><!--数据库厂商标识-->\n    <mappers/><!--映射器-->\n</configuration>\n```\n\n需要注意的是，MyBatis对配置项的顺序有一定要求，如果不符合就会出错。\n\n接下来我们一起了解MyBatis配置项的作用，其中properties、settings、typeAliases、typeHandlers、environments、mappers的使用。\n\n##4.2	properties属性\n\nproperties属性可以给系统配置一些运行参数，可以放在xml文件或者properties文件中，以方便修改参数，而不建议放在Java编码中。\n\n一般而言，MyBatis提供了3种方式来使用properties：\n\n- property子元素\n- properties文件\n- 程序代码传递\n\n###4.2.1    property子元素\n\n以使用property子元素封装数据库连接的相关配置为例，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--别名-->\n    <properties>\n        <property name=\"database.driver\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"database.url\" value=\"jdbc:mysql://localhost:3306/ssm_learn\"/>\n        <property name=\"database.username\" value=\"root\"/>\n        <property name=\"database.password\" value=\"1234\"/>\n    </properties>\n    <typeAliases>\n        <typeAlias alias=\"role\" type=\"com.ssm.learn.chapter3.pojo.Role\"/>\n    </typeAliases>\n    <!--数据库环境-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <!--配置事务管理器-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--配置数据源-->\n            <dataSource type=\"POOLED\"><!--type=\"POOLED\"表示采用MyBatis内部连接池-->\n                <property name=\"driver\" value=\"${database.driver}\"/>\n                <property name=\"url\" value=\"${database.url}\"/>\n                <property name=\"username\" value=\"${database.username}\"/>\n                <property name=\"password\" value=\"${database.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--映射文件-->\n    <mappers>\n        <mapper resource=\"com/ssm/learn/chapter3/mapper/RoleMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n在properties的子元素property定义好的属性参数可以通过${属性名称}的形式获取，这样定义一次就可以到处引用了。\n\n##4.2.2	使用properties文件\n\n使用properties文件是比较简单普遍的方法。首先，创建一个文件`jdbc.properties`放到classpath路径下，代码如下：\n\n```properties\ndatabase.driver=com.mysql.jdbc.Driver\ndatabase.url=jdbc:mysql://localhost:3306/ssm_learn\ndatabase.username=root\ndatabase.password=1234\n```\n\n然后，在MyBatis中通过properties标签的属性resource来引入properties文件，代码如下：\n\n```xml\n<properties resource=\"jdbc.properties\" />\n```\n\n引入后，同样可以通过${属性名称}的形式将properties文件的属性参数引入到MyBatis配置文件中。以后，我们只要维护properties文件就可以维护配置内容了。\n\n### 4.2.3	使用程序传递方式传递参数\n\n在真实的生产环境中，数据库的用户名和密码需要被加密成密文后再配置到properties文件中。连接时再通过工具类，这里使用 CodeUtils.decode()进行解密。那么我们在创建SqlSessionFactory时，就需要把用户名和密码解密后重置到properties属性中，如代码所示：\n\n```java\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream;\n        InputStream in = Resources.getResourceAsStream(\"jdbc.properties\");\n        Properties props = new Properties();\n        props.load(in);\n        String username = props.getProperty(\"database.username\");\n        String password = props.getProperty(\"database.password\");\n        //解密用户和密码，并在属性中重置\n        props.put(\"database.username\", CodeUtils.decode(username));\n        props.put(\"database.password\", CodeUtils.decode(password));\n        inputStream = Resources.getResourceAsStream(resource);\n        //使用程序传递的方式覆盖原有的properties属性参数\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, props);\n    }\n}\n```\n\n### 4.2.4	总结\n\n使用properties的3种方式是有优先级的，程序传递方式 > 使用properties文件方式 > 使用property子元素，MyBatis会根据优先级覆盖原先配置的属性值。建议使用properties文件方式，这种方式简单方便，如果存在需要加密的场景，可以参考以上代码。\n\n## 4.3	settings设置\n\nsettings设置是MyBatis中最复杂的配置，但是大部分情况下使用默认值即可，只需要修改一些常用规则即可，比如自动映射、驼峰命名映射、级联规则、是否启用缓存、执行器（Executor）类型等，如下表所示：\n\n| 配置项                   | 作用                                                         | 配置选项说明                | 默认值  |\n| ------------------------ | ------------------------------------------------------------ | --------------------------- | ------- |\n| autoMappingBehavior      | 指定MyBatis应如何自动映射列到字段或属性。<br />1、NONE表示取消自动映射<br />2、PARTIAL表示只会自动映射，没有定义嵌套结果集和映射结果集<br />3、FULL表示会自动映射任何复杂结果集（无论是否嵌套） | NONE<br />PARTIAL<br />FULL | PARTIAL |\n| mapUnderscoreToCamelCase | 是否开启自动驼峰命名规则映射，即从经典数据库列名A_COLUMN到经典Java属性名aColumn的类似映射 | true\\|false                 | false   |\n| lazyLoadingEnabled       | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态 | true\\|false                 | false   |\n| aggressiveLazyLoading    | 当启用时，对任意延迟属性的调用都会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载 | true\\|false                 | false   |\n| cacheEnabled             | 该配置影响所有映射器中配置缓存的全局开关                     | true\\|false                 | true    |\n| defaultExecutorType      | 配置默认的执行器。SIMPLE是普通的执行器；REUSE会重用预处理语句（prepared statements）；BATCH执行器将重用语句并执行批量更新 | true\\|false                 | false   |\n\n## 4.4	typeAliases别名\n\n由于类的全限定名称很长，为了简化使用，在MyBatis中允许定义一个别名代表这个类。别名分为系统定义别名和自定义别名。注意，在MyBatis中别名不区分大小写。\n\n### 4.4.1	系统定义别名\n\n| 别名       | Java类型   | 是否支持数组 |\n| ---------- | ---------- | ------------ |\n| _byte      | byte       | y            |\n| _short     | short      | y            |\n| _int       | int        | y            |\n| _integer   | int        | y            |\n| _double    | double     | y            |\n| _float     | float      | y            |\n| _boolean   | boolean    | y            |\n| string     | String     | y            |\n| byte       | Byte       | y            |\n| long       | Long       | y            |\n| short      | Short      | y            |\n| int        | Integer    | y            |\n| integer    | Integer    | y            |\n| double     | Double     | y            |\n| float      | Float      | y            |\n| boolean    | Boolean    | y            |\n| date       | Date       | y            |\n| decimal    | BigDecimal | y            |\n| bigdecimal | BigDecimal | y            |\n| object     | Object     | y            |\n| map        | Map        | n            |\n| hashmap    | HashMap    | n            |\n| list       | List       | n            |\n| arraylist  | ArrayList  | n            |\n| collection | Collection | n            |\n| iterator   | Iterator   | n            |\n| ResultSet  | ResultSet  | n            |\n\n如果需要使用对应类型的数据型，要看其是否能支持数据，如果支持只需要使用别名+[]即可，比如\\_int数据的别名就是\\_int[]。而类似list这样不支持数据的别名，则不能这样写。\n\n事实上Configuration对象也对一些常用的配置项配置了别名，如下所示：\n\n```java\n//事务方式别名\ntypeAliasRegistry.registerAlias(\"JDBC\",JdbcTransactionFactory.class);\ntypeAliasRegistry.registerAlias(\"MANAGED\",\n                                ManagedTransactionFactory.class);\n//数据源类型别名\ntypeAliasRegistry.registerAlias(\"JNDI\",JndiDataSourceFactory.class);\ntypeAliasRegistry.registerAlias(\"POOLED\",\n                                PooledDataSourceFactory.class);\ntypeAliasRegistry.registerAlias(\"UNPOOLED\",\n                                UnpooledDataSourceFactory.class);\n//缓存策略别名\ntypeAliasRegistry.registerAlias(\"PERPETUAL\",PerpetualCache.class);\ntypeAliasRegistry.registerAlias(\"FIFO\",FifoCache.class);\ntypeAliasRegistry.registerAlias(\"LRU\",LruCache.class);\ntypeAliasRegistry.registerAlias(\"SOFT\",SoftCache.class);\ntypeAliasRegistry.registerAlias(\"WEAK\",WeakCache.class);\n//数据库标识别名\ntypeAliasRegistry.registerAlias(\"DB VENDOR\",\n                                VendorDatabaseIdProvider.class);\n//语言驱动类别名\ntypeAliasRegistry.registerAlias(\"XML\",XMLLanguageDriver.class);\ntypeAliasRegistry.registerAlias(\"RAW\",RawLanguageDriver.class);\n//日志类别名\ntypeAliasRegistry.registerAlias(\"SLF4J\",Slf4jImpl.class);\ntypeAliasRegistry.registerAlias(\"COMMONS LOGGING\",\n                                JakartaCommonsLoggingImpl.class);\ntypeAliasRegistry.registerAlias(\"LOG4J\",Log4jImpl.class);\ntypeAliasRegistry.registerAlias(\"LOG4J2\",Log4j2Impl.class);\ntypeAliasRegistry.registerAlias(\"JDK LOGGING\",Jdk14LoggingImpl.class\n                                typeAliasRegistry.registerAlias(\"STDOUT LOGGING\",StdOutImpl.class);\n                                typeAliasRegistry.registerAlias(\"NO_LOGGING\",NoLoggingImpl.class);\n                                //动态代理別名\n                                typeAliasRegistry.registerAlias(\"CGLIB\",CglibProxyFactory.class);\n                                typeAliasRegistry.registerAlias(\"JAVASSIST\",\n                                                                JavassistProxyFactory.class);\n```\n\n### 4.4.2	自定义别名\n\n我们可以使用TypeAliasRegistry类的registerAlias方法注册，也可以采用配置文件或者扫描方式来自定义别名。\n\n使用配置文件定义很简单，如下所示：\n\n```xml\n<typeAliases>\n    <typeAlias alias=\"role\" type=\"com.ssm.learn.chapter4.pojo.Role\"/>\n    <typeAlias alias=\"user\" type=\"com.ssm.learn.chapter4.pojo.User\"/>\n</typeAliases>\n```\n\n但是如果很多类需要定义别名，使用以上方式很麻烦。MyBatis还支持扫描别名，比如上面的两个类都在包com.ssm.learn.chapter4.pojo下的话，就可以这样定义，如下所示：\n\n```xml\n<typeAliases>\n    <package name=\"com.ssm.learn.chapter4.pojo\"/>\n</typeAliases>\n```\n\nMyBatis将扫描这个包里的所有类，将其第一个字母变成小写作为其别名，比如类Role的别名会变成role。但如果MyBatis扫描了多个包，不同的包中存在相同的类名时将会出现异常。这个时候可以使用注解@Alias进行区分，如下所示：\n\n```java\npackage com.learn.ssm.chapter3.pojo;\n@Alias(\"user3\")\npublic class User{\n    ......\n}\n```\n\n## 4.5	typeHandler类型转换器\n\n在typeHandler中，分为jdbcType和javaType，其中jdbcType用于定义数据库类型，javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和javaType之间的相互转换。如图所示：![typeHandler](http://cdn.alanliang.site/note/typeHandler.jpg)\n\n因为MyBatis自动探测应该使用什么类型的typeHandler进行处理，所以并不需要我们配置typeHandler、javaType和jdbcType。但是有些场景无法探测，例如使用自定义枚举或者数据库使用特殊数据类型的场景，这时候需要使用自定义的typeHandler去处理类型之间的转换问题。\n\n和别名一样，在MyBatis中存在系统定义typeHandler和自定义typeHandler。\n\n### 4.5.1	系统定义的typeHandler\n\nMyBatis内部定义了许多有用的typeHandler，在大部分情况下无须显示声明。但有时候需要修改一些转换规则，比如枚举类型。\n\n### 4.5.2	自定义typeHandler\n\n要实现typeHandler就需要去实现接口typeHandler，或者继承BaseTypeHandler。这里我们仿造一个StringTypeHandler来实现一个自定义的typeHandler——MyTypeHandler，它只是用于实现接口typeHandler，代码如下：\n\n```java\n//启用扫描注册的时候需要注解\n@MappedTypes(String.class)\n@MappedJdbcTypes(JdbcType.VARCHAR)\npublic class MyTypeHandler implements TypeHandler<String> {\n\n	Logger logger = Logger.getLogger(MyTypeHandler.class);\n\n	@Override	\n    public void setParameter(PreparedStatement ps, int i, String parameter,\n			JdbcType jdbcType) throws SQLException {\n		logger.info(\"设置string参数【\" + parameter+\"】\");\n		ps.setString(i, parameter);\n	}\n\n	@Override	\n    public String getResult(ResultSet rs, String columnName)\n			throws SQLException {\n		String result = rs.getString(columnName);\n		logger.info(\"读取string参数1【\" + result+\"】\");\n		return result;\n	}\n\n	@Override\n	public String getResult(ResultSet rs, int columnIndex) throws SQLException {\n		String result = rs.getString(columnIndex);\n		logger.info(\"读取string参数2【\" + result+\"】\");\n		return result;\n	}\n\n	@Override\n	public String getResult(CallableStatement cs, int columnIndex)\n			throws SQLException {\n		String result = cs.getString(columnIndex);\n		logger.info(\"读取string参数3【\" + result+\"】\");\n		return result;\n	}\n}\n\n```\n\n定义的typeHandler泛型为String，显然我们要把数据库的数据类型转化为String型，然后实现设置参数和获取结果集的方法。此时还需要启动typeHandler，如下所示：\n\n```xml\n<typeHandlers>\n    <typeHandler jdbcType=\"VARCHAR\" javaType=\"string\" handler=\"com.ssm.learn.chapter4.typeHandler.MyTypeHandler\"/>\n</typeHandlers>\n```\n\n有时候还可以显示启用typeHandler，一般有两种方式，如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.learn.ssm.chapter4.mapper.RoleMapper\">\n\n	<resultMap id=\"roleMapper\" type=\"role\">\n		<result property=\"id\" column=\"id\" />\n        <!--注意到下面的jdbcType属性和javaType属性-->\n		<result property=\"roleName\" column=\"role_name\" jdbcType=\"VARCHAR\"\n			javaType=\"string\" />\n        \n        <!--注意到下面的typeHandler属性-->\n		<result property=\"note\" column=\"note\"\n			typeHandler=\"com.learn.ssm.chapter4.typehandler.MyTypeHandler\" />\n	</resultMap>\n    \n	<!--注意到下面的#{roleName, jdbcType=VARCHAR,javaType=string}-->\n	<select id=\"findRoles\" parameterType=\"string\" resultMap=\"roleMapper\">\n		select id, role_name, note from t_role\n		where role_name like concat(\'%\', #{roleName, jdbcType=VARCHAR,\n		javaType=string}, \'%\')\n	</select>\n\n	<select id=\"findRoles2\" parameterType=\"string\" resultMap=\"roleMapper\">\n		select id, role_name, note from t_role\n		where note like concat(\'%\', #{note,\n		typeHandler=com.learn.ssm.chapter4.typehandler.MyTypeHandler}, \'%\')\n	</select>\n</mapper>\n```\n\n注意，要么指定了与自定义typeHandler一致的javaType和jdbcType，要么直接使用typeHandler指定具体的实现类。\n\n', 'http://cdn.alanliang.site/note/oilpainting4.jpg', 1, 0, 0, 0, b'0', b'1', b'0', b'0', b'1', 3, 3, 1, 2, '2020-06-15 11:05:28', '2020-06-15 11:05:28');
INSERT INTO `t_article` VALUES (5, '映射器', 'JavaEE互联网轻量级框架整合开发第五章', '<h1 id=\"h1--5-\"><a name=\"第5章    映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第5章    映射器</h1><p>映射器是MyBatis最复杂且最重要的组件。它由一个接口和XML文件（或者注解组成）。在映射器中，可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效屏蔽JDBC底层的代码。</p>\n<p>映射器可以使用注解完成，但在企业应用不广，推荐使用XML方式，是因为：</p>\n<ul>\n<li>面对复杂性，SQL会显得无力，尤其是长句SQL；</li><li>注解的可读性较差；</li><li>注解丢失了XML上下文引用的功能</li></ul>\n<h2 id=\"h2-5-1-\"><a name=\"5.1    概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1    概述</h2><p>映射器的常用配置元素如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>元素名称</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>select</td>\n<td>查询语句，最常用、最复杂的元素之一</td>\n<td>可以自定义参数，返回结果集等</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>插入语句</td>\n<td>执行后返回一个参数，代表插入的条数</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新语句</td>\n<td>执行后返回一个参数，代表更新的条数</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除语句</td>\n<td>执行后返回一个参数，代表删除的条数</td>\n</tr>\n<tr>\n<td><del>parameterMap</del></td>\n<td>定义参数映射关系</td>\n<td>即将被删除，不建议使用</td>\n</tr>\n<tr>\n<td>sql</td>\n<td>允许定义一部分SQL，然后在各个地方引用它</td>\n<td>例如，定义一张表的列名，可以在多个SQL语句中使用</td>\n</tr>\n<tr>\n<td>resultMap</td>\n<td>用来描述从数据库结果集中来加载对象，它是最复杂、最强大的元素</td>\n<td>提供映射规则</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>给定名称空间的缓存配置</td>\n<td>—-</td>\n</tr>\n<tr>\n<td>cache-ref</td>\n<td>其他命名空间缓存配置的引用</td>\n<td>—-</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-5-2-\"><a name=\"5.2    引入映射器的方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2    引入映射器的方法</h2><h3 id=\"h3-5-2-1-\"><a name=\"5.2.1    用文件路径引入映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2.1    用文件路径引入映射器</h3><pre><code class=\"lang-xml\">&lt;mappers&gt;\n    &lt;mapper resource=&quot;demo/mapper/demoMapper.xml&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>其中，resource属性值为映射器的xml文件的资源路径</p>\n<h3 id=\"h3-5-2-2-\"><a name=\"5.2.2    用包名引入映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2.2    用包名引入映射器</h3><pre><code class=\"lang-xml\">&lt;mappers&gt;\n    &lt;package name=&quot;demo.mapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>其中，name属性值为映射器的接口所在包的全限定名</p>\n<h3 id=\"h3-5-2-3-\"><a name=\"5.2.3    用类注册引入映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2.3    用类注册引入映射器</h3><pre><code class=\"lang-xml\">&lt;mappers&gt;\n    &lt;mapper class=&quot;demo.mapper.DemoMapper1&quot;/&gt;\n     &lt;mapper class=&quot;demo.mapper.DemoMapper2&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>其中，class属性值为映射器的接口的全限定名</p>\n<h2 id=\"h2-5-3-select-\"><a name=\"5.3    select元素——查询语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3    select元素——查询语句</h2><p>select元素的常用配置如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>元素</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>它和Mapper的命名空间组合起来是唯一的，供MyBatis调用</td>\n<td>如果命名空间和id结合起来不唯一，MyBatis会抛出异常</td>\n</tr>\n<tr>\n<td>parameterType</td>\n<td>可以给出类的全限定名，也可以是别名，但是别名必须是MyBatis内部定义或者自定义的</td>\n<td>可以选择JavaBean、Map等简单的参数类型传递给SQL</td>\n</tr>\n<tr>\n<td><del>parameterMap</del></td>\n<td>即将废弃的元素，不建议使用</td>\n<td>—-</td>\n</tr>\n<tr>\n<td>resultType</td>\n<td>定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规则映射；或定义为in、double、float、map等参数；也可以使用别名，但是要符合别名规范，且不能和resultMap同时使用</td>\n<td>常用的参数之一，比如统计总条数时可以把它的值设置为int</td>\n</tr>\n<tr>\n<td>resultMap</td>\n<td>它是映射集的引用，将执行强大的映射功能。我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会</td>\n<td>MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等</td>\n</tr>\n</tbody>\n</table>\n<p>另外，如果还要设置缓存，还会使用到FlushCache、useCache，这里不展开讲。</p>\n<h3 id=\"h3-5-3-1-select-\"><a name=\"5.3.1    简单的select元素的应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.1    简单的select元素的应用</h3><p>先学习一个最简单的例子：统计用户表同一个姓氏的用户数量，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;countByFirstName&quot; parameterType=&quot;string&quot; resultType=&quot;int&quot;&gt;\n    select count(*) total from t_user where user_name like concat(#{firstName},&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<p>其中的元素含义：</p>\n<ul>\n<li>id：SQL语句的唯一标识</li><li>parameterType：SQL语句接收的参数类型，可以是类的别名也可以是类的全限定名</li><li>resultType：SQL语句返回的结果类型，可以是类的别名也可以是类的全限定名</li></ul>\n<p>接着还需要定义一个接口方法，代码如下所示：</p>\n<pre><code class=\"lang-java\">public interface UserMapper {\n    int countByFirstName(String firstName);\n}\n</code></pre>\n<h3 id=\"h3-5-3-2-\"><a name=\"5.3.2    自动映射和驼峰规则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.2    自动映射和驼峰规则</h3><p>MyBatis提供自动映射功能，在默认情况下是开启的。</p>\n<p>在settings元素中有两个可配置选项autoMappingBehavior和mapUnderscoreToCamelCase，它们是控制自动映射和驼峰映射的开关。一般而言，自动映射使用的多一些，而驼峰映射要求比较苛刻，应用不广。</p>\n<p>autoMappingBehavior的取值有：</p>\n<ul>\n<li>NONE，不进行自动映射</li><li>PARTIAL，默认值，只对没有嵌套结果集进行自动映射</li><li>FULL，对所有的结果集进行自动映射，包括嵌套结果集</li></ul>\n<p>在默认情况下使用默认值即可。规则如下所示：</p>\n<pre><code class=\"lang-java\">public class Role {\n    private Long id;\n    private String roleName;\n    private String note;\n    /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultType=&quot;role&quot;&gt;\n    select id,role_name as roleName,note from t_role where id = #{id};\n&lt;/select&gt;\n</code></pre>\n<p>如果编写的SQL列名和POJO的属性名一致，那么就会形成自动映射。原来的列名role_name被别名roleName替代，所以也会对应起来。</p>\n<h3 id=\"h3-5-3-3-\"><a name=\"5.3.3    传递多个参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.3    传递多个参数</h3><h4 id=\"h4-5-3-3-1-map-\"><a name=\"5.3.3.1    使用map接口传递多个参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.3.1    使用map接口传递多个参数</h4><p>假设要通过角色名称（role_name）和备注（note）两个参数对角色进行模糊查询，则可以使用map接口。</p>\n<p>把接口方法定义为：    </p>\n<pre><code class=\"lang-java\">List&lt;Role&gt; findRolesByMap(Map&lt;String,Object&gt; parameterMap);\n</code></pre>\n<p>使用它在SQL中设置对应的参数，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRolesByMap&quot; parameterType=&quot;map&quot; resultType=&quot;role&quot;&gt;\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n    and note like concat(&#39;%&#39;,#{note},&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<p>测试如下：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test2() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    Map&lt;String, Object&gt; parameterMap = new HashMap&lt;&gt;();\n    parameterMap.put(&quot;roleName&quot;, &quot;1&quot;);\n    parameterMap.put(&quot;note&quot;, &quot;1&quot;);\n    List&lt;Role&gt; roles = roleMapper.findRolesByMap(parameterMap);\n    logger.info(roles);\n    sqlSession.close();\n}\n</code></pre>\n<p>由于使用map不能限定其传递的数据类型，所以业务性质不强，可读性差，因此不推荐使用。</p>\n<h4 id=\"h4-5-3-3-2-\"><a name=\"5.3.3.2    使用注解传递多个参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.3.2    使用注解传递多个参数</h4><p>MyBatis提供了<a href=\"https://github.com/Param\" title=\"&#64;Param\" class=\"at-link\">@Param</a>注解，它可以定义映射器的参数名称，使用它可读性更好。把接口方法定义为：</p>\n<pre><code class=\"lang-java\">List&lt;Role&gt; findRolesByAnnotation(@Param(&quot;roleName&quot;) String roleName,\n                                 @Param(&quot;note&quot;) String note);\n</code></pre>\n<p>修改映射文件，代码如下所示：</p>\n<pre><code class=\"lang-java\">&lt;select id=&quot;findRolesByAnnotation&quot; resultType=&quot;role&quot;&gt;\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n    and note like concat(&#39;%&#39;,#{note},&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<p>注意，此时不用给出parameterType属性，MyBatis会自动探索。<br>测试如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test3() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    List&lt;Role&gt; roles = roleMapper.findRolesByAnnotation(&quot;1&quot;,&quot;1&quot;);\n    logger.info(roles);\n    sqlSession.close();\n}\n</code></pre>\n<p>改写后可读性大大提高，但是如果SQL很复杂，参数很多，那么接口方法的参数个数也会很多，这样使用很不方便。所以，MyBatis还提供了传递JavaBean的形式。</p>\n<h4 id=\"h4-5-3-3-3-javabean-\"><a name=\"5.3.3.3    通过JavaBean传递多个参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.3.3    通过JavaBean传递多个参数</h4><p>首先定义一个参数的POJO——RoleParams，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class RoleParams {\n    private String roleName;\n    private String note;\n\n    public RoleParams(){}\n    /*getter and setter*/\n}\n</code></pre>\n<p>此时把接口方法定义为：</p>\n<pre><code class=\"lang-java\">List&lt;Role&gt; findRolesByBean(RoleParams roleParams);\n</code></pre>\n<p>修改映射文件，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRolesByBean&quot; parameterType=&quot;com.ssm.learn.chapter5.pojo.RoleParams&quot; resultType=&quot;role&quot;&gt;\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n    and note like concat(&#39;%&#39;,#{note},&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<p>注意此时的parameterType属性值修改为RoleParams的全限定名或者别名。</p>\n<p>测试如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test5() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    RoleParams roleParams = new RoleParams();\n    roleParams.setRoleName(&quot;1&quot;);\n    roleParams.setNote(&quot;1&quot;);\n    List&lt;Role&gt; roles = roleMapper.findRolesByBean(roleParams);\n    logger.info(roles);\n    sqlSession.close();\n}\n</code></pre>\n<h4 id=\"h4-5-3-3-4-\"><a name=\"5.3.3.4    混合使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.3.4    混合使用</h4><p>在某种情况下可能需要混合使用几种方式来传递参数。比如通过角色名称和备注查询一个角色，与此同时还支持分页，分页的POJO——PageParams如下所示：</p>\n<pre><code class=\"lang-java\">public class PageParams {\n    private int start;\n    private int limit;\n\n    public PageParams(){}\n    /*getter and setter*/\n}\n</code></pre>\n<p>此时接口方法定义为：</p>\n<pre><code class=\"lang-java\">List&lt;Role&gt; findByMix(@Param(&quot;params&quot;)RoleParams roleParams, \n                     @Param(&quot;page&quot;)PageParams pageParams);\n</code></pre>\n<p>修改映射文件，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findByMix&quot; resultType=&quot;role&quot;&gt;\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(&#39;%&#39;,#{params.roleName},&#39;%&#39;)\n    and note like concat(&#39;%&#39;,#{params.note},&#39;%&#39;)\n    limit #{page.start},#{page.limit}\n&lt;/select&gt;\n</code></pre>\n<p>可以看到MyBatis对RoleParams、PageParams这类的JavaBean提供EL（中间）支持</p>\n<h4 id=\"h4-5-3-3-5-\"><a name=\"5.3.3.5    总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.3.5    总结</h4><p>对4种传递参数的方法进行评价：</p>\n<ul>\n<li>使用map传递参数丧失了业务可读性，实际应用应该果断废弃；</li><li>使用<a href=\"https://github.com/Param\" title=\"&#64;Param\" class=\"at-link\">@Param</a>注解适用于参数较少的情况，一般不超过5个；</li><li>当参数多于5个时，建议使用JavaBean方式；</li><li>对于使用混合参数的，要明确参数合理性</li></ul>\n<h3 id=\"h3-5-3-4-resultmap-\"><a name=\"5.3.4    使用resultMap映射结果集\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.4    使用resultMap映射结果集</h3><p>为了支持复杂的映射，select元素提供了resultMap属性。先定义resultMap属性，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.RoleMapper&quot;&gt;\n    &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;\n        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;\n    &lt;/resultMap&gt;\n    &lt;select id=&quot;getRoleUseResultMap&quot; parameterType=&quot;long&quot; resultMap=&quot;roleMap&quot;&gt;\n         select id,role_name as roleName,note from t_role where id = #{id};\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<ul>\n<li>resultMap的属性id是它的标识，type代表使用哪个类作为其映射的类，可以是别名或者全限定名；</li><li>它的子元素id代表resultMap的主键，而result代表其属性，id和result元素的属性property代表POJO的属性名称，而column代表SQL的列名。把POJO的属性和SQL的列名做对应。</li><li>在select中resultMap属性表明使用哪个resultMap作为映射规则</li></ul>\n<h4 id=\"h4-5-3-5-rowbounds\"><a name=\"5.3.5    分页参数RowBounds\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.5    分页参数RowBounds</h4><p>MyBatis不仅支持分页，而且还提供了专门处理分页的类——RowBounds。使用它很简单，只要给接口增加一个RowBounds参数即可。</p>\n<pre><code class=\"lang-java\"> List&lt;Role&gt; findByRowBounds(@Param(&quot;roleName&quot;) String roleName,\n                            @Param(&quot;note&quot;) String note,\n                            RowBounds rowBounds);\n</code></pre>\n<p>修改映射文件，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findByRowBounds&quot; resultType=&quot;role&quot;&gt;\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n    and note like concat(&#39;%&#39;,#{note},&#39;%&#39;)\n&lt;/select&gt;\n</code></pre>\n<p>代码中没有关于RowBounds的参数信息，它是MyBatis的一个附加参数，MyBatis会自动识别并完成分页。</p>\n<p>测试如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test7() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    RowBounds rowBounds = new RowBounds(0, 20);\n    List&lt;Role&gt; roles = roleMapper.findByRowBounds(&quot;1&quot;, &quot;1&quot;, rowBounds);\n    logger.info(roles);\n    sqlSession.close();\n}\n</code></pre>\n<p>RowBounds接收两个参数，第一个是偏移量offset，第二个参数是限制条数limit，这里表示从1条开始限定返回至多20条记录的结果。RowBounds只适合查询少量数据的场景，查询大量数据可以使用分页插件。</p>\n<h2 id=\"h2-5-4-insert-\"><a name=\"5.4    insert元素——插入语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4    insert元素——插入语句</h2><p>insert元素的常用配置如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>SQL编号，用于表示这条SQL语句</td>\n<td>命名空间+id+databaseId唯一，否则MyBatis会抛出异常</td>\n</tr>\n<tr>\n<td>parameterType</td>\n<td>参数类型，同select元素</td>\n<td>和select元素一样，可以是单个参数或者多个参数</td>\n</tr>\n<tr>\n<td>useGeneratedKeys</td>\n<td>是否启用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。（比如MySQL和SQL Server这样的数据库表的自增主键）</td>\n<td>默认值为false</td>\n</tr>\n<tr>\n<td>keyProperty</td>\n<td>（仅对insert和update有用）唯一标记一个属性，MyBatis会通过getGeneratedKeys的返回值，或者通过insert语句的selectKey子元素设置它的键值。如果是复合主键，要把每一个名称用逗号隔开</td>\n<td>默认值为unset。不能和KeyColumn连用</td>\n</tr>\n<tr>\n<td>keyColumn</td>\n<td>（仅对insert和update有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像PostgreSQL）中是必须的，当主键列不是表中的第一列时需要设置。如果是复合主键，要把每一个名称用逗号隔开</td>\n<td>不能和KeyProperty连用</td>\n</tr>\n</tbody>\n</table>\n<p>执行一条insert语句后，会返回一个整数表示其影响记录数。</p>\n<h3 id=\"h3-5-4-2-insert-\"><a name=\"5.4.2    简单的insert语句的应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4.2    简单的insert语句的应用</h3><p>写一条SQL插入角色，这是一条最简单的插入语句，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot;&gt;\n    insert into t_role(role_name,note)  values (#{roleName},#{note});\n&lt;/insert&gt;\n</code></pre>\n<ul>\n<li>id表示这条SQL；</li><li>parameterType代表传入参数类型；</li><li>没有配置的属性采用默认值</li></ul>\n<h3 id=\"h3-5-4-3-\"><a name=\"5.4.3    主键回填\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4.3    主键回填</h3><p>上面的代码并没有插入id列，因为MySQL中的表采用了自增主键，但有时候还需要这个主键来关联其它业务。</p>\n<p>insert标签中有这样一个属性useGeneratedKeys来获取主键，打开这个开关后，还要配置其属性keyProperty或keyColumn，告诉系统把生成的主键放入哪个属性，如果存在多个主键，就用逗号隔开。</p>\n<p>修改映射文件，让程序返回主键，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;\n    insert into t_role(role_name,note)  values (#{roleName},#{note});\n&lt;/insert&gt;\n</code></pre>\n<p>这样就会把数据库生成的主键回填至keyProperty指定的POJO属性，这里是id。</p>\n<p>测试主键回填的结果，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test8() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    Role role = new Role();\n    role.setRoleName(&quot;二郎神&quot;);\n    role.setNote(&quot;杨戬&quot;);\n    logger.info(role);\n    roleMapper.insertRole(role);\n    logger.info(role);\n    sqlSession.close();\n}\n</code></pre>\n<p>运行可看到，在执行insertRole方法前roleid值为null，而执行后值不为null。</p>\n<h3 id=\"h3-5-4-4-\"><a name=\"5.4.4    自定义主键\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4.4    自定义主键</h3><p>有时候主键可能依赖于某些规则，比如取消角色表的id递增规则，修改为：</p>\n<ul>\n<li>当角色表记录为空时，id设置为1</li><li>当角色表记录不为空时，id设置为当前id加3</li></ul>\n<p>MyBatis可用selectKey元素实现自定义键值的生成规则。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;&lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;\n    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;long&quot; order=&quot;BEFORE&quot;&gt;\n        select if (max(id) = null,1,max(id)+3) from t_role\n    &lt;/selectKey&gt;\n    insert into t_role(id,role_name,note)  values (#{id},#{roleName},#{note});\n&lt;/insert&gt;\n</code></pre>\n<p>以上代码定义了selectKey元素，它的keyProperty指定了id属性作为POJO的主键，resultType指定了返回long型的结果集，而order属性为BEFORE表示它将于当前定义的SQL前执行。</p>\n<h2 id=\"h2-5-5-update-delete-\"><a name=\"5.5    update元素和delete元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.5    update元素和delete元素</h2><p>update元素和delete元素比较简单，和insert元素差不多，执行后也会返回一个整数，用来标识该SQL语句影响了数据库的记录行数。更新和删除角色表记录，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;update id=&quot;updateRole&quot; parameterType=&quot;role&quot;&gt;\n    update t_role set role_name=#{roleName},set note=#{note} where id=#{id};\n&lt;/update&gt;\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;delete id=&quot;deleteRole&quot; parameterType=&quot;long&quot;&gt;\n    delete from t_role where id = #{id};\n&lt;/delete&gt;\n</code></pre>\n<h2 id=\"h2-5-6-sql-\"><a name=\"5.6    sql元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.6    sql元素</h2><p>sql元素的作用在于可以定义一条SQL的一部分，方便后面的SQL引用它，比如最典型的列名，通常情况下要在select、insert语句中反复编写，特别字段多的表。这时候可以使用sql元素，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.RoleMapper&quot;&gt;&lt;!--namespace对应接口的全限定名--&gt;\n    &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;\n        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;\n    &lt;/resultMap&gt;\n\n    &lt;sql id=&quot;roleCols&quot;&gt;\n        id,role_name,note\n    &lt;/sql&gt;\n\n    &lt;select id=&quot;getRole&quot; resultType=&quot;role&quot;&gt;\n        select &lt;include refid=&quot;roleCols&quot;/&gt; from t_role where id = #{id};\n    &lt;/select&gt;\n\n    &lt;insert id=&quot;insertRole&quot; parameterType=&quot;role&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;\n        &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;long&quot; order=&quot;BEFORE&quot;&gt;\n            select if (max(id) = null,1,max(id)+3) from t_role\n        &lt;/selectKey&gt;\n        insert into t_role(&lt;include refid=&quot;roleCols&quot;/&gt;)  values (#{id},#{roleName},#{note});\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>可以看到，通过sql元素定义，就可以include元素引入到各条SQL语句中，减少了列名的重复编写。</p>\n<p>sql元素还支持变量传递，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;sql id=&quot;roleCols&quot;&gt;\n    ${alias}.id,${alias}.role_name ,${alias}.note\n&lt;/sql&gt;\n&lt;select id=&quot;getRole&quot; resultType=&quot;role&quot;&gt;\n    select \n    &lt;include refid=&quot;roleCols&quot;&gt;\n        &lt;property name=&quot;alias&quot; value=&quot;r&quot;/&gt;\n    &lt;/include&gt;\n    from t_role where id = #{id};\n&lt;/select&gt;\n</code></pre>\n<p>在include元素中定义了一个命名为alias的变量，其值是SQL表t_role的别名r，然后sql元素就可以使用这个变量名了。</p>\n<h2 id=\"h2-5-7-resultmap-\"><a name=\"5.7    resultMap元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.7    resultMap元素</h2><p>resultMap的作用主要是定义映射规则，也就是SQL到JavaBean的映射关系。</p>\n<h3 id=\"h3-5-7-1-pojo-\"><a name=\"5.7.1    使用POJO存储结果集\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.7.1    使用POJO存储结果集</h3><pre><code class=\"lang-xml\">&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.RoleMapper&quot;&gt;\n    &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;/&gt;\n        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;\n    &lt;/resultMap&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>resultMap元素的属性id代表这个resultMap的标识，type代表需要映射的POJO，这里可以使用别名或者全限定名。在映射关系中，id表示对象的主键，property表示POJO的属性名称，column表示数据库列名。于是POJO就和数据库SQL的结果一一对应起来了。配置完成即可使用resultMap，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;getRoleUseResultMap&quot; parameterType=&quot;long&quot; resultMap=&quot;roleMap&quot;&gt;\n     select id,role_name as roleName,note from t_role where id = #{id};\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"h2-5-8-\"><a name=\"5.8    级联\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8    级联</h2><p>级联是一个数据库实体的概念。比如角色就需要存在用户与之对应，这样就有角色用户表，一个角色可能有多个用户，这就是一对多的级联；除此之外，还有一对一的级联，比如身份证和公民是一对一的关系。在MyBatis中还有一种被称为鉴别器的级联，它是一种可以选择具体实现类的级联，比如要查找雇员及其体检表的信息，但是雇员有性别之分，而根据性别的不同，其体检表的项目也会不一样，比如男性体检表可能有前列腺的项目，而女子体检表可能有子宫的项目，那么体检表应该分为男性和女性，从而根据雇员性别区关联。</p>\n<p>级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统的复杂度，同时降低系统性能，一般最好不超过3层。</p>\n<h3 id=\"h3-5-8-1-mybatis-\"><a name=\"5.8.1    MyBatis中的级联\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8.1    MyBatis中的级联</h3><p>MyBatis中的级联分为3种。</p>\n<ul>\n<li>鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分。</li><li>一对一（association）：比如学生证和学生就是一种一对一的级联。</li><li>一对多（collection）：比如班级和学生就是一种一对多的级联。</li></ul>\n<p>值得注意的是，MyBatis没有多对多级联，因为多对多级联比较复杂，使用困难，而且可以通过两个一对多进行替换，所有MyBatis不支持。</p>\n<p>为了更好地阐述级联，先给出一个雇员级联模型。</p>\n<ul>\n<li>该模型以雇员表为中心</li><li>雇员表和工牌表是一对一级联关系</li><li>雇员表和员工任务表是一对多级联关系</li><li>员工任务表和任务表是一对一级联关系</li><li>每个雇员都会有一个体检表，随着雇员字段性别取值不同，会有不同的关联表</li></ul>\n<p>mysql脚本略</p>\n<h3 id=\"h3-5-8-2-pojo\"><a name=\"5.8.2    建立POJO\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8.2    建立POJO</h3><p>男性体检表和女性体检表继承于体检表，因此可以得出3个体检表，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class HealthForm {\n\n   private Long id;\n   private Long empId;\n   private String heart;\n   private String liver;\n   private String spleen;\n   private String lung;\n   private String kidney;\n   private String note;\n\n    /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class MaleHealthForm extends HealthForm {\n\n   private String prostate;\n\n    /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class FemaleHealthForm extends HealthForm {\n\n   private String uterus;\n\n    /*getter and setter*/\n}\n</code></pre>\n<p>显然这个关联关系是通过MyBatis的鉴别器去完成。</p>\n<p>接下来设计员工表、工牌表和任务表的POJO，它们是以员工表为核心的，先完成工牌表和任务表的POJO，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class WorkCard {\n   private Long id;\n   private Long empId;\n   private String realName;\n   private String department;\n   private String mobile;\n   private String position;\n   private String note;\n\n   /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Task {\n   private Long id;\n   private String title;\n   private String context;\n   private String note;\n\n   /*getter and setter*/\n}\n</code></pre>\n<p>雇员任务表是通过任务编号(task_id)和任务进行一对一管理，这里只考虑其自身和任务编号的关联，而雇员对它的关联则由雇员去维护，这样就可得到雇员任务POJO，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class EmployeeTask {\n   private Long id;\n   private Long empId;\n    //任务按一对一级联\n   private Task task = null;\n   private String taskName;\n   private String note;\n\n   /*getter and setter*/\n}\n</code></pre>\n<p>属性task是一个Task类对象，由它进行关联任务信息。</p>\n<p>男雇员和女雇员继承于雇员，这就是一个鉴别器，通过雇员类的属性性别来决定使用哪个具体的子类初始化对象。它与工牌表是一对一关联关系，对于雇员任务表是一对多关联关系，由此可以得出3个类，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class Employee {\n\n   private Long id;\n   private String realName;\n   private SexEnum sex = null;\n   private Date birthday;\n   private String mobile;\n   private String email;\n   private String position;\n   private String note;\n    //工牌按一对一级联\n   private WorkCard workCard;\n   //雇员任务按一对多级联\n   private List&lt;EmployeeTask&gt; employeeTaskList = null;\n\n    /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class MaleEmployee extends Employee {\n\n   private MaleHealthForm maleHealthForm = null;\n\n   /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class FemaleEmployee extends Employee {\n\n   private FemaleHealthForm femaleHealthForm = null;\n\n   /*getter and setter*/\n}\n</code></pre>\n<h3 id=\"h3-5-8-3-\"><a name=\"5.8.3    配置映射文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8.3    配置映射文件</h3><p>配置TaskMapper.xml和WorkCardMapper.xml，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.TaskMapper&quot;&gt;\n    &lt;select id=&quot;getTask&quot; parameterType=&quot;long&quot; resultType=&quot;com.ssm.learn.chapter5.pojo.Task&quot;&gt;\n        select id,title,context,note from t_task where id =#{id}\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.WorkCardMapper&quot;&gt;\n    &lt;select id=&quot;getWorkCardByEmpId&quot; parameterType=&quot;long&quot; resultType=&quot;com.ssm.learn.chapter5.pojo.WorkCard&quot;&gt;\n        select id, emp_id as empId, real_name as realName, department, mobile, position, note FROM t_work_card\n        where emp_id = #{empId}\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>雇员任务表通过任务编号（task_id）和任务表示关联，这是一个一对一的级联关系，使用association元素，雇员任务表一对一级联如代码所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.EmployeeTaskMapper&quot;&gt;\n    &lt;resultMap id=&quot;EmployeeTaskMap&quot; type=&quot;com.ssm.learn.chapter5.pojo.EmployeeTask&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;\n        &lt;result property=&quot;taskName&quot; column=&quot;task_name&quot;/&gt;\n        &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;\n\n        &lt;association property=&quot;task&quot; column=&quot;task_id&quot; select=&quot;com.ssm.learn.chapter5.mapper.TaskMapper.getTask&quot;/&gt;\n\n    &lt;/resultMap&gt;\n\n    &lt;select id=&quot;getEmployeeTaskByEmpId&quot; resultMap=&quot;EmployeeTaskMap&quot;&gt;\n        select id, emp_id, task_id, note from t_employee_task where emp_id = #{empId}\n    &lt;/select&gt;\n\n&lt;/mapper&gt;\n</code></pre>\n<p>注意，association元素代表一对一级联的开始。property属性代表映射到POJO属性上。select配置是命名空间+SQL id的形式，这样便可以指向对应Mapper的SQL，MyBatis就会通过对应的SQL将数据查询回来。column代表SQL的列，用作参数传递给select属性制定的SQL，如果是多个参数则用逗号隔开。</p>\n<p>体检表能拆分为男性雇员和女性雇员，所以就有两个简单的映射器，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.MaleHealthFormMapper&quot;&gt;\n   &lt;select id=&quot;getMaleHealthForm&quot; parameterType=&quot;long&quot; resultType=&quot;com.ssm.learn.chapter5.pojo.MaleHealthForm&quot;&gt;\n       select id, heart, liver, spleen, lung, kidney, prostate, note from t_male_health_form\n       where emp_id = #{id}\n   &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.FemaleHealthFormMapper&quot;&gt;\n   &lt;select id=&quot;getFemaleHealthForm&quot; parameterType=&quot;long&quot; resultType=&quot;com.ssm.learn.chapter5.pojo.FemaleHealthForm&quot;&gt;\n       select id, heart, liver, spleen, lung, kidney, prostate, note from t_female_health_form\n       where emp_id = #{id}\n   &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>创建雇员的映射关系，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper.EmployeeMapper&quot;&gt;\n    &lt;resultMap id=&quot;employee&quot; type=&quot;com.ssm.learn.chapter5.pojo.Employee&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result column=&quot;real_name&quot; property=&quot;realName&quot;/&gt;\n        &lt;result column=&quot;sex&quot; property=&quot;sex&quot; typeHandler=&quot;com.ssm.learn.chapter5.typeHandler.SexTypeHandler&quot;/&gt;\n        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;\n        &lt;result column=&quot;mobile&quot; property=&quot;mobile&quot;/&gt;\n        &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt;\n        &lt;result column=&quot;position&quot; property=&quot;position&quot;/&gt;\n        &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;\n        &lt;association property=&quot;workCard&quot; column=&quot;id&quot;\n                     select=&quot;com.ssm.learn.chapter5.mapper.WorkCardMapper.getWorkCardByEmpId&quot;/&gt;\n        &lt;collection property=&quot;employeeTaskList&quot; column=&quot;id&quot; select=&quot;com.ssm.learn.chapter5.mapper.EmployeeTaskMapper.getEmployeeTaskByEmpId&quot;/&gt;\n        &lt;discriminator javaType=&quot;long&quot; column=&quot;sex&quot;&gt;\n            &lt;case value=&quot;1&quot; resultMap=&quot;MaleHealthFormMapper&quot;/&gt;\n            &lt;case value=&quot;2&quot; resultMap=&quot;FemaleHealthFormMapper&quot;/&gt;\n        &lt;/discriminator&gt;\n    &lt;/resultMap&gt;\n\n    &lt;resultMap id=&quot;FemaleEmployeeMap&quot; type=&quot;com.ssm.learn.chapter5.pojo.FemaleEmployee&quot; extends=&quot;employee&quot;&gt;\n        &lt;association property=&quot;femaleHealthForm&quot; column=&quot;id&quot; select=&quot;com.ssm.learn.chapter5.mapper.FemaleHealthFormMapper.getFemaleHealthForm&quot;/&gt;\n    &lt;/resultMap&gt;\n\n    &lt;resultMap id=&quot;MaleEmployeeMap&quot; type=&quot;com.ssm.learn.chapter5.pojo.MaleEmployee&quot; extends=&quot;employee&quot;&gt;\n        &lt;association property=&quot;maleHealthForm&quot; column=&quot;id&quot; select=&quot;com.ssm.learn.chapter5.mapper.MaleHealthFormMapper.getMaleHealthForm&quot;/&gt;\n    &lt;/resultMap&gt;\n\n    &lt;select id=&quot;getEmployee&quot; parameterType=&quot;long&quot; resultMap=&quot;employee&quot;&gt;\n        select id, real_name as realName, sex, birthday, mobile, email, position, note, from t_employee\n        where id = #{id}\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<ul>\n<li>association元素，对工牌进行一对一级联。</li><li>collection元素，一对多级联，其select元素指向SQL，将通过column制定的SQL字段作为参数进行传递，然后将结果返回给雇员POJO的属性employeeTaskList。</li><li>discriminator元素，鉴别器，它的属性column代表使用哪个字段进行鉴别，这里是sex，而它的子元素case，则用于进行区分。而resultMap属性表示采用哪个ResultMap去映射，比如sex为1，则使用maleHealthFormMapper进行映射。</li></ul>\n<p>而对于雇员体检表而言，id为employee的resultMap，被maleHealthMapper和femaleHealthMapper通过extends元素继承。</p>\n<p>测试级联，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test9() {\n    SqlSession sqlSession = null;\n    try {\n        sqlSession = SqlSessionFactoryUtils.openSqlSession();\n        EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class);\n        Employee employee = employeeMapper.getEmployee(1L);\n        logger.info(employee.getBirthday());\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (sqlSession != null) {\n            sqlSession.close();\n        }\n    }\n\n}\n</code></pre>\n<p>运行可以看到所有级联都成功了，但是这会引发性能问题，这叫N+1问题。</p>\n<h3 id=\"h3-5-8-4-n-1-\"><a name=\"5.8.4    N+1问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8.4    N+1问题</h3><p>比如作为一个雇员的管理者，它只想看到员工信息和员工任务信息，那么体检表和工牌的信息就是多余的。</p>\n<p>假设现在有N个关联关系完成了级联，那么只要再加入一个级联关系，就变成了N+1个级联，所有的级联SQL都会被执行，显然会有很多并不是我们关心的数据被取出，这样会造成很大的资源浪费，这就是N+1问题。</p>\n<p>为了应对N+1问题，MyBatis提供了延迟加载功能，即在一开始取出雇员信息是，并不需要将工牌表、体检表、任务表的记录取出，而是只将雇员信息和雇员任务表的信息取出。当我们通过雇员POJO访问工牌表时，体检表和任务表的记录才通过对应的SQL取出。</p>\n<h3 id=\"h3-5-8-5-\"><a name=\"5.8.5    延迟加载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8.5    延迟加载</h3><p>MyBatis提供延迟加载，我们希望一次性把常用的级联数据通过SQL直接查询出来，而对于那些不常用的级联数据不要取出，而是等待要用时才取出，这些不常用的级联数据可以采用延迟加载的功能。</p>\n<p>在MyBatis的settings配置中存在两个元素可以配置级联，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>作用</th>\n<th>配置选项说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lazyLoadingEnabled</td>\n<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</td>\n<td>true\\</td>\n<td>false</td>\n<td>false</td>\n</tr>\n<tr>\n<td>aggressiveLazyLoading</td>\n<td>当启用时，对任意延迟属性的调用都会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载</td>\n<td>true\\</td>\n<td>false</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<p>修改MyBatis配置文件，增加如下代码：</p>\n<pre><code class=\"lang-xml\">&lt;settings&gt;\n    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p>选项lazyLoadingEnabled决定是否开启延迟加载，而选项aggressiveLazyLoading决定是否采用层级加载，但是它们都是全局性配置，不能解决我们的需求。在MyBatis中使用fetchType属性，它可以处理全局定义无法处理的问题，进行自定义。fetchType出现在级联元素（association、collection，注意，discrimination没有这个属性）中，它由两个值可选：</p>\n<ul>\n<li>eager，获得当前POJO后立即加载对应的数据。</li><li>lazy，获得当前POJO后延迟加载对应的数据。</li></ul>\n<p>在保证lazyLoadingEnabled=true和aggressiveLazyLoading=false的前提下，对雇员的映射文件关于雇员属性、雇员任务进行如下修改：</p>\n<pre><code class=\"lang-xml\">&lt;collection property=&quot;employeeTaskList&quot; column=&quot;id&quot; select=&quot;com.ssm.learn.chapter5.mapper.EmployeeTaskMapper.getEmployeeTaskByEmpId&quot; fetchType=&quot;eager&quot;/&gt;\n</code></pre>\n<p>然后进行调试，这个时候已经按照我们的要求加载了数据，先加载雇员信息，然后加载雇员任务信息。fetchType属性会忽略全局配置项lazyLoadingEnabled和aggressiveLazyLoading。</p>\n<h3 id=\"h3-5-8-6-\"><a name=\"5.8.6    多对多级联\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.8.6    多对多级联</h3><p>现实中有许多用户，用户由归属于一些角色，这样一个用户可以对应多个角色，而一个角色又可以由多个用户担当。这就是多对多关联关系。但更多的都是拆分为两个一对多的关系，也就是一个角色对应多个用户和一个用户对应多个角色，这样就可以设计用户和角色的POJO了，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.learn.chapter5.pojo2;\n\nimport java.util.List;\n\npublic class Role2 {\n   private Long id;\n   private String roleName;\n   private String note;\n   // 关联用户信息，一对多关联\n   private List&lt;User2&gt; userList;\n\n    /*getter and setter*/\n}\n</code></pre>\n<pre><code class=\"lang-java\">package com.ssm.learn.chapter5.pojo2;\n\nimport java.util.List;\n\nimport com.ssm.learn.chapter5.enumeration.SexEnum;\n\npublic class User2 {\n   private Long id;\n   private String userName;\n   private String realName;\n   private SexEnum sex;\n   private String moble;\n   private String email;\n   private String note;\n   // 对角色一对多关联\n   private List&lt;Role2&gt; roleList;\n\n    /*getter and setter*/\n}\n</code></pre>\n<p>配置映射文件，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper2.RoleMapper2&quot;&gt;\n   &lt;resultMap type=&quot;com.ssm.learn.chapter5.pojo2.Role2&quot; id=&quot;roleMapper&quot;&gt;\n      &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;\n      &lt;result column=&quot;role_name&quot; property=&quot;roleName&quot; /&gt;\n      &lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt;\n      &lt;collection property=&quot;userList&quot; column=&quot;id&quot; fetchType=&quot;lazy&quot;\n         select=&quot;com.ssm.learn.chapter5.mapper2.UserMapper2.findUserByRoleId&quot; /&gt;\n   &lt;/resultMap&gt;\n\n   &lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultMap=&quot;roleMapper&quot;&gt;\n      select id, role_name, note from t_role where id = #{id}\n   &lt;/select&gt;\n\n   &lt;select id=&quot;findRoleByUserId&quot; parameterType=&quot;long&quot; resultMap=&quot;roleMapper&quot;&gt;\n      select r.id, r.role_name, r.note from t_role r, t_user_role ur\n      where r.id = ur.role_id and ur.user_id = #{userId}\n   &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.ssm.learn.chapter5.mapper2.UserMapper2&quot;&gt;\n   &lt;resultMap type=&quot;com.ssm.learn.chapter5.pojo2.User2&quot; id=&quot;userMapper&quot;&gt;\n      &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;\n      &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; /&gt;\n      &lt;result column=&quot;real_name&quot; property=&quot;realName&quot; /&gt;\n      &lt;result column=&quot;sex&quot; property=&quot;sex&quot;\n         typeHandler=&quot;com.ssm.learn.chapter5.typeHandler.SexTypeHandler&quot; /&gt;\n      &lt;result column=&quot;mobile&quot; property=&quot;moble&quot; /&gt;\n      &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;\n      &lt;result column=&quot;position&quot; property=&quot;position&quot; /&gt;\n      &lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt;\n      &lt;collection property=&quot;roleList&quot; column=&quot;id&quot; fetchType=&quot;lazy&quot;\n         select=&quot;com.ssm.learn.chapter5.mapper2.RoleMapper2.findRoleByUserId&quot; /&gt;\n   &lt;/resultMap&gt;\n   &lt;select id=&quot;getUser&quot; parameterType=&quot;long&quot; resultMap=&quot;userMapper&quot;&gt;\n      select id, user_name, real_name, sex, moble, email, note from t_user where\n      id =#{id}\n   &lt;/select&gt;\n   &lt;select id=&quot;findUserByRoleId&quot; parameterType=&quot;long&quot; resultMap=&quot;userMapper&quot;&gt;\n      select u.id, u.user_name, u.real_name, u.sex, u.moble, u.email, u.note\n      from\n      t_user u , t_user_role ur where u.id = ur.user_id and ur.role_id =#{roleId}\n   &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>这里都使用了collection去关联，但是把fetchType都设置为lazy，启用延时加载。</p>\n<p>测试代码如下：</p>\n<pre><code class=\"lang-java\">@Test\npublic void test10(){\n    SqlSession sqlSession=null;\n    try{\n        sqlSession=SqlSessionFactoryUtils.openSqlSession();\n        RoleMapper2 roleMapper2 = sqlSession.getMapper(RoleMapper2.class);\n        Role2 role = roleMapper2.getRole(1L);\n        role.getUserList();\n        UserMapper2 userMapper2 = sqlSession.getMapper(UserMapper2.class);\n        User2 user = userMapper2.getUser(1L);\n    }catch (Exception e){\n        e.printStackTrace();\n    }finally {\n        if(sqlSession!=null){\n            sqlSession.close();\n        }\n    }\n}\n</code></pre>\n<p>运行程序可以看到执行了3条SQL，因为调用getUserList所以才有了第二条SQL。</p>\n<h2 id=\"h2-5-9-\"><a name=\"5.9    缓存\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.9    缓存</h2><p>在MyBatis中允许使用缓存，把那些常用且命中率高的数据缓存起来，能够有效提高系统性能。</p>\n<p>MyBatis分为一级缓存和二级缓存，同时可以配置关于缓存的设置。</p>\n<h3 id=\"h3-5-9-1-\"><a name=\"5.9.1    一级缓存和二级缓存\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.9.1    一级缓存和二级缓存</h3><p>一级缓存是在SqlSession上的缓存，默认自动开启。二级缓存是在SqlSessionFactory上的缓存。</p>\n<p>没有任何配置的环境测试一级缓存，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void testFirstLevelCache() {\n    SqlSession sqlSession = null;\n    try {\n        sqlSession = SqlSessionFactoryUtils.openSqlSession();\n        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n        Role role = roleMapper.getRole(1L);\n        logger.info(&quot;再获取一次POJO......&quot;);\n        Role role2 = roleMapper.getRole(1L);\n    } catch (Exception e) {\n        logger.info(e.getMessage(), e);\n    } finally {\n        if (sqlSession != null) {\n            sqlSession.close();\n        }\n    }\n}\n</code></pre>\n<p>运行代码，得到如下日志：</p>\n<pre><code class=\"lang-markdown\">DEBUG 2020-02-25 16:42:22,848 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt;  Preparing: select id,role_name as roleName,note from t_role where id = ?; \nDEBUG 2020-02-25 16:42:22,883 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt; Parameters: 1(Long)\nDEBUG 2020-02-25 16:42:22,899 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: &lt;==      Total: 1\n INFO 2020-02-25 16:42:22,899 com.ssm.learn.chapter5.test.MyTest: 再获取一次POJO......\nDEBUG 2020-02-25 16:42:22,900 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@63440df3]\n</code></pre>\n<p>可以看到虽然对同一个对象进行了两次获取，但是实际上只有一条SQL被执行，其原因是代码使用了同一个SqlSession对象获取数据。当一个SqlSession第一次通过SQL和参数获取对象后就会将它缓存起来，如果下次的SQL和参数没有发生变化，并且缓存没有超时或者声明需要刷新时，它就会从缓存中获取数据，而不是通过SQL获取了。修改代码，如下所示：</p>\n<pre><code class=\"lang-java\">@Test\npublic void testFirstLevelCache() {\n    SqlSession sqlSession = null;\n    SqlSession sqlSession2 = null;\n    try {\n        sqlSession = SqlSessionFactoryUtils.openSqlSession();\n        sqlSession2 = SqlSessionFactoryUtils.openSqlSession();\n        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n        Role role = roleMapper.getRole(1L);\n        //需要提交，如果是一级缓存，MyBatis才会缓存对象到SqlSessionFactory层面\n        sqlSession.commit();\n        logger.info(&quot;不同sqlSession再获取一次POJO......&quot;);\n        RoleMapper roleMapper2 = sqlSession2.getMapper(RoleMapper.class);\n        Role role2 = roleMapper2.getRole(1L);\n        //需要提交，如果是一级缓存，MyBatis才会缓存对象到SqlSessionFactory层面\n    } catch (Exception e) {\n        logger.info(e.getMessage(), e);\n    } finally {\n        if (sqlSession != null) {\n            sqlSession.close();\n        }\n        if (sqlSession2 != null) {\n            sqlSession2.close();\n        }\n    }\n}\n</code></pre>\n<p>运行代码，得到以下日志：</p>\n<pre><code class=\"lang-markdown\">DEBUG 2020-02-25 16:55:56,004 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt;  Preparing: select id,role_name as roleName,note from t_role where id = ?; \nDEBUG 2020-02-25 16:55:56,039 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt; Parameters: 1(Long)\nDEBUG 2020-02-25 16:55:56,056 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: &lt;==      Total: 1\n INFO 2020-02-25 16:55:56,057 com.ssm.learn.chapter5.test.MyTest: 不同sqlSession再获取一次POJO......\nDEBUG 2020-02-25 16:55:56,057 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Opening JDBC Connection\nDEBUG 2020-02-25 16:55:56,062 org.apache.ibatis.datasource.pooled.PooledDataSource: Created connection 1956710488.\nDEBUG 2020-02-25 16:55:56,062 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@74a10858]\nDEBUG 2020-02-25 16:55:56,063 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt;  Preparing: select id,role_name as roleName,note from t_role where id = ?;\n</code></pre>\n<p>可以看到SQL被执行了两次，这说明一级缓存是在SqlSession层面的，对于不同的SqlSession对象是不能共享的。为了是SqlSession对象之间共享相同的缓存，有时候需要开启二级缓存，只需要在映射文件上加入代码：</p>\n<pre><code class=\"lang-xml\">&lt;cache/&gt;\n</code></pre>\n<p>这个时候MyBatis会序列化和反序列化对应的POJO，也就要求POJO是一个可序列化的对象，那么它就必须实现Serializable接口。代码如下所示：</p>\n<pre><code class=\"lang-java\">public class Role implements Serializable {\n    ...\n}\n</code></pre>\n<p>再次运行代码，得到以下日志：</p>\n<pre><code class=\"lang-markdown\">DEBUG 2020-02-25 17:02:39,248 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt;  Preparing: select id,role_name as roleName,note from t_role where id = ?; \nDEBUG 2020-02-25 17:02:39,281 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==&gt; Parameters: 1(Long)\nDEBUG 2020-02-25 17:02:39,297 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: &lt;==      Total: 1\n INFO 2020-02-25 17:02:39,309 com.ssm.learn.chapter5.test.MyTest: 不同sqlSession再获取一次POJO......\nDEBUG 2020-02-25 17:02:39,367 org.apache.ibatis.cache.decorators.LoggingCache: Cache Hit Ratio [com.ssm.learn.chapter5.mapper.RoleMapper]: 0.5\nDEBUG 2020-02-25 17:02:39,367 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@462d5aee]\n</code></pre>\n<p>可以看到不同的SqlSession在获取同一条记录，只发送了一条SQL。因为这个时候MyBatis将其保存在SqlSessionFactory层面。</p>\n', '# 第5章	映射器\n\n映射器是MyBatis最复杂且最重要的组件。它由一个接口和XML文件（或者注解组成）。在映射器中，可以配置参数、各类的SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的POJO或者其他对象上，映射器能有效屏蔽JDBC底层的代码。\n\n映射器可以使用注解完成，但在企业应用不广，推荐使用XML方式，是因为：\n\n- 面对复杂性，SQL会显得无力，尤其是长句SQL；\n- 注解的可读性较差；\n- 注解丢失了XML上下文引用的功能\n\n## 5.1    概述\n\n映射器的常用配置元素如下表所示：\n\n| 元素名称         | 描述                                                         | 备注                                            |\n| ---------------- | ------------------------------------------------------------ | ----------------------------------------------- |\n| select           | 查询语句，最常用、最复杂的元素之一                           | 可以自定义参数，返回结果集等                    |\n| insert           | 插入语句                                                     | 执行后返回一个参数，代表插入的条数              |\n| update           | 更新语句                                                     | 执行后返回一个参数，代表更新的条数              |\n| delete           | 删除语句                                                     | 执行后返回一个参数，代表删除的条数              |\n| ~~parameterMap~~ | 定义参数映射关系                                             | 即将被删除，不建议使用                          |\n| sql              | 允许定义一部分SQL，然后在各个地方引用它                      | 例如，定义一张表的列名，可以在多个SQL语句中使用 |\n| resultMap        | 用来描述从数据库结果集中来加载对象，它是最复杂、最强大的元素 | 提供映射规则                                    |\n| cache            | 给定名称空间的缓存配置                                       | ---                                             |\n| cache-ref        | 其他命名空间缓存配置的引用                                   | ---                                             |\n\n## 5.2	引入映射器的方法\n\n### 5.2.1	用文件路径引入映射器\n\n```xml\n<mappers>\n    <mapper resource=\"demo/mapper/demoMapper.xml\"/>\n</mappers>\n```\n\n其中，resource属性值为映射器的xml文件的资源路径\n\n### 5.2.2	用包名引入映射器\n\n```xml\n<mappers>\n    <package name=\"demo.mapper\"/>\n</mappers>\n```\n\n其中，name属性值为映射器的接口所在包的全限定名\n\n### 5.2.3	用类注册引入映射器\n\n```xml\n<mappers>\n    <mapper class=\"demo.mapper.DemoMapper1\"/>\n     <mapper class=\"demo.mapper.DemoMapper2\"/>\n</mappers>\n```\n\n其中，class属性值为映射器的接口的全限定名\n\n## 5.3	select元素——查询语句\n\nselect元素的常用配置如下表所示：\n\n| 元素             | 说明                                                         | 备注                                                       |\n| ---------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |\n| id               | 它和Mapper的命名空间组合起来是唯一的，供MyBatis调用          | 如果命名空间和id结合起来不唯一，MyBatis会抛出异常          |\n| parameterType    | 可以给出类的全限定名，也可以是别名，但是别名必须是MyBatis内部定义或者自定义的 | 可以选择JavaBean、Map等简单的参数类型传递给SQL             |\n| ~~parameterMap~~ | 即将废弃的元素，不建议使用                                   | ---                                                        |\n| resultType       | 定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规则映射；或定义为in、double、float、map等参数；也可以使用别名，但是要符合别名规范，且不能和resultMap同时使用 | 常用的参数之一，比如统计总条数时可以把它的值设置为int      |\n| resultMap        | 它是映射集的引用，将执行强大的映射功能。我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会 | MyBatis最复杂的元素，可以配置映射规则、级联、typeHandler等 |\n\n另外，如果还要设置缓存，还会使用到FlushCache、useCache，这里不展开讲。\n\n### 5.3.1	简单的select元素的应用\n\n先学习一个最简单的例子：统计用户表同一个姓氏的用户数量，代码如下所示：\n\n```xml\n<select id=\"countByFirstName\" parameterType=\"string\" resultType=\"int\">\n    select count(*) total from t_user where user_name like concat(#{firstName},\'%\')\n</select>\n```\n\n其中的元素含义：\n\n- id：SQL语句的唯一标识\n- parameterType：SQL语句接收的参数类型，可以是类的别名也可以是类的全限定名\n- resultType：SQL语句返回的结果类型，可以是类的别名也可以是类的全限定名\n\n接着还需要定义一个接口方法，代码如下所示：\n\n```java\npublic interface UserMapper {\n    int countByFirstName(String firstName);\n}\n```\n\n### 5.3.2	自动映射和驼峰规则\n\nMyBatis提供自动映射功能，在默认情况下是开启的。\n\n在settings元素中有两个可配置选项autoMappingBehavior和mapUnderscoreToCamelCase，它们是控制自动映射和驼峰映射的开关。一般而言，自动映射使用的多一些，而驼峰映射要求比较苛刻，应用不广。\n\nautoMappingBehavior的取值有：\n\n- NONE，不进行自动映射\n- PARTIAL，默认值，只对没有嵌套结果集进行自动映射\n- FULL，对所有的结果集进行自动映射，包括嵌套结果集\n\n在默认情况下使用默认值即可。规则如下所示：\n\n```java\npublic class Role {\n    private Long id;\n    private String roleName;\n    private String note;\n    /*getter and setter*/\n}\n```\n\n```xml\n<select id=\"getRole\" parameterType=\"long\" resultType=\"role\">\n    select id,role_name as roleName,note from t_role where id = #{id};\n</select>\n```\n\n如果编写的SQL列名和POJO的属性名一致，那么就会形成自动映射。原来的列名role_name被别名roleName替代，所以也会对应起来。\n\n### 5.3.3	传递多个参数\n\n####5.3.3.1	使用map接口传递多个参数\n\n假设要通过角色名称（role_name）和备注（note）两个参数对角色进行模糊查询，则可以使用map接口。\n\n把接口方法定义为：	\n\n```java\nList<Role> findRolesByMap(Map<String,Object> parameterMap);\n```\n\n使用它在SQL中设置对应的参数，代码如下所示：\n\n```xml\n<select id=\"findRolesByMap\" parameterType=\"map\" resultType=\"role\">\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(\'%\',#{roleName},\'%\')\n    and note like concat(\'%\',#{note},\'%\')\n</select>\n```\n\n测试如下：\n\n```java\n@Test\npublic void test2() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    Map<String, Object> parameterMap = new HashMap<>();\n    parameterMap.put(\"roleName\", \"1\");\n    parameterMap.put(\"note\", \"1\");\n    List<Role> roles = roleMapper.findRolesByMap(parameterMap);\n    logger.info(roles);\n    sqlSession.close();\n}\n```\n\n由于使用map不能限定其传递的数据类型，所以业务性质不强，可读性差，因此不推荐使用。\n\n#### 5.3.3.2	使用注解传递多个参数\n\nMyBatis提供了@Param注解，它可以定义映射器的参数名称，使用它可读性更好。把接口方法定义为：\n\n```java\nList<Role> findRolesByAnnotation(@Param(\"roleName\") String roleName,\n                                 @Param(\"note\") String note);\n```\n\n修改映射文件，代码如下所示：\n\n```java\n<select id=\"findRolesByAnnotation\" resultType=\"role\">\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(\'%\',#{roleName},\'%\')\n    and note like concat(\'%\',#{note},\'%\')\n</select>\n```\n\n注意，此时不用给出parameterType属性，MyBatis会自动探索。\n测试如下所示：\n\n```java\n@Test\npublic void test3() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    List<Role> roles = roleMapper.findRolesByAnnotation(\"1\",\"1\");\n    logger.info(roles);\n    sqlSession.close();\n}\n```\n\n改写后可读性大大提高，但是如果SQL很复杂，参数很多，那么接口方法的参数个数也会很多，这样使用很不方便。所以，MyBatis还提供了传递JavaBean的形式。\n\n#### 5.3.3.3	通过JavaBean传递多个参数\n\n首先定义一个参数的POJO——RoleParams，代码如下所示：\n\n```java\npublic class RoleParams {\n    private String roleName;\n    private String note;\n    \n    public RoleParams(){}\n    /*getter and setter*/\n}\n```\n\n此时把接口方法定义为：\n\n```java\nList<Role> findRolesByBean(RoleParams roleParams);\n```\n\n修改映射文件，代码如下所示：\n\n```xml\n<select id=\"findRolesByBean\" parameterType=\"com.ssm.learn.chapter5.pojo.RoleParams\" resultType=\"role\">\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(\'%\',#{roleName},\'%\')\n    and note like concat(\'%\',#{note},\'%\')\n</select>\n```\n\n注意此时的parameterType属性值修改为RoleParams的全限定名或者别名。\n\n测试如下所示：\n\n```java\n@Test\npublic void test5() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    RoleParams roleParams = new RoleParams();\n    roleParams.setRoleName(\"1\");\n    roleParams.setNote(\"1\");\n    List<Role> roles = roleMapper.findRolesByBean(roleParams);\n    logger.info(roles);\n    sqlSession.close();\n}\n```\n\n#### 5.3.3.4	混合使用\n\n在某种情况下可能需要混合使用几种方式来传递参数。比如通过角色名称和备注查询一个角色，与此同时还支持分页，分页的POJO——PageParams如下所示：\n\n```java\npublic class PageParams {\n    private int start;\n    private int limit;\n    \n    public PageParams(){}\n    /*getter and setter*/\n}\n```\n\n此时接口方法定义为：\n\n```java\nList<Role> findByMix(@Param(\"params\")RoleParams roleParams, \n                     @Param(\"page\")PageParams pageParams);\n```\n\n修改映射文件，代码如下所示：\n\n```xml\n<select id=\"findByMix\" resultType=\"role\">\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(\'%\',#{params.roleName},\'%\')\n    and note like concat(\'%\',#{params.note},\'%\')\n    limit #{page.start},#{page.limit}\n</select>\n```\n\n可以看到MyBatis对RoleParams、PageParams这类的JavaBean提供EL（中间）支持\n\n#### 5.3.3.5	总结\n\n对4种传递参数的方法进行评价：\n\n- 使用map传递参数丧失了业务可读性，实际应用应该果断废弃；\n- 使用@Param注解适用于参数较少的情况，一般不超过5个；\n- 当参数多于5个时，建议使用JavaBean方式；\n- 对于使用混合参数的，要明确参数合理性\n\n### 5.3.4    使用resultMap映射结果集\n\n为了支持复杂的映射，select元素提供了resultMap属性。先定义resultMap属性，代码如下所示：\n\n```xml\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.RoleMapper\">\n    <resultMap id=\"roleMap\" type=\"role\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"roleName\" column=\"role_name\"/>\n        <result property=\"note\" column=\"note\"/>\n    </resultMap>\n    <select id=\"getRoleUseResultMap\" parameterType=\"long\" resultMap=\"roleMap\">\n         select id,role_name as roleName,note from t_role where id = #{id};\n    </select>\n</mapper>\n```\n\n- resultMap的属性id是它的标识，type代表使用哪个类作为其映射的类，可以是别名或者全限定名；\n- 它的子元素id代表resultMap的主键，而result代表其属性，id和result元素的属性property代表POJO的属性名称，而column代表SQL的列名。把POJO的属性和SQL的列名做对应。\n- 在select中resultMap属性表明使用哪个resultMap作为映射规则\n\n####5.3.5    分页参数RowBounds\n\nMyBatis不仅支持分页，而且还提供了专门处理分页的类——RowBounds。使用它很简单，只要给接口增加一个RowBounds参数即可。\n\n```java\n List<Role> findByRowBounds(@Param(\"roleName\") String roleName,\n                            @Param(\"note\") String note,\n                            RowBounds rowBounds);\n```\n\n修改映射文件，代码如下所示：\n\n```xml\n<select id=\"findByRowBounds\" resultType=\"role\">\n    select id,role_name as roleName,note from t_role\n    where role_name like concat(\'%\',#{roleName},\'%\')\n    and note like concat(\'%\',#{note},\'%\')\n</select>\n```\n\n代码中没有关于RowBounds的参数信息，它是MyBatis的一个附加参数，MyBatis会自动识别并完成分页。\n\n测试如下所示：\n\n```java\n@Test\npublic void test7() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    RowBounds rowBounds = new RowBounds(0, 20);\n    List<Role> roles = roleMapper.findByRowBounds(\"1\", \"1\", rowBounds);\n    logger.info(roles);\n    sqlSession.close();\n}\n```\n\nRowBounds接收两个参数，第一个是偏移量offset，第二个参数是限制条数limit，这里表示从1条开始限定返回至多20条记录的结果。RowBounds只适合查询少量数据的场景，查询大量数据可以使用分页插件。\n\n## 5.4	insert元素——插入语句\n\ninsert元素的常用配置如下表所示：\n\n| 属性             | 描述                                                         | 备注                                              |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------- |\n| id               | SQL编号，用于表示这条SQL语句                                 | 命名空间+id+databaseId唯一，否则MyBatis会抛出异常 |\n| parameterType    | 参数类型，同select元素                                       | 和select元素一样，可以是单个参数或者多个参数      |\n| useGeneratedKeys | 是否启用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。（比如MySQL和SQL Server这样的数据库表的自增主键） | 默认值为false                                     |\n| keyProperty      | （仅对insert和update有用）唯一标记一个属性，MyBatis会通过getGeneratedKeys的返回值，或者通过insert语句的selectKey子元素设置它的键值。如果是复合主键，要把每一个名称用逗号隔开 | 默认值为unset。不能和KeyColumn连用                |\n| keyColumn        | （仅对insert和update有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像PostgreSQL）中是必须的，当主键列不是表中的第一列时需要设置。如果是复合主键，要把每一个名称用逗号隔开 | 不能和KeyProperty连用                             |\n\n执行一条insert语句后，会返回一个整数表示其影响记录数。\n\n### 5.4.2	简单的insert语句的应用\n\n写一条SQL插入角色，这是一条最简单的插入语句，代码如下所示：\n\n```xml\n<insert id=\"insertRole\" parameterType=\"role\">\n    insert into t_role(role_name,note)  values (#{roleName},#{note});\n</insert>\n```\n\n- id表示这条SQL；\n- parameterType代表传入参数类型；\n- 没有配置的属性采用默认值\n\n### 5.4.3    主键回填\n\n上面的代码并没有插入id列，因为MySQL中的表采用了自增主键，但有时候还需要这个主键来关联其它业务。\n\ninsert标签中有这样一个属性useGeneratedKeys来获取主键，打开这个开关后，还要配置其属性keyProperty或keyColumn，告诉系统把生成的主键放入哪个属性，如果存在多个主键，就用逗号隔开。\n\n修改映射文件，让程序返回主键，代码如下所示：\n\n```xml\n<insert id=\"insertRole\" parameterType=\"role\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into t_role(role_name,note)  values (#{roleName},#{note});\n</insert>\n```\n\n这样就会把数据库生成的主键回填至keyProperty指定的POJO属性，这里是id。\n\n测试主键回填的结果，代码如下所示：\n\n```java\n@Test\npublic void test8() {\n    SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession();\n    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n    Role role = new Role();\n    role.setRoleName(\"二郎神\");\n    role.setNote(\"杨戬\");\n    logger.info(role);\n    roleMapper.insertRole(role);\n    logger.info(role);\n    sqlSession.close();\n}\n```\n\n运行可看到，在执行insertRole方法前roleid值为null，而执行后值不为null。\n\n### 5.4.4	自定义主键\n\n有时候主键可能依赖于某些规则，比如取消角色表的id递增规则，修改为：\n\n- 当角色表记录为空时，id设置为1\n- 当角色表记录不为空时，id设置为当前id加3\n\nMyBatis可用selectKey元素实现自定义键值的生成规则。代码如下所示：\n\n```xml\n<<insert id=\"insertRole\" parameterType=\"role\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n	<selectKey keyProperty=\"id\" resultType=\"long\" order=\"BEFORE\">\n    	select if (max(id) = null,1,max(id)+3) from t_role\n	</selectKey>\n	insert into t_role(id,role_name,note)  values (#{id},#{roleName},#{note});\n</insert>\n```\n\n以上代码定义了selectKey元素，它的keyProperty指定了id属性作为POJO的主键，resultType指定了返回long型的结果集，而order属性为BEFORE表示它将于当前定义的SQL前执行。\n\n## 5.5	update元素和delete元素\n\nupdate元素和delete元素比较简单，和insert元素差不多，执行后也会返回一个整数，用来标识该SQL语句影响了数据库的记录行数。更新和删除角色表记录，代码如下所示：\n\n```xml\n<update id=\"updateRole\" parameterType=\"role\">\n    update t_role set role_name=#{roleName},set note=#{note} where id=#{id};\n</update>\n```\n\n```xml\n<delete id=\"deleteRole\" parameterType=\"long\">\n    delete from t_role where id = #{id};\n</delete>\n```\n\n## 5.6	sql元素\n\nsql元素的作用在于可以定义一条SQL的一部分，方便后面的SQL引用它，比如最典型的列名，通常情况下要在select、insert语句中反复编写，特别字段多的表。这时候可以使用sql元素，代码如下所示：\n\n```xml\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.RoleMapper\"><!--namespace对应接口的全限定名-->\n    <resultMap id=\"roleMap\" type=\"role\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"roleName\" column=\"role_name\"/>\n        <result property=\"note\" column=\"note\"/>\n    </resultMap>\n\n    <sql id=\"roleCols\">\n        id,role_name,note\n    </sql>\n\n    <select id=\"getRole\" resultType=\"role\">\n        select <include refid=\"roleCols\"/> from t_role where id = #{id};\n    </select>\n\n    <insert id=\"insertRole\" parameterType=\"role\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        <selectKey keyProperty=\"id\" resultType=\"long\" order=\"BEFORE\">\n            select if (max(id) = null,1,max(id)+3) from t_role\n        </selectKey>\n        insert into t_role(<include refid=\"roleCols\"/>)  values (#{id},#{roleName},#{note});\n    </insert>\n</mapper>\n```\n\n可以看到，通过sql元素定义，就可以include元素引入到各条SQL语句中，减少了列名的重复编写。\n\nsql元素还支持变量传递，如下所示：\n\n```xml\n<sql id=\"roleCols\">\n    ${alias}.id,${alias}.role_name ,${alias}.note\n</sql>\n<select id=\"getRole\" resultType=\"role\">\n    select \n    <include refid=\"roleCols\">\n        <property name=\"alias\" value=\"r\"/>\n    </include>\n    from t_role where id = #{id};\n</select>\n```\n\n在include元素中定义了一个命名为alias的变量，其值是SQL表t_role的别名r，然后sql元素就可以使用这个变量名了。\n\n## 5.7	resultMap元素\n\nresultMap的作用主要是定义映射规则，也就是SQL到JavaBean的映射关系。\n\n### 5.7.1	使用POJO存储结果集\n\n```xml\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.RoleMapper\">\n    <resultMap id=\"roleMap\" type=\"role\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"roleName\" column=\"role_name\"/>\n        <result property=\"note\" column=\"note\"/>\n    </resultMap>\n</mapper>  \n```\n\nresultMap元素的属性id代表这个resultMap的标识，type代表需要映射的POJO，这里可以使用别名或者全限定名。在映射关系中，id表示对象的主键，property表示POJO的属性名称，column表示数据库列名。于是POJO就和数据库SQL的结果一一对应起来了。配置完成即可使用resultMap，如下所示：\n\n```xml\n<select id=\"getRoleUseResultMap\" parameterType=\"long\" resultMap=\"roleMap\">\n     select id,role_name as roleName,note from t_role where id = #{id};\n</select>\n```\n\n## 5.8	级联\n\n级联是一个数据库实体的概念。比如角色就需要存在用户与之对应，这样就有角色用户表，一个角色可能有多个用户，这就是一对多的级联；除此之外，还有一对一的级联，比如身份证和公民是一对一的关系。在MyBatis中还有一种被称为鉴别器的级联，它是一种可以选择具体实现类的级联，比如要查找雇员及其体检表的信息，但是雇员有性别之分，而根据性别的不同，其体检表的项目也会不一样，比如男性体检表可能有前列腺的项目，而女子体检表可能有子宫的项目，那么体检表应该分为男性和女性，从而根据雇员性别区关联。\n\n级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统的复杂度，同时降低系统性能，一般最好不超过3层。\n\n### 5.8.1	MyBatis中的级联\n\nMyBatis中的级联分为3种。\n\n- 鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分。\n- 一对一（association）：比如学生证和学生就是一种一对一的级联。\n- 一对多（collection）：比如班级和学生就是一种一对多的级联。\n\n值得注意的是，MyBatis没有多对多级联，因为多对多级联比较复杂，使用困难，而且可以通过两个一对多进行替换，所有MyBatis不支持。\n\n为了更好地阐述级联，先给出一个雇员级联模型。\n\n- 该模型以雇员表为中心\n- 雇员表和工牌表是一对一级联关系\n- 雇员表和员工任务表是一对多级联关系\n- 员工任务表和任务表是一对一级联关系\n- 每个雇员都会有一个体检表，随着雇员字段性别取值不同，会有不同的关联表\n\nmysql脚本略\n\n ### 5.8.2    建立POJO\n\n男性体检表和女性体检表继承于体检表，因此可以得出3个体检表，代码如下所示：\n\n```java\npublic class HealthForm {\n   \n   private Long id;\n   private Long empId;\n   private String heart;\n   private String liver;\n   private String spleen;\n   private String lung;\n   private String kidney;\n   private String note;\n    \n    /*getter and setter*/\n}\n```\n\n```java\npublic class MaleHealthForm extends HealthForm {\n   \n   private String prostate;\n	\n    /*getter and setter*/\n}\n```\n\n```java\npublic class FemaleHealthForm extends HealthForm {\n\n   private String uterus;\n	\n    /*getter and setter*/\n}\n```\n\n显然这个关联关系是通过MyBatis的鉴别器去完成。\n\n接下来设计员工表、工牌表和任务表的POJO，它们是以员工表为核心的，先完成工牌表和任务表的POJO，代码如下所示：\n\n```java\npublic class WorkCard {\n   private Long id;\n   private Long empId;\n   private String realName;\n   private String department;\n   private String mobile;\n   private String position;\n   private String note;\n    \n   /*getter and setter*/\n}\n```\n\n```java\npublic class Task {\n   private Long id;\n   private String title;\n   private String context;\n   private String note;\n   \n   /*getter and setter*/\n}\n```\n\n雇员任务表是通过任务编号(task_id)和任务进行一对一管理，这里只考虑其自身和任务编号的关联，而雇员对它的关联则由雇员去维护，这样就可得到雇员任务POJO，代码如下所示：\n\n```java\npublic class EmployeeTask {\n   private Long id;\n   private Long empId;\n    //任务按一对一级联\n   private Task task = null;\n   private String taskName;\n   private String note;\n   \n   /*getter and setter*/\n}\n```\n\n属性task是一个Task类对象，由它进行关联任务信息。\n\n男雇员和女雇员继承于雇员，这就是一个鉴别器，通过雇员类的属性性别来决定使用哪个具体的子类初始化对象。它与工牌表是一对一关联关系，对于雇员任务表是一对多关联关系，由此可以得出3个类，代码如下所示：\n\n```java\npublic class Employee {\n\n   private Long id;\n   private String realName;\n   private SexEnum sex = null;\n   private Date birthday;\n   private String mobile;\n   private String email;\n   private String position;\n   private String note;\n    //工牌按一对一级联\n   private WorkCard workCard;\n   //雇员任务按一对多级联\n   private List<EmployeeTask> employeeTaskList = null;\n   \n    /*getter and setter*/\n}\n```\n\n```java\npublic class MaleEmployee extends Employee {\n\n   private MaleHealthForm maleHealthForm = null;\n    \n   /*getter and setter*/\n}\n```\n\n```java\npublic class FemaleEmployee extends Employee {\n\n   private FemaleHealthForm femaleHealthForm = null;\n\n   /*getter and setter*/\n}\n```\n\n### 5.8.3	配置映射文件\n\n配置TaskMapper.xml和WorkCardMapper.xml，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.TaskMapper\">\n    <select id=\"getTask\" parameterType=\"long\" resultType=\"com.ssm.learn.chapter5.pojo.Task\">\n        select id,title,context,note from t_task where id =#{id}\n    </select>\n</mapper>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.WorkCardMapper\">\n    <select id=\"getWorkCardByEmpId\" parameterType=\"long\" resultType=\"com.ssm.learn.chapter5.pojo.WorkCard\">\n        select id, emp_id as empId, real_name as realName, department, mobile, position, note FROM t_work_card\n        where emp_id = #{empId}\n    </select>\n</mapper>\n```\n\n雇员任务表通过任务编号（task_id）和任务表示关联，这是一个一对一的级联关系，使用association元素，雇员任务表一对一级联如代码所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.EmployeeTaskMapper\">\n    <resultMap id=\"EmployeeTaskMap\" type=\"com.ssm.learn.chapter5.pojo.EmployeeTask\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"empId\" column=\"emp_id\"/>\n        <result property=\"taskName\" column=\"task_name\"/>\n        <result property=\"note\" column=\"note\"/>\n        \n        <association property=\"task\" column=\"task_id\" select=\"com.ssm.learn.chapter5.mapper.TaskMapper.getTask\"/>\n        \n    </resultMap>\n\n    <select id=\"getEmployeeTaskByEmpId\" resultMap=\"EmployeeTaskMap\">\n        select id, emp_id, task_id, note from t_employee_task where emp_id = #{empId}\n    </select>\n\n</mapper>\n```\n\n注意，association元素代表一对一级联的开始。property属性代表映射到POJO属性上。select配置是命名空间+SQL id的形式，这样便可以指向对应Mapper的SQL，MyBatis就会通过对应的SQL将数据查询回来。column代表SQL的列，用作参数传递给select属性制定的SQL，如果是多个参数则用逗号隔开。\n\n体检表能拆分为男性雇员和女性雇员，所以就有两个简单的映射器，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.MaleHealthFormMapper\">\n   <select id=\"getMaleHealthForm\" parameterType=\"long\" resultType=\"com.ssm.learn.chapter5.pojo.MaleHealthForm\">\n       select id, heart, liver, spleen, lung, kidney, prostate, note from t_male_health_form\n       where emp_id = #{id}\n   </select>\n</mapper>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.FemaleHealthFormMapper\">\n   <select id=\"getFemaleHealthForm\" parameterType=\"long\" resultType=\"com.ssm.learn.chapter5.pojo.FemaleHealthForm\">\n       select id, heart, liver, spleen, lung, kidney, prostate, note from t_female_health_form\n       where emp_id = #{id}\n   </select>\n</mapper>\n```\n\n创建雇员的映射关系，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper.EmployeeMapper\">\n    <resultMap id=\"employee\" type=\"com.ssm.learn.chapter5.pojo.Employee\">\n        <id property=\"id\" column=\"id\"/>\n        <result column=\"real_name\" property=\"realName\"/>\n        <result column=\"sex\" property=\"sex\" typeHandler=\"com.ssm.learn.chapter5.typeHandler.SexTypeHandler\"/>\n        <result column=\"birthday\" property=\"birthday\"/>\n        <result column=\"mobile\" property=\"mobile\"/>\n        <result column=\"email\" property=\"email\"/>\n        <result column=\"position\" property=\"position\"/>\n        <result column=\"note\" property=\"note\"/>\n        <association property=\"workCard\" column=\"id\"\n                     select=\"com.ssm.learn.chapter5.mapper.WorkCardMapper.getWorkCardByEmpId\"/>\n        <collection property=\"employeeTaskList\" column=\"id\" select=\"com.ssm.learn.chapter5.mapper.EmployeeTaskMapper.getEmployeeTaskByEmpId\"/>\n        <discriminator javaType=\"long\" column=\"sex\">\n            <case value=\"1\" resultMap=\"MaleHealthFormMapper\"/>\n            <case value=\"2\" resultMap=\"FemaleHealthFormMapper\"/>\n        </discriminator>\n    </resultMap>\n\n    <resultMap id=\"FemaleEmployeeMap\" type=\"com.ssm.learn.chapter5.pojo.FemaleEmployee\" extends=\"employee\">\n        <association property=\"femaleHealthForm\" column=\"id\" select=\"com.ssm.learn.chapter5.mapper.FemaleHealthFormMapper.getFemaleHealthForm\"/>\n    </resultMap>\n\n    <resultMap id=\"MaleEmployeeMap\" type=\"com.ssm.learn.chapter5.pojo.MaleEmployee\" extends=\"employee\">\n        <association property=\"maleHealthForm\" column=\"id\" select=\"com.ssm.learn.chapter5.mapper.MaleHealthFormMapper.getMaleHealthForm\"/>\n    </resultMap>\n\n    <select id=\"getEmployee\" parameterType=\"long\" resultMap=\"employee\">\n        select id, real_name as realName, sex, birthday, mobile, email, position, note, from t_employee\n        where id = #{id}\n    </select>\n</mapper>\n```\n\n- association元素，对工牌进行一对一级联。\n- collection元素，一对多级联，其select元素指向SQL，将通过column制定的SQL字段作为参数进行传递，然后将结果返回给雇员POJO的属性employeeTaskList。\n- discriminator元素，鉴别器，它的属性column代表使用哪个字段进行鉴别，这里是sex，而它的子元素case，则用于进行区分。而resultMap属性表示采用哪个ResultMap去映射，比如sex为1，则使用maleHealthFormMapper进行映射。\n\n而对于雇员体检表而言，id为employee的resultMap，被maleHealthMapper和femaleHealthMapper通过extends元素继承。\n\n测试级联，代码如下所示：\n\n```java\n@Test\npublic void test9() {\n    SqlSession sqlSession = null;\n    try {\n        sqlSession = SqlSessionFactoryUtils.openSqlSession();\n        EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class);\n        Employee employee = employeeMapper.getEmployee(1L);\n        logger.info(employee.getBirthday());\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (sqlSession != null) {\n            sqlSession.close();\n        }\n    }\n\n}\n```\n\n运行可以看到所有级联都成功了，但是这会引发性能问题，这叫N+1问题。\n\n### 5.8.4	N+1问题\n\n比如作为一个雇员的管理者，它只想看到员工信息和员工任务信息，那么体检表和工牌的信息就是多余的。\n\n假设现在有N个关联关系完成了级联，那么只要再加入一个级联关系，就变成了N+1个级联，所有的级联SQL都会被执行，显然会有很多并不是我们关心的数据被取出，这样会造成很大的资源浪费，这就是N+1问题。\n\n为了应对N+1问题，MyBatis提供了延迟加载功能，即在一开始取出雇员信息是，并不需要将工牌表、体检表、任务表的记录取出，而是只将雇员信息和雇员任务表的信息取出。当我们通过雇员POJO访问工牌表时，体检表和任务表的记录才通过对应的SQL取出。\n\n### 5.8.5	延迟加载\n\nMyBatis提供延迟加载，我们希望一次性把常用的级联数据通过SQL直接查询出来，而对于那些不常用的级联数据不要取出，而是等待要用时才取出，这些不常用的级联数据可以采用延迟加载的功能。\n\n在MyBatis的settings配置中存在两个元素可以配置级联，如下所示：\n\n| 配置项                | 作用                                                         | 配置选项说明 | 默认值 |\n| --------------------- | ------------------------------------------------------------ | ------------ | ------ |\n| lazyLoadingEnabled    | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。在特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态 | true\\|false  | false  |\n| aggressiveLazyLoading | 当启用时，对任意延迟属性的调用都会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载 | true\\|false  | false  |\n\n修改MyBatis配置文件，增加如下代码：\n\n```xml\n<settings>\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\n</settings>\n```\n\n选项lazyLoadingEnabled决定是否开启延迟加载，而选项aggressiveLazyLoading决定是否采用层级加载，但是它们都是全局性配置，不能解决我们的需求。在MyBatis中使用fetchType属性，它可以处理全局定义无法处理的问题，进行自定义。fetchType出现在级联元素（association、collection，注意，discrimination没有这个属性）中，它由两个值可选：\n\n- eager，获得当前POJO后立即加载对应的数据。\n- lazy，获得当前POJO后延迟加载对应的数据。\n\n在保证lazyLoadingEnabled=true和aggressiveLazyLoading=false的前提下，对雇员的映射文件关于雇员属性、雇员任务进行如下修改：\n\n```xml\n<collection property=\"employeeTaskList\" column=\"id\" select=\"com.ssm.learn.chapter5.mapper.EmployeeTaskMapper.getEmployeeTaskByEmpId\" fetchType=\"eager\"/>\n```\n\n然后进行调试，这个时候已经按照我们的要求加载了数据，先加载雇员信息，然后加载雇员任务信息。fetchType属性会忽略全局配置项lazyLoadingEnabled和aggressiveLazyLoading。\n\n### 5.8.6	多对多级联\n\n现实中有许多用户，用户由归属于一些角色，这样一个用户可以对应多个角色，而一个角色又可以由多个用户担当。这就是多对多关联关系。但更多的都是拆分为两个一对多的关系，也就是一个角色对应多个用户和一个用户对应多个角色，这样就可以设计用户和角色的POJO了，代码如下所示：\n\n```java\npackage com.ssm.learn.chapter5.pojo2;\n\nimport java.util.List;\n\npublic class Role2 {\n   private Long id;\n   private String roleName;\n   private String note;\n   // 关联用户信息，一对多关联\n   private List<User2> userList;\n\n	/*getter and setter*/\n}\n```\n\n```java\npackage com.ssm.learn.chapter5.pojo2;\n\nimport java.util.List;\n\nimport com.ssm.learn.chapter5.enumeration.SexEnum;\n\npublic class User2 {\n   private Long id;\n   private String userName;\n   private String realName;\n   private SexEnum sex;\n   private String moble;\n   private String email;\n   private String note;\n   // 对角色一对多关联\n   private List<Role2> roleList;\n\n	/*getter and setter*/\n}\n```\n\n配置映射文件，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper2.RoleMapper2\">\n   <resultMap type=\"com.ssm.learn.chapter5.pojo2.Role2\" id=\"roleMapper\">\n      <id column=\"id\" property=\"id\" />\n      <result column=\"role_name\" property=\"roleName\" />\n      <result column=\"note\" property=\"note\" />\n      <collection property=\"userList\" column=\"id\" fetchType=\"lazy\"\n         select=\"com.ssm.learn.chapter5.mapper2.UserMapper2.findUserByRoleId\" />\n   </resultMap>\n\n   <select id=\"getRole\" parameterType=\"long\" resultMap=\"roleMapper\">\n      select id, role_name, note from t_role where id = #{id}\n   </select>\n\n   <select id=\"findRoleByUserId\" parameterType=\"long\" resultMap=\"roleMapper\">\n      select r.id, r.role_name, r.note from t_role r, t_user_role ur\n      where r.id = ur.role_id and ur.user_id = #{userId}\n   </select>\n</mapper>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.ssm.learn.chapter5.mapper2.UserMapper2\">\n   <resultMap type=\"com.ssm.learn.chapter5.pojo2.User2\" id=\"userMapper\">\n      <id column=\"id\" property=\"id\" />\n      <result column=\"user_name\" property=\"userName\" />\n      <result column=\"real_name\" property=\"realName\" />\n      <result column=\"sex\" property=\"sex\"\n         typeHandler=\"com.ssm.learn.chapter5.typeHandler.SexTypeHandler\" />\n      <result column=\"mobile\" property=\"moble\" />\n      <result column=\"email\" property=\"email\" />\n      <result column=\"position\" property=\"position\" />\n      <result column=\"note\" property=\"note\" />\n      <collection property=\"roleList\" column=\"id\" fetchType=\"lazy\"\n         select=\"com.ssm.learn.chapter5.mapper2.RoleMapper2.findRoleByUserId\" />\n   </resultMap>\n   <select id=\"getUser\" parameterType=\"long\" resultMap=\"userMapper\">\n      select id, user_name, real_name, sex, moble, email, note from t_user where\n      id =#{id}\n   </select>\n   <select id=\"findUserByRoleId\" parameterType=\"long\" resultMap=\"userMapper\">\n      select u.id, u.user_name, u.real_name, u.sex, u.moble, u.email, u.note\n      from\n      t_user u , t_user_role ur where u.id = ur.user_id and ur.role_id =#{roleId}\n   </select>\n</mapper>\n```\n\n这里都使用了collection去关联，但是把fetchType都设置为lazy，启用延时加载。\n\n测试代码如下：\n\n```java\n@Test\npublic void test10(){\n    SqlSession sqlSession=null;\n    try{\n        sqlSession=SqlSessionFactoryUtils.openSqlSession();\n        RoleMapper2 roleMapper2 = sqlSession.getMapper(RoleMapper2.class);\n        Role2 role = roleMapper2.getRole(1L);\n        role.getUserList();\n        UserMapper2 userMapper2 = sqlSession.getMapper(UserMapper2.class);\n        User2 user = userMapper2.getUser(1L);\n    }catch (Exception e){\n        e.printStackTrace();\n    }finally {\n        if(sqlSession!=null){\n            sqlSession.close();\n        }\n    }\n}\n```\n\n运行程序可以看到执行了3条SQL，因为调用getUserList所以才有了第二条SQL。\n\n## 5.9	缓存\n\n在MyBatis中允许使用缓存，把那些常用且命中率高的数据缓存起来，能够有效提高系统性能。\n\nMyBatis分为一级缓存和二级缓存，同时可以配置关于缓存的设置。\n\n### 5.9.1	一级缓存和二级缓存\n\n一级缓存是在SqlSession上的缓存，默认自动开启。二级缓存是在SqlSessionFactory上的缓存。\n\n没有任何配置的环境测试一级缓存，代码如下所示：\n\n```java\n@Test\npublic void testFirstLevelCache() {\n    SqlSession sqlSession = null;\n    try {\n        sqlSession = SqlSessionFactoryUtils.openSqlSession();\n        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n        Role role = roleMapper.getRole(1L);\n        logger.info(\"再获取一次POJO......\");\n        Role role2 = roleMapper.getRole(1L);\n    } catch (Exception e) {\n        logger.info(e.getMessage(), e);\n    } finally {\n        if (sqlSession != null) {\n            sqlSession.close();\n        }\n    }\n}\n```\n\n运行代码，得到如下日志：\n\n```markdown\nDEBUG 2020-02-25 16:42:22,848 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==>  Preparing: select id,role_name as roleName,note from t_role where id = ?; \nDEBUG 2020-02-25 16:42:22,883 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==> Parameters: 1(Long)\nDEBUG 2020-02-25 16:42:22,899 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: <==      Total: 1\n INFO 2020-02-25 16:42:22,899 com.ssm.learn.chapter5.test.MyTest: 再获取一次POJO......\nDEBUG 2020-02-25 16:42:22,900 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@63440df3]\n```\n\n可以看到虽然对同一个对象进行了两次获取，但是实际上只有一条SQL被执行，其原因是代码使用了同一个SqlSession对象获取数据。当一个SqlSession第一次通过SQL和参数获取对象后就会将它缓存起来，如果下次的SQL和参数没有发生变化，并且缓存没有超时或者声明需要刷新时，它就会从缓存中获取数据，而不是通过SQL获取了。修改代码，如下所示：\n\n```java\n@Test\npublic void testFirstLevelCache() {\n    SqlSession sqlSession = null;\n    SqlSession sqlSession2 = null;\n    try {\n        sqlSession = SqlSessionFactoryUtils.openSqlSession();\n        sqlSession2 = SqlSessionFactoryUtils.openSqlSession();\n        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n        Role role = roleMapper.getRole(1L);\n        //需要提交，如果是一级缓存，MyBatis才会缓存对象到SqlSessionFactory层面\n        sqlSession.commit();\n        logger.info(\"不同sqlSession再获取一次POJO......\");\n        RoleMapper roleMapper2 = sqlSession2.getMapper(RoleMapper.class);\n        Role role2 = roleMapper2.getRole(1L);\n        //需要提交，如果是一级缓存，MyBatis才会缓存对象到SqlSessionFactory层面\n    } catch (Exception e) {\n        logger.info(e.getMessage(), e);\n    } finally {\n        if (sqlSession != null) {\n            sqlSession.close();\n        }\n        if (sqlSession2 != null) {\n            sqlSession2.close();\n        }\n    }\n}\n```\n\n运行代码，得到以下日志：\n\n```markdown\nDEBUG 2020-02-25 16:55:56,004 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==>  Preparing: select id,role_name as roleName,note from t_role where id = ?; \nDEBUG 2020-02-25 16:55:56,039 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==> Parameters: 1(Long)\nDEBUG 2020-02-25 16:55:56,056 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: <==      Total: 1\n INFO 2020-02-25 16:55:56,057 com.ssm.learn.chapter5.test.MyTest: 不同sqlSession再获取一次POJO......\nDEBUG 2020-02-25 16:55:56,057 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Opening JDBC Connection\nDEBUG 2020-02-25 16:55:56,062 org.apache.ibatis.datasource.pooled.PooledDataSource: Created connection 1956710488.\nDEBUG 2020-02-25 16:55:56,062 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@74a10858]\nDEBUG 2020-02-25 16:55:56,063 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==>  Preparing: select id,role_name as roleName,note from t_role where id = ?; \n```\n\n可以看到SQL被执行了两次，这说明一级缓存是在SqlSession层面的，对于不同的SqlSession对象是不能共享的。为了是SqlSession对象之间共享相同的缓存，有时候需要开启二级缓存，只需要在映射文件上加入代码：\n\n```xml\n<cache/>\n```\n\n这个时候MyBatis会序列化和反序列化对应的POJO，也就要求POJO是一个可序列化的对象，那么它就必须实现Serializable接口。代码如下所示：\n\n```java\npublic class Role implements Serializable {\n	...\n}\n```\n\n再次运行代码，得到以下日志：\n\n```markdown\nDEBUG 2020-02-25 17:02:39,248 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==>  Preparing: select id,role_name as roleName,note from t_role where id = ?; \nDEBUG 2020-02-25 17:02:39,281 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==> Parameters: 1(Long)\nDEBUG 2020-02-25 17:02:39,297 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: <==      Total: 1\n INFO 2020-02-25 17:02:39,309 com.ssm.learn.chapter5.test.MyTest: 不同sqlSession再获取一次POJO......\nDEBUG 2020-02-25 17:02:39,367 org.apache.ibatis.cache.decorators.LoggingCache: Cache Hit Ratio [com.ssm.learn.chapter5.mapper.RoleMapper]: 0.5\nDEBUG 2020-02-25 17:02:39,367 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@462d5aee]\n```\n\n可以看到不同的SqlSession在获取同一条记录，只发送了一条SQL。因为这个时候MyBatis将其保存在SqlSessionFactory层面。\n\n', 'http://cdn.alanliang.site/note/oilpainting5.jpg', 1, 1, 0, 0, b'0', b'1', b'1', b'1', b'1', 5, 3, 1, 2, '2020-06-15 11:08:33', '2020-06-15 11:43:59');
INSERT INTO `t_article` VALUES (6, '动态SQL', 'JavaEE互联网轻量级框架整合开发第六章', '<p>MyBatis提供对SQL语句动态的组装能力，使用XML的几个简单元素，便能完成动态SQL的功能。体现了MyBatis灵活、高度可配置性和可维护性。</p>\n<h2 id=\"h2-6-1-\"><a name=\"6.1    概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1    概述</h2><p>MyBatis的动态SQL包括以下几种元素：</p>\n<table>\n<thead>\n<tr>\n<th>元素</th>\n<th>作用</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if</td>\n<td>判断语句</td>\n<td>单条件分支判断</td>\n</tr>\n<tr>\n<td>choose(when, otherwise)</td>\n<td>相当于Java中的switch语句</td>\n<td>多条件分支判断</td>\n</tr>\n<tr>\n<td>trim(when, set)</td>\n<td>辅助元素，用于处理特定的SQL拼装问题，比如去掉多用的and, or等</td>\n<td>用于处理SQL拼装的问题</td>\n</tr>\n<tr>\n<td>foreach</td>\n<td>循环语句</td>\n<td>在in语句等列举条件常用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-6-2-if-\"><a name=\"6.2    if元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2    if元素</h2><p>if元素是最常用的判断语句，相当于Java中的if语句，它常常与test属性联合使用。</p>\n<p>例如，根据角色名称（roleName）去查找角色，但是角色名称是一个选填条件，不填写时，就不要用它作为条件查询。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    select role_no, role_name, note from t_role where 1=1\n    &lt;if test=&quot;roleName != null and roleName != &#39;&#39;&quot;&gt;\n        and role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n    &lt;/if&gt;\n&lt;/select&gt;\n</code></pre>\n<p>当映射器接收roleName后，如果参数不为空，则构造对roleName的模糊查询，否则就不要去构造这个条件。</p>\n<h2 id=\"h2-6-3-choose-when-otherwise-\"><a name=\"6.3    choose、when、otherwise元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3    choose、when、otherwise元素</h2><p>choose…when…otherwise语句相当于Java中的switch…case…default语句。</p>\n<p>例如，有这样一个场景：</p>\n<ul>\n<li>如果角色编号（roleNo）不为空，则只用角色编号作为条件查询；</li><li>当角色编号为空，而角色名称不为空，则用角色名称作为条件进行模糊查询；</li><li>当角色编号和角色名称都为空，则要求角色备注不为空。</li></ul>\n<p>代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRoles2&quot; parameterType=&quot;role&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    select role_no, role_name, note from t_role where 1=1\n    &lt;choose&gt;\n        &lt;when test=&quot;roleNo != null and roleNo !=&#39;&#39;&quot;&gt;\n            and role_no = #{roleNo}\n        &lt;/when&gt;\n        &lt;when test=&quot;roleName != null and roleName != &#39;&#39;&quot;&gt;\n            and role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n        &lt;/when&gt;\n        &lt;otherwise&gt;\n            and note is not null\n        &lt;/otherwise&gt;\n    &lt;/choose&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"h2-6-4-trim-where-set-\"><a name=\"6.4    trim、where、set元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.4    trim、where、set元素</h2><p>以前的动态SQL语句加入条件“1=1”是为了防止出现SQL语句异常，如果不加入这个条件，就会变成这样一个错误语句：</p>\n<pre><code class=\"lang-sql\">select role_no, role_name, note from t_role where and role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n</code></pre>\n<p>加入这个这个条件显得相当奇怪，我们可以用where元素去处理SQL以达到预期效果，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRoles3&quot; parameterType=&quot;role&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    select role_no, role_name, note from t_role where 1=1\n    &lt;where&gt;\n        &lt;if test=&quot;roleName != null and roleName != &#39;&#39;&quot;&gt;\n            and role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n        &lt;/if&gt;\n        &lt;if test=&quot;note != null and note !=&#39;&#39;&quot;&gt;\n            and note like concat(&#39;%&#39;,#{note},&#39;%&#39;)\n        &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<p>有时候要去掉的是一些特殊的SQL语法，比如常见的and、or。而使用trim元素也可以达到预期效果。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRoles4&quot; parameterType=&quot;role&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    select role_no, role_name, note from t_role\n    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;\n        &lt;if test=&quot;roleName != null and roleName != &#39;&#39;&quot;&gt;\n            and role_name like concat(&#39;%&#39;,#{roleName},&#39;%&#39;)\n        &lt;/if&gt;\n    &lt;/trim&gt;\n&lt;/select&gt;\n</code></pre>\n<p>其中，perfix代表的是语句的前缀，而prefixOverrides代表的是需要去掉那种字符串。基本与where是等效的。</p>\n<p>在Hibernate中要发送所有字段更新持久对象，但现实中场景是只想更新某一个字段，这样会浪费网络带宽，更好的办法就是把主键和更新字段的值传递给SQL去更新。但一个个字段更新需要多条SQL语句，Hibernate中发送所有字段避免了这样的问题。而在MyBatis中，常常可以使用set元素来避免这样的问题，例如更新一个角色的数据，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;update id=&quot;updateRole&quot; parameterType=&quot;role&quot;&gt;\n    update t_role \n    &lt;set&gt;\n        &lt;if test=&quot;roleName != null and roleName != &#39;&#39;&quot;&gt;\n            role_name = #{roleName},\n        &lt;/if&gt;\n        &lt;if test=&quot;note != null and note != &#39;&#39;&quot;&gt;\n            note = #{note}\n        &lt;/if&gt;\n    &lt;/set&gt;\n    where role_no = #{roleNo}\n&lt;/update&gt;\n</code></pre>\n<p>set元素遇到了逗号，会把对应的逗号去掉。当我们只需要更新备注时，我们只需要传递备注信息和角色编号即可，而不需要传递角色名称。MyBatis就会根据参数的规则进行动态SQL组装，这样便能避免全部字段更新的问题。</p>\n<h2 id=\"h2-6-5-foreach-\"><a name=\"6.5    foreach元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.5    foreach元素</h2><p>foreach元素是一个循环语句，它的作用是遍历集合，它能很好地支持数组和List、Set接口的集合，往往用于SQL中的in关键字。</p>\n<p>在数据库中，经常需要根据编号找到对应的数据，比如角色。有一个List\\&lt;String\\&gt;的角色编号的集合roleNoList，可以使用foreach元素找到这个集合中的角色的详细信息，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRolesByRoleNoList&quot; resultType=&quot;role&quot;&gt;\n    select * from t_role where role_no in\n    &lt;foreach item=&quot;roleNo&quot; index=&quot;index&quot; collection=&quot;roleNoList&quot;\n             open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;\n        #{roleNo}\n    &lt;/foreach&gt;\n&lt;/select&gt;\n</code></pre>\n<ul>\n<li>collection属性的值是接收的参数名称，它可以是一个数组、List、Set等集合；</li><li>item属性的值是遍历中当前的元素；</li><li>index属性的值是当前元素的位置下标；</li><li>open和close属性的值是以什么符号将这些集合包装起来；</li><li>separator属性的值是各个元素的间隔符号。</li></ul>\n<p>需要注意的是，大量数据的in语句会消耗大量性能，此外一些数据库对SQL语句长度有限制，所以使用前要预估collection对象的长度。</p>\n<h2 id=\"h2-6-6-test-\"><a name=\"6.6    用test属性判断字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.6    用test属性判断字符串</h2><p>test的作用相当于判断真假，可以判断空和非空，也可以判断字符串、数字和枚举等。对以下代码进行测试：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;getRoleTest&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    select role_no, role_name, note from t_role\n    &lt;if test=&quot; type == &#39;Y&#39;.toString()&quot;&gt;\n        where 1=1\n    &lt;/if&gt;\n&lt;/select&gt;\n</code></pre>\n<p>如果把type =‘Y’传递给SQL，就可以发现MyBatis加入了条件“where 1=1”。所以对于字符串的判断，可以通过加入toString()的方法进行比较。它可以判断数值型的参数。对于枚举而言，取决于使用何种typeHandler。</p>\n<h2 id=\"h2-6-7-bind-\"><a name=\"6.7    bind元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.7    bind元素</h2><p>bind元素的作用是通过OGNL表达式去自定义一个上下文变量。在进行模糊查询时，如果是MySQL数据库，常常这样使用：<code>concat（‘%’,参数,’%‘）</code>。而如果是Oracle数据库，常常这样使用：<code>%||参数||%</code>。但是有了bind元素就不必使用特定数据库的语法了，而是使用MyBatis的动态SQL即可完成。</p>\n<p>例如，要按角色名称进行模糊查询，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRole&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + _parameter + &#39;%&#39;&quot;/&gt;\n    select role_no, role_name, note from t_role\n    where role_name like #{pattern}\n&lt;/select&gt;\n</code></pre>\n<p>这里的“_parameter”是传递进来的参数。这样无论是MySQL还是Oracle都可以使用这样的语句，提高了代码的可移植性。</p>\n<p>同时，传递多个参数也是没问题的。代码如下所示：</p>\n<pre><code class=\"lang-java\">public List&lt;Role&gt; findRole(@Param(&quot;roleName&quot;)String roleName, \n                           @Param(&quot;note&quot;)String note);\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;findRole&quot; resultMap=&quot;roleResultMap&quot;&gt;\n    &lt;bind name=&quot;pattern_roleName&quot; value=&quot;&#39;%&#39; + roleName + &#39;%&#39;&quot;/&gt;\n    &lt;bind name=&quot;pattern_note&quot; value=&quot;&#39;%&#39; + note + &#39;%&#39;&quot;/&gt;\n    select role_no, role_name, note from t_role\n    where role_name like #{pattern_roleName}\n    and note like #{pattern_note}\n&lt;/select&gt;\n</code></pre>\n<p>这里绑定了两个新变量pattern_roleName和pattern_note，这样就可以在SQL的其他地方使用了。</p>\n', 'MyBatis提供对SQL语句动态的组装能力，使用XML的几个简单元素，便能完成动态SQL的功能。体现了MyBatis灵活、高度可配置性和可维护性。\n\n## 6.1	概述\n\nMyBatis的动态SQL包括以下几种元素：\n\n| 元素                    | 作用                                                         | 备注                   |\n| ----------------------- | ------------------------------------------------------------ | ---------------------- |\n| if                      | 判断语句                                                     | 单条件分支判断         |\n| choose(when, otherwise) | 相当于Java中的switch语句                                     | 多条件分支判断         |\n| trim(when, set)         | 辅助元素，用于处理特定的SQL拼装问题，比如去掉多用的and, or等 | 用于处理SQL拼装的问题  |\n| foreach                 | 循环语句                                                     | 在in语句等列举条件常用 |\n\n## 6.2	if元素\n\nif元素是最常用的判断语句，相当于Java中的if语句，它常常与test属性联合使用。\n\n例如，根据角色名称（roleName）去查找角色，但是角色名称是一个选填条件，不填写时，就不要用它作为条件查询。代码如下所示：\n\n```xml\n<select id=\"findRoles\" parameterType=\"string\" resultMap=\"roleResultMap\">\n    select role_no, role_name, note from t_role where 1=1\n    <if test=\"roleName != null and roleName != \'\'\">\n        and role_name like concat(\'%\',#{roleName},\'%\')\n    </if>\n</select>\n```\n\n当映射器接收roleName后，如果参数不为空，则构造对roleName的模糊查询，否则就不要去构造这个条件。\n\n## 6.3	choose、when、otherwise元素\n\nchoose...when...otherwise语句相当于Java中的switch...case...default语句。\n\n例如，有这样一个场景：\n\n- 如果角色编号（roleNo）不为空，则只用角色编号作为条件查询；\n- 当角色编号为空，而角色名称不为空，则用角色名称作为条件进行模糊查询；\n- 当角色编号和角色名称都为空，则要求角色备注不为空。\n\n代码如下所示：\n\n```xml\n<select id=\"findRoles2\" parameterType=\"role\" resultMap=\"roleResultMap\">\n    select role_no, role_name, note from t_role where 1=1\n    <choose>\n        <when test=\"roleNo != null and roleNo !=\'\'\">\n            and role_no = #{roleNo}\n        </when>\n        <when test=\"roleName != null and roleName != \'\'\">\n            and role_name like concat(\'%\',#{roleName},\'%\')\n        </when>\n        <otherwise>\n            and note is not null\n        </otherwise>\n    </choose>\n</select>\n```\n\n## 6.4	trim、where、set元素\n\n以前的动态SQL语句加入条件“1=1”是为了防止出现SQL语句异常，如果不加入这个条件，就会变成这样一个错误语句：\n\n```sql\nselect role_no, role_name, note from t_role where and role_name like concat(\'%\',#{roleName},\'%\')\n```\n\n加入这个这个条件显得相当奇怪，我们可以用where元素去处理SQL以达到预期效果，代码如下所示：\n\n```xml\n<select id=\"findRoles3\" parameterType=\"role\" resultMap=\"roleResultMap\">\n    select role_no, role_name, note from t_role where 1=1\n    <where>\n        <if test=\"roleName != null and roleName != \'\'\">\n            and role_name like concat(\'%\',#{roleName},\'%\')\n        </if>\n        <if test=\"note != null and note !=\'\'\">\n            and note like concat(\'%\',#{note},\'%\')\n        </if>\n    </where>\n</select>\n```\n\n\n\n有时候要去掉的是一些特殊的SQL语法，比如常见的and、or。而使用trim元素也可以达到预期效果。代码如下所示：\n\n```xml\n<select id=\"findRoles4\" parameterType=\"role\" resultMap=\"roleResultMap\">\n    select role_no, role_name, note from t_role\n    <trim prefix=\"where\" prefixOverrides=\"and\">\n        <if test=\"roleName != null and roleName != \'\'\">\n            and role_name like concat(\'%\',#{roleName},\'%\')\n        </if>\n    </trim>\n</select>\n```\n\n其中，perfix代表的是语句的前缀，而prefixOverrides代表的是需要去掉那种字符串。基本与where是等效的。\n\n在Hibernate中要发送所有字段更新持久对象，但现实中场景是只想更新某一个字段，这样会浪费网络带宽，更好的办法就是把主键和更新字段的值传递给SQL去更新。但一个个字段更新需要多条SQL语句，Hibernate中发送所有字段避免了这样的问题。而在MyBatis中，常常可以使用set元素来避免这样的问题，例如更新一个角色的数据，如下所示：\n\n```xml\n<update id=\"updateRole\" parameterType=\"role\">\n    update t_role \n    <set>\n        <if test=\"roleName != null and roleName != \'\'\">\n            role_name = #{roleName},\n        </if>\n        <if test=\"note != null and note != \'\'\">\n            note = #{note}\n        </if>\n    </set>\n    where role_no = #{roleNo}\n</update>\n```\n\nset元素遇到了逗号，会把对应的逗号去掉。当我们只需要更新备注时，我们只需要传递备注信息和角色编号即可，而不需要传递角色名称。MyBatis就会根据参数的规则进行动态SQL组装，这样便能避免全部字段更新的问题。\n\n## 6.5	foreach元素\n\nforeach元素是一个循环语句，它的作用是遍历集合，它能很好地支持数组和List、Set接口的集合，往往用于SQL中的in关键字。\n\n在数据库中，经常需要根据编号找到对应的数据，比如角色。有一个List\\<String\\>的角色编号的集合roleNoList，可以使用foreach元素找到这个集合中的角色的详细信息，代码如下所示：\n\n```xml\n<select id=\"findRolesByRoleNoList\" resultType=\"role\">\n    select * from t_role where role_no in\n    <foreach item=\"roleNo\" index=\"index\" collection=\"roleNoList\"\n             open=\"(\" separator=\",\" close=\")\">\n        #{roleNo}\n    </foreach>\n</select>\n```\n\n- collection属性的值是接收的参数名称，它可以是一个数组、List、Set等集合；\n- item属性的值是遍历中当前的元素；\n- index属性的值是当前元素的位置下标；\n- open和close属性的值是以什么符号将这些集合包装起来；\n- separator属性的值是各个元素的间隔符号。\n\n需要注意的是，大量数据的in语句会消耗大量性能，此外一些数据库对SQL语句长度有限制，所以使用前要预估collection对象的长度。\n\n## 6.6	用test属性判断字符串\n\ntest的作用相当于判断真假，可以判断空和非空，也可以判断字符串、数字和枚举等。对以下代码进行测试：\n\n```xml\n<select id=\"getRoleTest\" parameterType=\"string\" resultMap=\"roleResultMap\">\n    select role_no, role_name, note from t_role\n    <if test=\" type == \'Y\'.toString()\">\n        where 1=1\n    </if>\n</select>\n```\n\n如果把type =‘Y’传递给SQL，就可以发现MyBatis加入了条件“where 1=1”。所以对于字符串的判断，可以通过加入toString()的方法进行比较。它可以判断数值型的参数。对于枚举而言，取决于使用何种typeHandler。\n\n## 6.7	bind元素\n\nbind元素的作用是通过OGNL表达式去自定义一个上下文变量。在进行模糊查询时，如果是MySQL数据库，常常这样使用：`concat（‘%’,参数,’%‘）`。而如果是Oracle数据库，常常这样使用：`%||参数||%`。但是有了bind元素就不必使用特定数据库的语法了，而是使用MyBatis的动态SQL即可完成。\n\n例如，要按角色名称进行模糊查询，代码如下所示：\n\n```xml\n<select id=\"findRole\" parameterType=\"string\" resultMap=\"roleResultMap\">\n    <bind name=\"pattern\" value=\"\'%\' + _parameter + \'%\'\"/>\n    select role_no, role_name, note from t_role\n    where role_name like #{pattern}\n</select>\n```\n\n这里的“_parameter”是传递进来的参数。这样无论是MySQL还是Oracle都可以使用这样的语句，提高了代码的可移植性。\n\n同时，传递多个参数也是没问题的。代码如下所示：\n\n```java\npublic List<Role> findRole(@Param(\"roleName\")String roleName, \n                           @Param(\"note\")String note);\n```\n\n```xml\n<select id=\"findRole\" resultMap=\"roleResultMap\">\n    <bind name=\"pattern_roleName\" value=\"\'%\' + roleName + \'%\'\"/>\n    <bind name=\"pattern_note\" value=\"\'%\' + note + \'%\'\"/>\n    select role_no, role_name, note from t_role\n    where role_name like #{pattern_roleName}\n    and note like #{pattern_note}\n</select>\n```\n\n这里绑定了两个新变量pattern_roleName和pattern_note，这样就可以在SQL的其他地方使用了。\n\n', 'http://cdn.alanliang.site/note/oilpainting6.jpg', 1, 0, 0, 0, b'0', b'1', b'0', b'0', b'1', 2, 3, 1, 2, '2020-06-15 11:22:20', '2020-06-15 11:22:20');
INSERT INTO `t_article` VALUES (7, '装配Bean', 'JavaEE互联网轻量级框架整合开发第十章', '<h2 id=\"h2-10-1-3-\"><a name=\"10.1    依赖注入的3种方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.1    依赖注入的3种方式</h2><p>在实际环境中实现IoC容器的方式主要分为两大类，一类是依赖查找，依赖查找是通过资源定位查找对应资源；另一类是依赖注入，而Spring主要使用的是依赖注入。一般而言，依赖注入可以分为3种方式：</p>\n<ul>\n<li>构造器注入；</li><li>setter注入；</li><li>接口注入</li></ul>\n<p>构造器注入和setter注入是主要方式，而接口注入是从别的地方注入的方式，比如在Web工程中，往往是通过服务器（比如Tomcat）来配置数据源，这时可以用JNDI的形式通过接口将它注入Spring IoC容器中。</p>\n<h3 id=\"h3-10-1-1-\"><a name=\"10.1.1    构造器注入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.1.1    构造器注入</h3><p>在大部分情况下，我们都是通过类的构造方法来创建类的对象，Spring也可以采用反射的方式，通过使用构造方法来完成注入，这就是构造器注入的原理。我们以角色类为例，代码如下：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter9.pojo;\n\npublic class Role {\n    private Long id;\n    private String roleName;\n    private String note;\n\n       /*getter and setter*/\n\n    public Role(Long id, String roleName, String note) {\n        this.id = id;\n        this.roleName = roleName;\n        this.note = note;\n    }\n}\n</code></pre>\n<p>这时不能利用无参构造创建对象，为了使Spring能够正确创建对象，需要像这样做。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;role1&quot; class=&quot;com.ssm.chapter10.Role&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;\n    &lt;constructor-arg index=&quot;1&quot; value=&quot;总经理&quot;/&gt;\n    &lt;constructor-arg index=&quot;2&quot; value=&quot;公司管理者&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>constructor-arg元素用于定义类构造方法的参数，其中index用于定义参数位置（从0开始），而value则是设置值。通过这样定义Spring便知道使用Role(Long, String, String)这样的构造方法去创建对象了。</p>\n<p>这样注入虽然简单，但是如果参数很多，这样的构造方法就很复杂了，这时可以考虑使用setter注入。</p>\n<h3 id=\"h3-10-1-2-setter-\"><a name=\"10.1.2    setter注入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.1.2    setter注入</h3><p>setter注入是Spring中最常见的注入方法，利用JavaBean定义的setter方法完成注入，灵活且可读性高。首先可以把构造方法声明为无参数的，然后使用setter注入为其设置对应的值。先在Role类中添加无参构造，然后完成配置。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;role2&quot; class=&quot;com.ssm.chapter10.Role&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;\n    &lt;property name=&quot;roleName&quot; value=&quot;高级工程师&quot;/&gt;\n    &lt;property name=&quot;note&quot; value=&quot;重要人员&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<h3 id=\"h3-10-1-3-\"><a name=\"10.1.3    接口注入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.1.3    接口注入</h3><p>有时候资源来自于外界，比如数据库连接资源完全可以在Tomcat下配置，然后通过JNDI的方式获取，这时我们需要采用接口注入的形式获取它。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;Context&gt;\n    &lt;Resource name=&quot;jdbc/ssm&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/ssm&quot; username=&quot;root&quot; password=&quot;1234&quot; /&gt;\n&lt;/Context&gt;\n</code></pre>\n<p>如果Tomcat的Web工程使用了Spring，那么可以通过Spring的机制，用JNDI获取Tomcat启动的数据库连接池，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;\n    &lt;property name=&quot;jndiName&quot;&gt;\n        &lt;value&gt;java:comp/env/jdbc/ssm&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<h2 id=\"h2-10-2-bean-\"><a name=\"10.2    装配Bean概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.2    装配Bean概述</h2><p>在Spring中提供3种方法进行配置：</p>\n<ul>\n<li>在XML中显式配置；</li><li>在Java的接口和类中实现配置；</li><li>隐式Bean的发现机制和自动装配原则。</li></ul>\n<p>这3种方法在实际开发中被会被用到，使用优先级的建议如下：</p>\n<ol>\n<li>基于约定优于配置的原则，应该最优先使用通过隐式Bean的发现机制和自动装配的原则，这样简单灵活。</li><li>没有办法使用自动装配原则的情况下优先考虑Java接口和类中实现配置，这样可以避免XML配置的泛滥。这种场景典型的例子是一个父类有多个子类。比如学生类有两个子类：男学生类和女学生类，通过IoC容器初始化一个学生类，容器将不知道初始化哪个子类，这个时候可以使用Java的注解配置指定。</li><li>在上述方法都无法使用的情况下，那么只能选择XML配置。由于实际开发中常常使用第三方类库，我们无法修改源码，这是就可以通过XML配置。</li></ol>\n<p>总而言之，可以修改源码则优先使用自动装配，这样可以减少大量的XML配置。不能修改源码则使用XML配置。</p>\n<h2 id=\"h2-10-3-xml-bean\"><a name=\"10.3    通过XML配置装配Bean\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.3    通过XML配置装配Bean</h2><p>使用XML装配Bean需要定义对应的XML，这里需要引入对应的XML模式（XSD）文件，这些文件会定义配置Spring Bean的一些元素，一个简单的配置如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;\n   &lt;!--Spring Bean配置代码--&gt;\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"h3-10-3-1-\"><a name=\"10.3.1    装配简易值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.3.1    装配简易值</h3><p>一个简单的装配，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;role2&quot; class=&quot;com.ssm.chapter10.Role&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;\n    &lt;property name=&quot;roleName&quot; value=&quot;高级工程师&quot;/&gt;\n    &lt;property name=&quot;note&quot; value=&quot;重要人员&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<ul>\n<li><p>id属性是Spring寻找Bean的标识，但不是必需的属性，缺省时Spring将采用“全限定名#{number}”的格式生成标识。在这里，标识是“com.ssm.chapter9.pojo.Role#0”。第二次声明就是“com.ssm.chapter9.pojo.Role#1”。建议自定义id，比较简单。</p>\n</li><li><p>class属性是类的全限定名。</p>\n</li><li><p>property元素是注入类的属性，其中name属性是注入属性名称，value属性注入属性的值。如果需要注入一些自定义的类，比如之前的果汁制作器例子，需要先定义原料的Bean，然后在制作器中引用原料。代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;source&quot; class=&quot;com.ssm.chapter9.pojo.Source&quot;&gt;\n        &lt;property name=&quot;fruit&quot; value=&quot;橙汁&quot; /&gt;\n        &lt;property name=&quot;sugar&quot; value=&quot;少糖&quot; /&gt;\n        &lt;property name=&quot;size&quot; value=&quot;大杯&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;juiceMaker2&quot; class=&quot;com.ssm.chapter9.pojo.JuiceMaker2&quot;&gt;\n        &lt;property name=&quot;beverageShop&quot; value=&quot;贡茶&quot; /&gt;\n        &lt;property name=&quot;source&quot; ref=&quot;source&quot; /&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p>这里定义了一个id为source的Bean，然后在制作器中通过ref属性去引用对应的Bean。</p>\n</li></ul>\n<h3 id=\"h3-10-3-2-\"><a name=\"10.3.2    装配集合\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.3.2    装配集合</h3><p>有些时候要做一些复杂的装配工作，比如Set、Map、List、Array和Properties等。我们首先定义一个JavaBean，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.pojo;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class ComplexAssembly {\n\n   private Long id;\n   private List&lt;String&gt; list;\n   private Map&lt;String, String&gt; map;\n   private Properties props;\n   private Set&lt;String&gt; set;\n   private String[] array;\n\n   /*getter and setter*/\n}\n</code></pre>\n<p>装配这些常用的集合类，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;complexAssembly&quot; class=&quot;com.ssm.chapter10.pojo.ComplexAssembly&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;\n\n    &lt;property name=&quot;list&quot;&gt;\n        &lt;list&gt;\n            &lt;value&gt;value-list-1&lt;/value&gt;\n            &lt;value&gt;value-list-1&lt;/value&gt;\n            &lt;value&gt;value-list-1&lt;/value&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n\n    &lt;property name=&quot;map&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key=&quot;key1&quot; value=&quot;value-key-1&quot;/&gt;\n            &lt;entry key=&quot;key2&quot; value=&quot;value-key-2&quot;/&gt;\n            &lt;entry key=&quot;key3&quot; value=&quot;value-key-3&quot;/&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n\n    &lt;property name=&quot;props&quot;&gt;\n        &lt;props&gt;\n            &lt;prop key=&quot;prop1&quot;&gt;value-prop-1&lt;/prop&gt;\n            &lt;prop key=&quot;prop2&quot;&gt;value-prop-2&lt;/prop&gt;\n            &lt;prop key=&quot;prop3&quot;&gt;value-prop-3&lt;/prop&gt;\n        &lt;/props&gt;\n    &lt;/property&gt;\n\n    &lt;property name=&quot;set&quot;&gt;\n        &lt;set&gt;\n            &lt;value&gt;value-set-1&lt;/value&gt;\n            &lt;value&gt;value-set-2&lt;/value&gt;\n            &lt;value&gt;value-set-3&lt;/value&gt;\n        &lt;/set&gt;\n    &lt;/property&gt;\n\n    &lt;property name=&quot;array&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;value-array-1&lt;/value&gt;\n            &lt;value&gt;value-array-2&lt;/value&gt;\n            &lt;value&gt;value-array-3&lt;/value&gt;\n        &lt;/array&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<ul>\n<li><p>List集合属性使用\\&lt;list\\&gt;元素注入，\\&lt;value\\&gt;元素指定了该集合装配的值。</p>\n</li><li><p>Map集合属性使用\\&lt;map\\&gt;元素注入，\\&lt;entry\\&gt;元素指定了该集合装配的键值对，其中key属性为键值，value属性为对应的值。</p>\n</li><li>Properties集合属性使用\\&lt;props\\&gt;元素注入，\\&lt;prop\\&gt;元素指定了该集合装配的Property，其中key属性为键值，该元素包裹的值为设置的值。</li><li>Set集合属性使用\\&lt;set\\&gt;元素注入，\\&lt;value\\&gt;元素指定了该集合装配的值。</li><li>Array数组属性使用\\&lt;Array\\&gt;元素注入，\\&lt;value\\&gt;元素指定了该数组装配的值。</li></ul>\n<p>从上面可以看到各个集合对字符串的装载，但是有时需要更复杂的装载，比如这些集合中装载的是类对象。为此先创建2个POJO，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class Role {\n   private Long id;\n   private String roleName;\n   private String note;\n\n   /*getter and setter*/\n\n   public Role() {\n   }\n\n   public Role(Long id, String roleName, String note) {\n      this.id = id;\n      this.roleName = roleName;\n      this.note = note;\n   }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class User {\n   private Long id;\n   private String userName;\n   private String note;\n\n   /*getter and setter*/\n}\n</code></pre>\n<p>再创建一个稍微复杂的POJO，装配用户和角色类，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class UserRoleAssembly {\n\n   private Long id;\n   private List&lt;Role&gt; list;\n   private Map&lt;Role, User&gt; map;\n   private Set&lt;Role&gt; set;\n\n   /*getter and setter*/\n}\n</code></pre>\n<p>修改配置文件，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;role1&quot; class=&quot;com.ssm.chapter10.pojo.Role&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;\n    &lt;property name=&quot;roleName&quot; value=&quot;role_name_1&quot;/&gt;\n    &lt;property name=&quot;note&quot; value=&quot;role_note_1&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;role2&quot; class=&quot;com.ssm.chapter10.pojo.Role&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;\n    &lt;property name=&quot;roleName&quot; value=&quot;role_name_2&quot;/&gt;\n    &lt;property name=&quot;note&quot; value=&quot;role_note_2&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;user1&quot; class=&quot;com.ssm.chapter10.pojo.User&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;\n    &lt;property name=&quot;userName&quot; value=&quot;user_name_1&quot;/&gt;\n    &lt;property name=&quot;note&quot; value=&quot;user_note_1&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;user2&quot; class=&quot;com.ssm.chapter10.pojo.User&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;2&quot;/&gt;\n    &lt;property name=&quot;userName&quot; value=&quot;user_name_2&quot;/&gt;\n    &lt;property name=&quot;note&quot; value=&quot;user_note_2&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;userRoleAssembly&quot; class=&quot;com.ssm.chapter10.pojo.UserRoleAssembly&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;\n    &lt;property name=&quot;list&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;role1&quot;/&gt;\n            &lt;ref bean=&quot;role2&quot;/&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n\n    &lt;property name=&quot;map&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key-ref=&quot;role1&quot; value-ref=&quot;user1&quot;/&gt;\n            &lt;entry key-ref=&quot;role2&quot; value-ref=&quot;user2&quot;/&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n\n    &lt;property name=&quot;set&quot;&gt;\n        &lt;set&gt;\n            &lt;ref bean=&quot;role1&quot;/&gt;\n            &lt;ref bean=&quot;role2&quot;/&gt;\n        &lt;/set&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<ul>\n<li><p>List集合属性使用\\&lt;list\\&gt;元素注入，\\&lt;ref\\&gt;元素指定该集合装配的对象，bean属性引用已定义的Bean。</p>\n</li><li><p>Map集合属性使用\\&lt;map\\&gt;元素注入，\\&lt;entry\\&gt;元素指定该集合装配的键值对，key-ref属性引用已定义的Bean作为键值，value-ref属性引用已定义的Bean作为对应的值。</p>\n</li><li>Set集合属性使用\\&lt;set\\&gt;元素注入，\\&lt;ref\\&gt;元素指定该集合装配的对象，bean属性引用已定义的Bean。</li></ul>\n<h2 id=\"h2-10-4-bean\"><a name=\"10.4    通过注解装配Bean\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4    通过注解装配Bean</h2><p>使用注解可以减少XML的配置，注解功能更强大，既能实现XML的功能，也提供自动装配的功能。</p>\n<p>在Spring中，它提供了两种方式来让Spring IoC容器发现Bean。</p>\n<ul>\n<li>组件扫描：通过定义资源的方式，让Spring IoC容器扫描对应的包，从而把Bean装配进来。</li><li>自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。</li></ul>\n<p>通过组件扫描和自动装配，大部分工程都可以使用Java配置完成。但是不使用XML也存在一定弊端，比如系统存在多个公共配置（比如多个properties和XML文件），如果写在注解里，那么公共资源的配置就显得比较分散，不利于统一管理，这是使用XML更加明确一些。</p>\n<h3 id=\"h3-10-4-1-component-bean\"><a name=\"10.4.1    使用@Component装配Bean\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4.1    使用<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>装配Bean</h3><p>首先定义一个POJO。代码如下所示：</p>\n<pre><code class=\"lang-java\">@Component(value = &quot;role&quot;)\npublic class Role {\n   @Value(&quot;1&quot;)\n   private Long id;\n   @Value(&quot;role_name_1&quot;)\n   private String roleName;\n   @Value(&quot;role_note_1&quot;)\n   private String note;\n\n   /*getter and setter*/\n}\n</code></pre>\n<ul>\n<li>注解<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>表明Spring IoC容器会扫描这个类并生成Bean实例，而其中的value属性表明这个类在容器中的id，相当于XML方式定义的Bean的id属性。也可以简写成<code><a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>(&quot;role&quot;)</code>。甚至直接写成<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>，这样的话容器将为其生成默认id，其值为首字母小写的类名，这里是“role”。</li><li>注解<a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>表明为属性注入值。注入的时候Spring会为其转化类型。</li></ul>\n<p>此时容器还并不知道去哪里扫描对象，所有还需要使用一个Java Config来告诉它，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.pojo;\n\nimport org.springframework.context.annotation.ComponentScan;\n@ComponentScan\npublic class PojoConfig {\n}\n</code></pre>\n<ul>\n<li>包名和POJO保持一致。</li><li><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>表明扫描组件，默认扫描当前包的路径，POJO的包名和它保持一致才能扫描。</li></ul>\n<p>接下来就可以通过Spring定义好的Spring IoC容器的实现类——AnnotationConfigApplicationContext生成IoC容器了，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class AnnotationMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(PojoConfig.class);\n        Role role = ctx.getBean(Role.class);\n        System.out.println(role);\n    }\n}\n</code></pre>\n<p>很多时候我们只需要扫描特定的类而不是整一个包，下面我们解决这个问题。另外，<a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>只能注入简单值，注入对象可使用<a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>。</p>\n<p><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>有两个配置项，第一个是basePackages，可以配置一个Java包的数组，Spring会根据配置扫描对应的包和子包，装配配置好的Bean；第二个是basePackageClasses，可以配置多个类，Spring会根据配置的类所在的包，为包和子包进行扫描，装配对应配置的Bean。</p>\n<p>为了验证<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>的两个配置项，我们首先声明一个接口RoleService，代码如下所示：</p>\n<pre><code class=\"lang-java\">import com.ssm.chapter10.annotation.pojo.Role;\n\npublic interface RoleService {\n    public void printRoleInfo(Role role);\n}\n</code></pre>\n<p>然后，创建一个实现类，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.service.impl;\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RoleServiceImpl implements RoleService {\n    @Override\n    public void printRoleInfo(Role role) {\n        System.out.println(&quot;id = &quot;+role.getId());\n        System.out.println(&quot;roleName = &quot;+role.getRoleName());\n        System.out.println(&quot;note = &quot;+role.getNote());\n    }\n}\n</code></pre>\n<p>这里<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>表明它是一个Spring所需要的Bean，为了装配RoleServiceImpl和之前定义的Role，需要给<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>注解加上对应的配置，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.config;\nimport com.ssm.chapter10.annotation.service.impl.RoleServiceImpl;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Role;\n\n@ComponentScan(basePackageClasses = {Role.class, RoleServiceImpl.class})\n/*\n    @ComponentScan(basePackages = {&quot;com.ssm.chapter10.annotation.pojo&quot;,\n    &quot;com.ssm.chapter10.annotation.service&quot;})\n */\n/*\n    @ComponentScan(basePackages = {&quot;com.ssm.chapter10.annotation.pojo&quot;,\n    &quot;com.ssm.chapter10.annotation.service&quot;},\n    basePackageClasses = {Role.class, RoleServiceImpl.class})\n */\npublic class ApplicationConfig {\n}\n</code></pre>\n<ul>\n<li>3种方法可以采用任意1种。</li><li>每一次使用<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>定义对应的包，Spring就会生成一个对应的新的对象，也就是说配置的Bean会生成多个实例，这往往不是我们需要的。</li><li>在同一个<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>中即使重复定义相同的包或者存在其子包定义，也不会造成同一个Bean的多次扫描，而导致一次配置生成多个对象。</li></ul>\n<p>因此，建议不要采用多个<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>注解进行配置，优先使用basePackages，但在需要大量重构的工程中尽量不要使用，因为重构修改包名需要反复配置。</p>\n<p>测试上述两个配置，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class AnnotationMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);\n        Role role = context.getBean(Role.class);\n        RoleService roleService = context.getBean(RoleService.class);\n        roleService.printRoleInfo(role);\n        context.close();\n    }\n}\n</code></pre>\n<h3 id=\"h3-10-4-2-autowired\"><a name=\"10.4.2    自动装配——@Autowired\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4.2    自动装配——<a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a></h3><p>所谓自动装配技术是一种由Spring自己发现对应的Bean，自动完成装配工作的方式。只要在需要注入的地方加上注解<a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>，Spring就会根据类型寻找定义的Bean并且将其注入。</p>\n<p>下面开始测试自动装配，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.service;\n\npublic interface RoleService2 {\n    public void printRoleInfo();\n}\n</code></pre>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.service.impl;\n\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService2;\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class RoleServiceImpl2 implements RoleService2 {\n\n    @Autowired\n    private Role role;\n\n    @Override\n    public void printRoleInfo() {\n        System.out.println(&quot;id = &quot;+role.getId());\n        System.out.println(&quot;roleName = &quot;+role.getRoleName());\n        System.out.println(&quot;note = &quot;+role.getNote());\n    }\n}\n</code></pre>\n<p>这里的 <a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>注解，表示在Spring IoC容器定位所有的Bean后，这个字段需要按类型注入，这样容器就会寻找资源，然后将其注入。</p>\n<p>在默认情况下，容器认为必须找到对应的Bean来注入这个字段，如果寻找失败将会抛出异常。有时候这并不是一个真实的需求，比如日志有时可有可无，这时我们可以将<a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>注解的配置项required设置为false。这时如果容器找不到对应的类型，允许不注入，也不会抛出异常，但字段可能为空而导致空指针异常。在大部分情况下都不需要这样修改。</p>\n<p> <a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>注解除了可以配置在属性上，也可以配置在方法上，比较常见的是配置在Bean的setter方法上完成注入，代码如下所示：</p>\n<pre><code class=\"lang-java\">public class RoleServiceImpl2 implements RoleService2 {\n\n    private Role role;\n\n    @Autowired\n    public void setRole(Role role) {\n        this.role = role;\n    }\n}\n</code></pre>\n<h3 id=\"h3-10-4-3-primary-qulifier-\"><a name=\"10.4.3    自动装配的歧义性（@Primary和@Qulifier）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4.3    自动装配的歧义性（<a href=\"https://github.com/Primary\" title=\"&#64;Primary\" class=\"at-link\">@Primary</a>和<a href=\"https://github.com/Qulifier\" title=\"&#64;Qulifier\" class=\"at-link\">@Qulifier</a>）</h3><p><a href=\"https://github.com/AutoWire\" title=\"&#64;AutoWire\" class=\"at-link\">@AutoWire</a>的使用方式十分简单，但是有时候并不能使用，因为该方式按类型注入。比如当一个接口存在多个实现类时。重新定义一个新的接口RoleServiceImpl3，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.service.impl;\n\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService;\nimport org.springframework.stereotype.Component;\n\n@Component(&quot;roleService3&quot;)\npublic class RoleServiceImpl3 implements RoleService {\n    @Override\n    public void printRoleInfo(Role role) {\n        System.out.println(&quot;id = &quot;+role.getId());\n        System.out.println(&quot;roleName = &quot;+role.getRoleName());\n        System.out.println(&quot;note = &quot;+role.getNote());\n    }\n}\n</code></pre>\n<p>再创建一个RoleController类，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.controller;\n\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService;\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class RoleController {\n\n    @Autowired\n    private RoleService roleService;\n\n    public void printRole(Role role){\n        roleService.printRoleInfo(role);\n    }\n}\n</code></pre>\n<p>这里的属性roleService是一个RoleService接口类型。RoleService有两个实现类，分别是RoleServiceImpl1和RoleServiceImpl3，这时容器无法判断注入哪个对象，于是就会抛出异常。</p>\n<p>因此按类型注入对象可能会因为存在多个该类型的Bean而导致注入失败。回想Spring IoC最底层容器接口——BeanFactory的定义，它存在一个通过类型获取Bean的方法：</p>\n<pre><code class=\"lang-java\">&lt;T&gt; T getBean(Class&lt;T&gt; requireType) throws BeanException;\n</code></pre>\n<p>通过RoleService.class作为参数就无法判断使用哪个类实例进行返回，这就是自动装配的歧义性。</p>\n<p>为了消除歧义性，Spring提供了两个<a href=\"https://github.com/Primary\" title=\"&#64;Primary\" class=\"at-link\">@Primary</a>和<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>。</p>\n<h4 id=\"h4-1-primary\"><a name=\"1、注解@Primary\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、注解<a href=\"https://github.com/Primary\" title=\"&#64;Primary\" class=\"at-link\">@Primary</a></h4><p>注解<a href=\"https://github.com/Primary\" title=\"&#64;Primary\" class=\"at-link\">@Primary</a>代表首要的，当Spring IoC通过一个接口或者抽象类注入对象的时候，由于存在多个实现类或者具体类，容器不清楚注入哪个类。注解<a href=\"https://github.com/Primary\" title=\"&#64;Primary\" class=\"at-link\">@Primary</a>则是告诉容器，优先使用该类注入。代码如下所示：</p>\n<pre><code class=\"lang-java\">@Component(&quot;roleService3&quot;)\n@primary\npublic class RoleServiceImpl3 implements RoleService {\n    @Override\n    public void printRoleInfo(Role role) {\n        System.out.println(&quot;id = &quot;+role.getId());\n        System.out.println(&quot;roleName = &quot;+role.getRoleName());\n        System.out.println(&quot;note = &quot;+role.getNote());\n    }\n}\n</code></pre>\n<p>这里的<a href=\"https://github.com/primary\" title=\"&#64;primary\" class=\"at-link\">@primary</a>注解告诉容器，如果存在多个RoleService类型，无法判断注入哪个的时候，优先将RoleServiceImpl3的实例注入，这样就可以消除歧义性了。</p>\n<h4 id=\"h4-2-qualifier\"><a name=\"2、注解@Qualifier\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、注解<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a></h4><p>除了按类型查找Bean，Spring IoC容器最底层的接口BeanFactory也定义了按名称查找的方法，这样便能消除歧义性，而<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>就是这样的一个注解。</p>\n<pre><code class=\"lang-java\">public class RoleController {\n\n    @Autowired\n    @Qualifier(&quot;roleService3&quot;)\n    private RoleService roleService;\n\n    public void printRole(Role role){\n        roleService.printRoleInfo(role);\n    }\n}\n</code></pre>\n<p>这时容器就不会按照类型的方式注入，而是按照名称的方式注入，这样既能注入成功，也不存在歧义性。BeanFactory定义的方法如下：</p>\n<pre><code class=\"lang-java\">Object getBean(String name) throws BeanException;\n</code></pre>\n<h3 id=\"h3-10-4-4-\"><a name=\"10.4.4    装载有参构造方法类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4.4    装载有参构造方法类</h3><p>Role类的构造方法都是没带参数的，而事实上在某些时候构造方法是带参数的，对于一些带有参数的构造方法，也允许我们通过注解注入，比如有时RoleController的构造方法如下所示：</p>\n<pre><code class=\"lang-java\">@Component\npublic class RoleController2 {\n    private RoleService roleService;\n\n    public RoleController2(RoleService roleService) {\n        this.roleService = roleService;\n    }\n    ...\n}\n</code></pre>\n<p>我们仍然可以使用<a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>或者<a href=\"https://github.com/Qualifier\" title=\"&#64;Qualifier\" class=\"at-link\">@Qualifier</a>进行注入，换句话说，这两个注解还能支持到参数。代码如下所示：</p>\n<pre><code class=\"lang-java\">public RoleController2(@Autowired RoleService roleService) {\n    this.roleService = roleService;\n}\n</code></pre>\n<h3 id=\"h3-10-4-5-bean-bean\"><a name=\"10.4.5    使用@Bean装配Bean\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4.5    使用<a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a>装配Bean</h3><p>之前都是通过<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>装配Bean，但是<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>只能注解在类上，不能注解到方法上，但是很多时候我们并不能修改源码。这时可以使用<a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a>，它可以注解到方法上，并将方法返回的对象作为Spring的Bean，存放在容器中。比如我们需要使用DBCP数据源，这时要引入关于它的包，然后来装配数据源的Bean。代码如下所示：</p>\n<pre><code class=\"lang-java\">@Bean(name = &quot;dataSource&quot;)\npublic DataSource getDataSource() {\n    Properties properties = new Properties();\n    properties.setProperty(&quot;driver&quot;, &quot;com.mysql.jdbc.Driver&quot;);\n    properties.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/ssm_learn&quot;);\n    properties.setProperty(&quot;username&quot;, &quot;root&quot;);\n    properties.setProperty(&quot;password&quot;, &quot;1234&quot;);\n    DataSource dataSource = null;\n    try {\n        dataSource = BasicDataSourceFactory.createDataSource(properties);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return dataSource;\n}\n</code></pre>\n<p>和其他Bean一样，它也可以通过<a href=\"https://github.com/Autowired\" title=\"&#64;Autowired\" class=\"at-link\">@Autowired</a>或者Qualifier等注解注入到其它Bean中。</p>\n<h2 id=\"h2-10-5-\"><a name=\"10.5    装配的混合使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.5    装配的混合使用</h2><p>在实际中，使用XML或者注解各有道理，建议在自己的工程中尽量使用注解方式，因为使用简单，而对于引入第三方包或者服务的类，尽量使用XML方式，这样的好处是可以尽量对第三方包或者服务的细节减少理解。</p>\n<p>如上述代码的注入方式就存在弊端，我们通过XML方式实现，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;\n    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm_learn&quot;/&gt;\n    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n    &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>显然我们不需要去了解第三方包的更多细节，也不需要过多的Java代码，相对于<a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a>的注入会更好一些。</p>\n<p>新建一个XML文件，命名为spring-dataSource.xml，添加上述代码。我们需要通过引用它到注解的体系中，而注解的体系则需要完成对角色编号（id）为1的查询功能。</p>\n<p>首先，使用注解<a href=\"https://github.com/importResource\" title=\"&#64;importResource\" class=\"at-link\">@importResource</a>，引入spring-dataSource.xml所定义的内容，代码如下所示：</p>\n<pre><code class=\"lang-java\">@ComponentScan(basePackages = {&quot;com.ssm.chapter10.annotation&quot;})\n@ImportResource({&quot;classpath:spring-dataSource.xml&quot;})\npublic class ApplicationConfig {\n}\n</code></pre>\n<p>这时我们就可以通过<a href=\"https://github.com/AutoWired\" title=\"&#64;AutoWired\" class=\"at-link\">@AutoWired</a>注入实现对数据库连接池的注入了，比如定义一个查询角色的接口——RoleDataSourceService，代码如下所示：</p>\n<pre><code class=\"lang-java\">package com.ssm.chapter10.annotation.service;\nimport com.ssm.chapter10.annotation.pojo.Role;\npublic interface RoleDataSourceService {\n    public Role getRole(Long id);\n}\n</code></pre>\n<p>然后实现该接口，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Component\npublic class RoleDataSourceServiceImpl implements RoleDataSourceService {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Override\n    public Role getRole(Long id) {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Role role = null;\n        try {\n            conn = dataSource.getConnection();\n            ps = conn.prepareStatement(&quot;select id, role_name, note from t_role where id=?&quot;);\n            ps.setLong(1, id);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                role = new Role();\n                role.setId(rs.getLong(&quot;id&quot;));\n                role.setRoleName(rs.getString(&quot;role_name&quot;));\n                role.setNote(rs.getString(&quot;note&quot;));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            /*close database resources*/\n        }\n        return role;\n    }\n}\n</code></pre>\n<p>这样便能把XML所配置的DataSource注入RoleDataSourceServiceImplement中了，同样也可以注入其他资源。</p>\n<p>有时所有配置都放在一个ApplicationConfig类里面会造成配置复杂，因此就希望分为多个类似于ApplicationConfig的配置类，比如ApplicationConfig2、ApplicationConfig3等，Spring也提供了注解<a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>的方式注入这些配置类，代码如下所示：</p>\n<pre><code class=\"lang-java\">@ComponentScan(basePackages = {&quot;com.ssm.chapter10.annotation&quot;})\n@Import({ApplicationConfig2.class, ApplicationConfig3.class})\npublic class ApplicationConfig {\n}\n</code></pre>\n<p>通过这样的形式加载了多个配置文件。</p>\n<p>有多个XML文件，而你希望通过其中的一个XML文件去引入其他的XML文件，假设目前有spring-bean.xml，需要引入spring-dataSource.xml，那么可以在spring-bean.xml使用import元素来加载它，如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;import resource=&quot;spring-datasource.xml&quot; /&gt;\n</code></pre>\n<p>Spring还支持通过XML的配置扫描注解的包，只需要通过\\&lt;context:component-scan\\&gt;定义扫描的包就可以了，比如下面的代码功能是等同的：</p>\n<pre><code class=\"lang-java\">@ComponentScan(basePackages={&quot;com.ssm.chapter10.annotation&quot;})\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;context:component-scan base-package=&quot;com.ssm.chapter10.annotation&quot;/&gt;\n</code></pre>\n<h2 id=\"h2-10-6-profile\"><a name=\"10.6    使用Profile\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.6    使用Profile</h2><p>有时有需要在不同环境中切换的需求，比如测试环境和开发环境的切换。Spring提供了Bean的Profile属性来实现这种需求。</p>\n<h3 id=\"h3-10-6-1-profile-\"><a name=\"10.6.1    使用注解@Profile配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.6.1    使用注解<a href=\"https://github.com/Profile\" title=\"&#64;Profile\" class=\"at-link\">@Profile</a>配置</h3><p>配置两个数据库连接池，一个用于开发（dev），一个用于测试(test)，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Bean(name = &quot;dataSource&quot;)\n@Profile(&quot;dev&quot;)\npublic DataSource getDataSource() {\n    ...\n}\n</code></pre>\n<pre><code class=\"lang-java\">@Bean(name = &quot;dataSource&quot;)\n@Profile(&quot;test&quot;)\npublic DataSource getDataSource() {\n    ...\n}\n</code></pre>\n<p>这里定义了两个Bean，都加入了<a href=\"https://github.com/Profile\" title=\"&#64;Profile\" class=\"at-link\">@Profile</a>注解，但一个值是dev，一个值是test。</p>\n<h3 id=\"h3-10-6-2-xml-profile\"><a name=\"10.6.2    使用XML定义Profile\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.6.2    使用XML定义Profile</h3><p>在一个XML中允许配置多个Profile，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;beans profile=&quot;dev&quot;&gt;\n    &lt;bean id=&quot;devDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/chapter10&quot; /&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n\n&lt;beans profile=&quot;test&quot;&gt;\n    &lt;bean id=&quot;testDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/chapter10&quot; /&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<h2 id=\"h2-10-7-properties-\"><a name=\"10.7    加载属性（properties）文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.7    加载属性（properties）文件</h2><p>在开发中，配置文件往往使用properties文件，比如使用配置数据库文件，新建一个database-config.properties文件，代码如下所示：</p>\n<pre><code class=\"lang-properties\">jdbc.database.driver=com.mysql.jdbc.Driver\njdbc.database.url=jdbc:mysql://localhost:3306/chapter10\njdbc.database.username=root\njdbc.database.password=123456\n</code></pre>\n<p>在Spring中可以使用注解或者XML的方式加载属性文件。</p>\n<h3 id=\"h3-10-7-1-\"><a name=\"10.7.1    使用注解方式加载属性文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.7.1    使用注解方式加载属性文件</h3><p>Spring提供了注解<a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a>来加载属性文件，它的配置项有：</p>\n<ul>\n<li>name：字符串，配置该属性配置的名称。</li><li>value：字符串数组，可以配置多个属性文件。</li><li>ignoreResourceNotFound：布尔值，默认为false，其含义为如果找不到对应的属性文件是否抛出异常。</li><li>encoding：文件编码，默认为空字符串“”。</li></ul>\n<p>定义Java配置类，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Configuration\n@PropertySource(value={&quot;classpath:database-config.properties&quot;},ignoreResourceNotFound=true)\npublic class ApplicationConfig{   \n}\n</code></pre>\n<h3 id=\"h3-10-7-2-xml-\"><a name=\"10.7.2    使用XML方式加载属性文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.7.2    使用XML方式加载属性文件</h3><p>同样可以使用XML方式加载属性文件，只需要使用\\&lt;context:propterty-placeholder\\&gt;元素加载配置项即可。代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;context:property-placeholder ignore-resource-not-found=&quot;true&quot; location=&quot;classpath:database-confg.properties&quot;/&gt;\n</code></pre>\n<p>ignore-resource-not-found属性表示是否忽略文件不存在，默认值为false，当为默认值时找不到中文将会抛出异常。配置多个文件时，文件名用逗号分隔。也可以这样配置，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;\n    &lt;property name=&quot;locations&quot;&gt;\n        &lt;array&gt;\n             &lt;value&gt;classpath:database-config.properties&lt;/value&gt;\n             &lt;value&gt;classpath:log4j.properties&lt;/value&gt;\n        &lt;/array&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>当需要大量配置文件的时候，使用上述方法更好。</p>\n<h2 id=\"h2-10-8-bean\"><a name=\"10.8    条件化装配Bean\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.8    条件化装配Bean</h2><p>在某些条件下不需要装配Bean。比如属性文件中没有database-confg.properties属性配置时，就不需要创建数据源，这时我们需要通过条件化去判断。Spring提供了注解<a href=\"https://github.com/Conditional\" title=\"&#64;Conditional\" class=\"at-link\">@Conditional</a>，它可以配置一个或者多个类。只是这些了都需要实现接口Condition，我们修改关于DBCP的数据源，代码如下所示：</p>\n<pre><code class=\"lang-JAVA\">@Bean(name = &quot;dataSource&quot;)\n@Conditional({DataSourceCondition.class})\npublic DataSource getDataSource(@Value(&quot;${jdbc.database.driver}&quot;) String driver, @Value(&quot;${jdbc.database.url}&quot;) String url, @Value(&quot;${jdbc.database.username}&quot;) String username, @Value(&quot;${jdbc.database.password}&quot; String password){\n    Properties properties = new Properties();\n    properties.setProperty(&quot;driver&quot;, &quot;com.mysql.jdbc.Driver&quot;);\n    properties.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/ssm_learn&quot;);\n    properties.setProperty(&quot;username&quot;, &quot;root&quot;);\n    properties.setProperty(&quot;password&quot;, &quot;1234&quot;);\n    DataSource dataSource = null;\n    try {\n        dataSource = BasicDataSourceFactory.createDataSource(properties);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return dataSource;\n}\n</code></pre>\n<p>这里通过<a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>往参数里注入了对应属性文件的配置，但是我们没有办法确定这些数据源连接池的属性是否在属性文件中已经配置完整，如果是不充足的属性配置，则会引起创建失败，为此要判断属性文件的配置是否充足才能继续创建Bean。通过<a href=\"https://github.com/Conditional\" title=\"&#64;Conditional\" class=\"at-link\">@Conditional</a>去引入了一个类——DataSourceCondition，由它来判断。这个类的代码如下所示：</p>\n<pre><code class=\"lang-java\">public class DataSourceCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n        //获取上下文环境\n        Environment env = context.getEnvironment();\n        //判断是否存在关于数据源的基础配置\n        return env.containsProperty(&quot;jdbc.database.driver&quot;) \n                &amp;&amp; env.containsProperty(&quot;jdbc.database.url&quot;)\n                &amp;&amp; env.containsProperty(&quot;jdbc.database.username&quot;)\n                &amp;&amp; env.containsProperty(&quot;jdbc.database.password&quot;);\n    }\n}\n</code></pre>\n<p>这里要求DataSourceCondition实现接口Condition的matches方法，该方法有两个参数，一个是ConditionContext，通过它可以获得Spring的上下文，另一个是AnnotatedTypeMetadata，通过它可以获得关于该Bean的注解信息。这里获取了上下文环境，然后判断该环境中的属性文件是否配置了数据库的相关参数，有则返回true，那么Spring会去创建对应的Bean，否则不创建。</p>\n<h2 id=\"h2-10-9-bean-\"><a name=\"10.9    Bean的作用域\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.9    Bean的作用域</h2><p>在默认情况下，Spring IoC容器只会为一个Bean创建一个实例，比如下面的测试：</p>\n<pre><code class=\"lang-java\">AplicationContext ctx = new ClassPathApplicationContext(&quot;spring-props.xml&quot;);\nRoleDataSourceService roleService1 = ctx.getBean(RoleDataSourceService.class);\nRoleDataSourceService roleService2 = ctx.getBean(RoleDataSourceService.class);\nSystem.out.println(roleService1 ==  roleService2);\n</code></pre>\n<p>由于roleService1与roleService2是同一个对象，结果将显示true。</p>\n<p>有时候我们希望通过容器获取某个Bean的多个实例，比如Strut2中的Action往往绑定从页面请求过来的订单，如果它也是一个实例，那么订单从头至尾只有一个，不符合互联网的并发要求。</p>\n<p>Spring提供了4种作用域，它会根据情况来决定是否生成新的对象。</p>\n<ul>\n<li>单例（Singleton）：默认选项，在整个应用中，Spring只为其生成一个Bean的实例。</li><li>原型（prototype）：当每次注入或者通过容器获取Bean时，Spring都为其创建一个新的实例。</li><li>会话（Session）：在Web应用中使用，在一次会话过程中，Spring只为其创建一个实例。</li><li>请求（Request）：在Web应用中使用，在一次请求过程中，Spring只为其创建一个实例。</li></ul>\n<p>会话和请求只能在Web应用中使用，比较少用。</p>\n<p>修改RoleDataSourceServiceImpl类，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class RoleDataSourceServiceImpl implements RoleDataSourceService {\n    ...\n}\n</code></pre>\n<p>将RoleDataSourceServiceImpl的作用域改为prototype，再次进行测试，会发现结果显示false，这表示它们是两个不相同的实例。</p>\n<h2 id=\"h2-10-10-spring-spring-el-\"><a name=\"10.10    使用Spring表达式（Spring EL）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.10    使用Spring表达式（Spring EL）</h2><p>Spring提供了更为灵活的注入方式——Spring EL。它拥有很多功能：</p>\n<ul>\n<li>通过Bean的id来引用Bean。</li><li>调用指定对象的方法和访问对象的属性，</li><li>进行运算。</li><li>提供正则表达式匹配。</li><li>集合配置。</li></ul>\n<h3 id=\"h3-10-10-1-spring-el-\"><a name=\"10.10.1    Spring EL相关的类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.10.1    Spring EL相关的类</h3><h3 id=\"h3-10-10-2-bean-\"><a name=\"10.10.2    Bean的属性和方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.10.2    Bean的属性和方法</h3><p>使用注解<a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>，读取属性文件使用的是“$”,而在SpringEL中则使用“#”。以Role类为例，初始化它的属性，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Component(&quot;role&quot;)\npublic class Role {\n    // 赋值long型\n    @Value(&quot;#{1}&quot;)\n    private Long id;\n    // 字符串赋值\n    @Value(&quot;#{&#39;role_name_1&#39;}&quot;)\n    private String roleName;\n    // 字符串赋值\n    @Value(&quot;#{&#39;note_1&#39;}&quot;)\n    private String note;\n    /*getter and setter*/\n}\n</code></pre>\n<p>这样就定义了一个名为role的Bean了，并且为它的属性赋值。这时可以通过另外一个Bean去引用它的属性或者调用它的方法，比如新建一个ElBean作为测试，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Component(&quot;elBean&quot;)\npublic class ElBean {\n\n    //通过beanName获取bean，然后注入\n    @Value(&quot;#{role}&quot;)\n    private Role role;\n\n    //获取bean的属性id\n    @Value(&quot;#{role.id}&quot;)\n    private Long id;\n\n    //调用bean的getNote方法，获取角色名称\n    @Value(&quot;#{role.getNote().toString()}&quot;)\n    private String note;\n\n     /*getter and setter*/\n}\n</code></pre>\n<p>我们可以通过BeanName进行注入，也可以通过OGNL获取其属性或者调用其方法来注入其他的Bean。</p>\n<h3 id=\"h3-10-10-3-\"><a name=\"10.10.3    使用类的静态常量和方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.10.3    使用类的静态常量和方法</h3><p>有时候我们可能希望使用一些静态方法和常量，比如圆周率π。而在Java中就是Math类的PI常量了，注入它非常简单，代码如下所示：</p>\n<pre><code class=\"lang-java\">@Value(&quot;#{T(Math).PI}&quot;)\nprivate double pi;\n</code></pre>\n<p>这里的Math代表的是java.lang.*包下的Math类。当在Java代码中使用该包是不需要导入的，对于SpringEL也是如此。如果在Spring中使用一个非该包的内容，那么要给出该类的全限定名，类似这样：</p>\n<pre><code class=\"lang-java\">@Value(&quot;#{T(java.lang.Math).PI}&quot;)\nprivate double pi;\n</code></pre>\n<h3 id=\"h3-10-10-4-spring-el-\"><a name=\"10.10.4    Spring EL运算\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.10.4    Spring EL运算</h3><p>SpringEL还可以进行运算，比如在ElBean上增加一个数字num，其值默认是角色编号+1，那么我们可以写成：</p>\n<pre><code class=\"lang-java\">@Value(&quot;#{role.id + 1}&quot;)\nprivate long num;\n</code></pre>\n<p>有时候“+”运算符也可以运用在字符串的连接上，比如：</p>\n<pre><code class=\"lang-java\">@Value(&quot;#{role.roleName + role.note}&quot;)\nprivate String str;\n</code></pre>\n<p>数字和字符串都可以使用“eq”或者“==”进行相等比较。除此之外，还有大于、小于等数字运行，比如：</p>\n<pre><code class=\"lang-java\">@Value(&quot;#{role.id == 1}&quot;)\nprivate boolean equalNum;\n\n@Value(&quot;#{role.note eq &#39;note_1&#39;}&quot;)\nprivate boolean equalString;\n\n@Value(&quot;#{role.id &gt; 2}&quot;)\nprivate boolean greater;\n\n@Value(&quot;#{role.id &lt; 2}&quot;)\nprivate booleanless;\n</code></pre>\n<p>还可以使用三目运算符，比如：</p>\n<pre><code class=\"lang-java\">int max = (role.getId()&gt;1 ? 5 : 1);\n</code></pre>\n<pre><code class=\"lang-java\">String defualtString = (role.getNote() == null ? &quot;hello&quot; : role.getNote());\n</code></pre>\n<p>通过Spring EL实现上述功能：</p>\n<pre><code class=\"lang-java\">@Value(&quot;#{role.getId()&gt;1 ? 5 : 1}&quot;)\nprivate int max;\n@Value(&quot;#{role.note?:&#39;hello&#39;}&quot;)\nprivate String defaultString;\n</code></pre>\n<p>Spring EL的功能远不止这些，这里直接说最基础最常用的功能。</p>\n', '##10.1	依赖注入的3种方式\n\n在实际环境中实现IoC容器的方式主要分为两大类，一类是依赖查找，依赖查找是通过资源定位查找对应资源；另一类是依赖注入，而Spring主要使用的是依赖注入。一般而言，依赖注入可以分为3种方式：\n\n- 构造器注入；\n- setter注入；\n- 接口注入\n\n构造器注入和setter注入是主要方式，而接口注入是从别的地方注入的方式，比如在Web工程中，往往是通过服务器（比如Tomcat）来配置数据源，这时可以用JNDI的形式通过接口将它注入Spring IoC容器中。\n\n### 10.1.1	构造器注入\n\n在大部分情况下，我们都是通过类的构造方法来创建类的对象，Spring也可以采用反射的方式，通过使用构造方法来完成注入，这就是构造器注入的原理。我们以角色类为例，代码如下：\n\n```java\npackage com.ssm.chapter9.pojo;\n\npublic class Role {\n	private Long id;\n	private String roleName;\n	private String note;\n	\n   	/*getter and setter*/\n    \n    public Role(Long id, String roleName, String note) {\n		this.id = id;\n		this.roleName = roleName;\n		this.note = note;\n	}\n}\n\n```\n\n这时不能利用无参构造创建对象，为了使Spring能够正确创建对象，需要像这样做。代码如下所示：\n\n```xml\n<bean id=\"role1\" class=\"com.ssm.chapter10.Role\">\n    <constructor-arg index=\"0\" value=\"1\"/>\n    <constructor-arg index=\"1\" value=\"总经理\"/>\n    <constructor-arg index=\"2\" value=\"公司管理者\"/>\n</bean>\n```\n\nconstructor-arg元素用于定义类构造方法的参数，其中index用于定义参数位置（从0开始），而value则是设置值。通过这样定义Spring便知道使用Role(Long, String, String)这样的构造方法去创建对象了。\n\n这样注入虽然简单，但是如果参数很多，这样的构造方法就很复杂了，这时可以考虑使用setter注入。\n\n### 10.1.2	setter注入\n\nsetter注入是Spring中最常见的注入方法，利用JavaBean定义的setter方法完成注入，灵活且可读性高。首先可以把构造方法声明为无参数的，然后使用setter注入为其设置对应的值。先在Role类中添加无参构造，然后完成配置。代码如下所示：\n\n```xml\n<bean id=\"role2\" class=\"com.ssm.chapter10.Role\">\n    <property name=\"id\" value=\"2\"/>\n    <property name=\"roleName\" value=\"高级工程师\"/>\n    <property name=\"note\" value=\"重要人员\"/>\n</bean>\n```\n\n\n\n### 10.1.3	接口注入\n\n有时候资源来自于外界，比如数据库连接资源完全可以在Tomcat下配置，然后通过JNDI的方式获取，这时我们需要采用接口注入的形式获取它。代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Context>\n	<Resource name=\"jdbc/ssm\" auth=\"Container\" type=\"javax.sql.DataSource\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/ssm\" username=\"root\" password=\"1234\" />\n</Context>\n```\n\n如果Tomcat的Web工程使用了Spring，那么可以通过Spring的机制，用JNDI获取Tomcat启动的数据库连接池，代码如下所示：\n\n```xml\n<bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n    <property name=\"jndiName\">\n        <value>java:comp/env/jdbc/ssm</value>\n    </property>\n</bean>\n```\n\n##10.2	装配Bean概述\n\n在Spring中提供3种方法进行配置：\n\n- 在XML中显式配置；\n- 在Java的接口和类中实现配置；\n- 隐式Bean的发现机制和自动装配原则。\n\n这3种方法在实际开发中被会被用到，使用优先级的建议如下：\n\n1. 基于约定优于配置的原则，应该最优先使用通过隐式Bean的发现机制和自动装配的原则，这样简单灵活。\n2. 没有办法使用自动装配原则的情况下优先考虑Java接口和类中实现配置，这样可以避免XML配置的泛滥。这种场景典型的例子是一个父类有多个子类。比如学生类有两个子类：男学生类和女学生类，通过IoC容器初始化一个学生类，容器将不知道初始化哪个子类，这个时候可以使用Java的注解配置指定。\n3. 在上述方法都无法使用的情况下，那么只能选择XML配置。由于实际开发中常常使用第三方类库，我们无法修改源码，这是就可以通过XML配置。\n\n总而言之，可以修改源码则优先使用自动装配，这样可以减少大量的XML配置。不能修改源码则使用XML配置。\n\n##10.3	通过XML配置装配Bean\n\n使用XML装配Bean需要定义对应的XML，这里需要引入对应的XML模式（XSD）文件，这些文件会定义配置Spring Bean的一些元素，一个简单的配置如下：\n\n```xml\n<?xml version=\'1.0\' encoding=\'UTF-8\' ?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n   http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\">\n   <!--Spring Bean配置代码-->\n</beans>\n```\n\n### 10.3.1	装配简易值\n\n一个简单的装配，代码如下所示：\n\n```xml\n<bean id=\"role2\" class=\"com.ssm.chapter10.Role\">\n    <property name=\"id\" value=\"2\"/>\n    <property name=\"roleName\" value=\"高级工程师\"/>\n    <property name=\"note\" value=\"重要人员\"/>\n</bean>\n```\n\n- id属性是Spring寻找Bean的标识，但不是必需的属性，缺省时Spring将采用“全限定名#{number}”的格式生成标识。在这里，标识是“com.ssm.chapter9.pojo.Role#0”。第二次声明就是“com.ssm.chapter9.pojo.Role#1”。建议自定义id，比较简单。\n\n- class属性是类的全限定名。\n\n- property元素是注入类的属性，其中name属性是注入属性名称，value属性注入属性的值。如果需要注入一些自定义的类，比如之前的果汁制作器例子，需要先定义原料的Bean，然后在制作器中引用原料。代码如下所示：\n\n  ```xml\n  <bean id=\"source\" class=\"com.ssm.chapter9.pojo.Source\">\n  		<property name=\"fruit\" value=\"橙汁\" />\n  		<property name=\"sugar\" value=\"少糖\" />\n  		<property name=\"size\" value=\"大杯\" />\n  	</bean>\n  \n  	<bean id=\"juiceMaker2\" class=\"com.ssm.chapter9.pojo.JuiceMaker2\">\n  		<property name=\"beverageShop\" value=\"贡茶\" />\n  		<property name=\"source\" ref=\"source\" />\n  	</bean>\n  ```\n\n  这里定义了一个id为source的Bean，然后在制作器中通过ref属性去引用对应的Bean。\n\n### 10.3.2    装配集合\n\n有些时候要做一些复杂的装配工作，比如Set、Map、List、Array和Properties等。我们首先定义一个JavaBean，代码如下所示：\n\n```java\npackage com.ssm.chapter10.pojo;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\npublic class ComplexAssembly {\n\n   private Long id;\n   private List<String> list;\n   private Map<String, String> map;\n   private Properties props;\n   private Set<String> set;\n   private String[] array;\n    \n   /*getter and setter*/\n}\n```\n\n装配这些常用的集合类，代码如下所示：\n\n```xml\n<bean id=\"complexAssembly\" class=\"com.ssm.chapter10.pojo.ComplexAssembly\">\n    <property name=\"id\" value=\"1\"/>\n\n    <property name=\"list\">\n        <list>\n            <value>value-list-1</value>\n            <value>value-list-1</value>\n            <value>value-list-1</value>\n        </list>\n    </property>\n\n    <property name=\"map\">\n        <map>\n            <entry key=\"key1\" value=\"value-key-1\"/>\n            <entry key=\"key2\" value=\"value-key-2\"/>\n            <entry key=\"key3\" value=\"value-key-3\"/>\n        </map>\n    </property>\n\n    <property name=\"props\">\n        <props>\n            <prop key=\"prop1\">value-prop-1</prop>\n            <prop key=\"prop2\">value-prop-2</prop>\n            <prop key=\"prop3\">value-prop-3</prop>\n        </props>\n    </property>\n\n    <property name=\"set\">\n        <set>\n            <value>value-set-1</value>\n            <value>value-set-2</value>\n            <value>value-set-3</value>\n        </set>\n    </property>\n\n    <property name=\"array\">\n        <array>\n            <value>value-array-1</value>\n            <value>value-array-2</value>\n            <value>value-array-3</value>\n        </array>\n    </property>\n</bean>\n```\n\n- List集合属性使用\\<list\\>元素注入，\\<value\\>元素指定了该集合装配的值。\n\n- Map集合属性使用\\<map\\>元素注入，\\<entry\\>元素指定了该集合装配的键值对，其中key属性为键值，value属性为对应的值。\n- Properties集合属性使用\\<props\\>元素注入，\\<prop\\>元素指定了该集合装配的Property，其中key属性为键值，该元素包裹的值为设置的值。\n- Set集合属性使用\\<set\\>元素注入，\\<value\\>元素指定了该集合装配的值。\n- Array数组属性使用\\<Array\\>元素注入，\\<value\\>元素指定了该数组装配的值。\n\n从上面可以看到各个集合对字符串的装载，但是有时需要更复杂的装载，比如这些集合中装载的是类对象。为此先创建2个POJO，代码如下所示：\n\n```java\npublic class Role {\n   private Long id;\n   private String roleName;\n   private String note;\n	\n   /*getter and setter*/\n    \n   public Role() {\n   }\n\n   public Role(Long id, String roleName, String note) {\n      this.id = id;\n      this.roleName = roleName;\n      this.note = note;\n   }\n}\n```\n\n```java\npublic class User {\n   private Long id;\n   private String userName;\n   private String note;\n    \n   /*getter and setter*/\n}\n```\n\n再创建一个稍微复杂的POJO，装配用户和角色类，代码如下所示：\n\n```java\npublic class UserRoleAssembly {\n   \n   private Long id;\n   private List<Role> list;\n   private Map<Role, User> map;\n   private Set<Role> set;\n   \n   /*getter and setter*/\n}\n```\n\n修改配置文件，代码如下：\n\n```xml\n<bean id=\"role1\" class=\"com.ssm.chapter10.pojo.Role\">\n    <property name=\"id\" value=\"1\"/>\n    <property name=\"roleName\" value=\"role_name_1\"/>\n    <property name=\"note\" value=\"role_note_1\"/>\n</bean>\n\n<bean id=\"role2\" class=\"com.ssm.chapter10.pojo.Role\">\n    <property name=\"id\" value=\"2\"/>\n    <property name=\"roleName\" value=\"role_name_2\"/>\n    <property name=\"note\" value=\"role_note_2\"/>\n</bean>\n\n<bean id=\"user1\" class=\"com.ssm.chapter10.pojo.User\">\n    <property name=\"id\" value=\"1\"/>\n    <property name=\"userName\" value=\"user_name_1\"/>\n    <property name=\"note\" value=\"user_note_1\"/>\n</bean>\n\n<bean id=\"user2\" class=\"com.ssm.chapter10.pojo.User\">\n    <property name=\"id\" value=\"2\"/>\n    <property name=\"userName\" value=\"user_name_2\"/>\n    <property name=\"note\" value=\"user_note_2\"/>\n</bean>\n\n<bean id=\"userRoleAssembly\" class=\"com.ssm.chapter10.pojo.UserRoleAssembly\">\n    <property name=\"id\" value=\"1\"/>\n    <property name=\"list\">\n        <list>\n            <ref bean=\"role1\"/>\n            <ref bean=\"role2\"/>\n        </list>\n    </property>\n\n    <property name=\"map\">\n        <map>\n            <entry key-ref=\"role1\" value-ref=\"user1\"/>\n            <entry key-ref=\"role2\" value-ref=\"user2\"/>\n        </map>\n    </property>\n\n    <property name=\"set\">\n        <set>\n            <ref bean=\"role1\"/>\n            <ref bean=\"role2\"/>\n        </set>\n    </property>\n</bean>\n```\n\n- List集合属性使用\\<list\\>元素注入，\\<ref\\>元素指定该集合装配的对象，bean属性引用已定义的Bean。\n\n- Map集合属性使用\\<map\\>元素注入，\\<entry\\>元素指定该集合装配的键值对，key-ref属性引用已定义的Bean作为键值，value-ref属性引用已定义的Bean作为对应的值。\n- Set集合属性使用\\<set\\>元素注入，\\<ref\\>元素指定该集合装配的对象，bean属性引用已定义的Bean。\n\n##10.4    通过注解装配Bean\n\n使用注解可以减少XML的配置，注解功能更强大，既能实现XML的功能，也提供自动装配的功能。\n\n在Spring中，它提供了两种方式来让Spring IoC容器发现Bean。\n\n- 组件扫描：通过定义资源的方式，让Spring IoC容器扫描对应的包，从而把Bean装配进来。\n- 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。\n\n通过组件扫描和自动装配，大部分工程都可以使用Java配置完成。但是不使用XML也存在一定弊端，比如系统存在多个公共配置（比如多个properties和XML文件），如果写在注解里，那么公共资源的配置就显得比较分散，不利于统一管理，这是使用XML更加明确一些。\n\n### 10.4.1	使用@Component装配Bean\n\n首先定义一个POJO。代码如下所示：\n\n```java\n@Component(value = \"role\")\npublic class Role {\n   @Value(\"1\")\n   private Long id;\n   @Value(\"role_name_1\")\n   private String roleName;\n   @Value(\"role_note_1\")\n   private String note;\n    \n   /*getter and setter*/\n}\n```\n\n- 注解@Component表明Spring IoC容器会扫描这个类并生成Bean实例，而其中的value属性表明这个类在容器中的id，相当于XML方式定义的Bean的id属性。也可以简写成`@Component(\"role\")`。甚至直接写成@Component，这样的话容器将为其生成默认id，其值为首字母小写的类名，这里是“role”。\n- 注解@Value表明为属性注入值。注入的时候Spring会为其转化类型。\n\n此时容器还并不知道去哪里扫描对象，所有还需要使用一个Java Config来告诉它，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.pojo;\n\nimport org.springframework.context.annotation.ComponentScan;\n@ComponentScan\npublic class PojoConfig {\n}\n```\n\n- 包名和POJO保持一致。\n- @ComponentScan表明扫描组件，默认扫描当前包的路径，POJO的包名和它保持一致才能扫描。\n\n接下来就可以通过Spring定义好的Spring IoC容器的实现类——AnnotationConfigApplicationContext生成IoC容器了，代码如下所示：\n\n```java\npublic class AnnotationMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(PojoConfig.class);\n        Role role = ctx.getBean(Role.class);\n        System.out.println(role);\n    }\n}\n```\n\n很多时候我们只需要扫描特定的类而不是整一个包，下面我们解决这个问题。另外，@Value只能注入简单值，注入对象可使用@Autowired。\n\n@ComponentScan有两个配置项，第一个是basePackages，可以配置一个Java包的数组，Spring会根据配置扫描对应的包和子包，装配配置好的Bean；第二个是basePackageClasses，可以配置多个类，Spring会根据配置的类所在的包，为包和子包进行扫描，装配对应配置的Bean。\n\n为了验证@ComponentScan的两个配置项，我们首先声明一个接口RoleService，代码如下所示：\n\n```java\nimport com.ssm.chapter10.annotation.pojo.Role;\n\npublic interface RoleService {\n    public void printRoleInfo(Role role);\n}\n```\n\n然后，创建一个实现类，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.service.impl;\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RoleServiceImpl implements RoleService {\n    @Override\n    public void printRoleInfo(Role role) {\n        System.out.println(\"id = \"+role.getId());\n        System.out.println(\"roleName = \"+role.getRoleName());\n        System.out.println(\"note = \"+role.getNote());\n    }\n}\n```\n\n这里@Component表明它是一个Spring所需要的Bean，为了装配RoleServiceImpl和之前定义的Role，需要给@ComponentScan注解加上对应的配置，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.config;\nimport com.ssm.chapter10.annotation.service.impl.RoleServiceImpl;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Role;\n\n@ComponentScan(basePackageClasses = {Role.class, RoleServiceImpl.class})\n/*\n    @ComponentScan(basePackages = {\"com.ssm.chapter10.annotation.pojo\",\n    \"com.ssm.chapter10.annotation.service\"})\n */\n/*\n    @ComponentScan(basePackages = {\"com.ssm.chapter10.annotation.pojo\",\n    \"com.ssm.chapter10.annotation.service\"},\n    basePackageClasses = {Role.class, RoleServiceImpl.class})\n */\npublic class ApplicationConfig {\n}\n```\n\n- 3种方法可以采用任意1种。\n- 每一次使用@ComponentScan定义对应的包，Spring就会生成一个对应的新的对象，也就是说配置的Bean会生成多个实例，这往往不是我们需要的。\n- 在同一个@ComponentScan中即使重复定义相同的包或者存在其子包定义，也不会造成同一个Bean的多次扫描，而导致一次配置生成多个对象。\n\n因此，建议不要采用多个@ComponentScan注解进行配置，优先使用basePackages，但在需要大量重构的工程中尽量不要使用，因为重构修改包名需要反复配置。\n\n测试上述两个配置，代码如下所示：\n\n```java\npublic class AnnotationMain {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);\n        Role role = context.getBean(Role.class);\n        RoleService roleService = context.getBean(RoleService.class);\n        roleService.printRoleInfo(role);\n        context.close();\n    }\n}\n```\n\n### 10.4.2	自动装配——@Autowired\n\n所谓自动装配技术是一种由Spring自己发现对应的Bean，自动完成装配工作的方式。只要在需要注入的地方加上注解@Autowired，Spring就会根据类型寻找定义的Bean并且将其注入。\n\n下面开始测试自动装配，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.service;\n\npublic interface RoleService2 {\n    public void printRoleInfo();\n}\n```\n\n```java\npackage com.ssm.chapter10.annotation.service.impl;\n\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService2;\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class RoleServiceImpl2 implements RoleService2 {\n\n    @Autowired\n    private Role role;\n\n    @Override\n    public void printRoleInfo() {\n        System.out.println(\"id = \"+role.getId());\n        System.out.println(\"roleName = \"+role.getRoleName());\n        System.out.println(\"note = \"+role.getNote());\n    }\n}\n```\n\n这里的 @Autowired注解，表示在Spring IoC容器定位所有的Bean后，这个字段需要按类型注入，这样容器就会寻找资源，然后将其注入。\n\n在默认情况下，容器认为必须找到对应的Bean来注入这个字段，如果寻找失败将会抛出异常。有时候这并不是一个真实的需求，比如日志有时可有可无，这时我们可以将@Autowired注解的配置项required设置为false。这时如果容器找不到对应的类型，允许不注入，也不会抛出异常，但字段可能为空而导致空指针异常。在大部分情况下都不需要这样修改。\n\n @Autowired注解除了可以配置在属性上，也可以配置在方法上，比较常见的是配置在Bean的setter方法上完成注入，代码如下所示：\n\n```java\npublic class RoleServiceImpl2 implements RoleService2 {\n\n    private Role role;\n    \n    @Autowired\n    public void setRole(Role role) {\n        this.role = role;\n    }\n}\n\n```\n\n### 10.4.3	自动装配的歧义性（@Primary和@Qulifier）\n\n@AutoWire的使用方式十分简单，但是有时候并不能使用，因为该方式按类型注入。比如当一个接口存在多个实现类时。重新定义一个新的接口RoleServiceImpl3，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.service.impl;\n\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService;\nimport org.springframework.stereotype.Component;\n\n@Component(\"roleService3\")\npublic class RoleServiceImpl3 implements RoleService {\n    @Override\n    public void printRoleInfo(Role role) {\n        System.out.println(\"id = \"+role.getId());\n        System.out.println(\"roleName = \"+role.getRoleName());\n        System.out.println(\"note = \"+role.getNote());\n    }\n}\n```\n\n再创建一个RoleController类，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.controller;\n\nimport com.ssm.chapter10.annotation.pojo.Role;\nimport com.ssm.chapter10.annotation.service.RoleService;\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class RoleController {\n\n    @Autowired\n    private RoleService roleService;\n\n    public void printRole(Role role){\n        roleService.printRoleInfo(role);\n    }\n}\n```\n\n这里的属性roleService是一个RoleService接口类型。RoleService有两个实现类，分别是RoleServiceImpl1和RoleServiceImpl3，这时容器无法判断注入哪个对象，于是就会抛出异常。\n\n因此按类型注入对象可能会因为存在多个该类型的Bean而导致注入失败。回想Spring IoC最底层容器接口——BeanFactory的定义，它存在一个通过类型获取Bean的方法：\n\n```java\n<T> T getBean(Class<T> requireType) throws BeanException;\n```\n\n通过RoleService.class作为参数就无法判断使用哪个类实例进行返回，这就是自动装配的歧义性。\n\n为了消除歧义性，Spring提供了两个@Primary和@Qualifier。\n\n#### 1、注解@Primary\n\n注解@Primary代表首要的，当Spring IoC通过一个接口或者抽象类注入对象的时候，由于存在多个实现类或者具体类，容器不清楚注入哪个类。注解@Primary则是告诉容器，优先使用该类注入。代码如下所示：\n\n```java\n@Component(\"roleService3\")\n@primary\npublic class RoleServiceImpl3 implements RoleService {\n    @Override\n    public void printRoleInfo(Role role) {\n        System.out.println(\"id = \"+role.getId());\n        System.out.println(\"roleName = \"+role.getRoleName());\n        System.out.println(\"note = \"+role.getNote());\n    }\n}\n```\n\n这里的@primary注解告诉容器，如果存在多个RoleService类型，无法判断注入哪个的时候，优先将RoleServiceImpl3的实例注入，这样就可以消除歧义性了。\n\n#### 2、注解@Qualifier\n\n除了按类型查找Bean，Spring IoC容器最底层的接口BeanFactory也定义了按名称查找的方法，这样便能消除歧义性，而@Qualifier就是这样的一个注解。\n\n```java\npublic class RoleController {\n\n    @Autowired\n    @Qualifier(\"roleService3\")\n    private RoleService roleService;\n\n    public void printRole(Role role){\n        roleService.printRoleInfo(role);\n    }\n}\n```\n\n这时容器就不会按照类型的方式注入，而是按照名称的方式注入，这样既能注入成功，也不存在歧义性。BeanFactory定义的方法如下：\n\n```java\nObject getBean(String name) throws BeanException;\n```\n\n### 10.4.4	装载有参构造方法类\n\nRole类的构造方法都是没带参数的，而事实上在某些时候构造方法是带参数的，对于一些带有参数的构造方法，也允许我们通过注解注入，比如有时RoleController的构造方法如下所示：\n\n```java\n@Component\npublic class RoleController2 {\n    private RoleService roleService;\n\n    public RoleController2(RoleService roleService) {\n        this.roleService = roleService;\n    }\n	...\n}\n\n```\n\n我们仍然可以使用@Autowired或者@Qualifier进行注入，换句话说，这两个注解还能支持到参数。代码如下所示：\n\n```java\npublic RoleController2(@Autowired RoleService roleService) {\n    this.roleService = roleService;\n}\n```\n\n### 10.4.5	使用@Bean装配Bean\n\n之前都是通过@Component装配Bean，但是@Component只能注解在类上，不能注解到方法上，但是很多时候我们并不能修改源码。这时可以使用@Bean，它可以注解到方法上，并将方法返回的对象作为Spring的Bean，存放在容器中。比如我们需要使用DBCP数据源，这时要引入关于它的包，然后来装配数据源的Bean。代码如下所示：\n\n```java\n@Bean(name = \"dataSource\")\npublic DataSource getDataSource() {\n    Properties properties = new Properties();\n    properties.setProperty(\"driver\", \"com.mysql.jdbc.Driver\");\n    properties.setProperty(\"url\", \"jdbc:mysql://localhost:3306/ssm_learn\");\n    properties.setProperty(\"username\", \"root\");\n    properties.setProperty(\"password\", \"1234\");\n    DataSource dataSource = null;\n    try {\n        dataSource = BasicDataSourceFactory.createDataSource(properties);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return dataSource;\n}\n```\n\n和其他Bean一样，它也可以通过@Autowired或者Qualifier等注解注入到其它Bean中。\n\n## 10.5	装配的混合使用\n\n在实际中，使用XML或者注解各有道理，建议在自己的工程中尽量使用注解方式，因为使用简单，而对于引入第三方包或者服务的类，尽量使用XML方式，这样的好处是可以尽量对第三方包或者服务的细节减少理解。\n\n如上述代码的注入方式就存在弊端，我们通过XML方式实现，代码如下所示：\n\n```xml\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_learn\"/>\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"1234\"/>\n</bean>\n```\n\n显然我们不需要去了解第三方包的更多细节，也不需要过多的Java代码，相对于@Bean的注入会更好一些。\n\n新建一个XML文件，命名为spring-dataSource.xml，添加上述代码。我们需要通过引用它到注解的体系中，而注解的体系则需要完成对角色编号（id）为1的查询功能。\n\n首先，使用注解@importResource，引入spring-dataSource.xml所定义的内容，代码如下所示：\n\n```java\n@ComponentScan(basePackages = {\"com.ssm.chapter10.annotation\"})\n@ImportResource({\"classpath:spring-dataSource.xml\"})\npublic class ApplicationConfig {\n}\n```\n\n\n\n这时我们就可以通过@AutoWired注入实现对数据库连接池的注入了，比如定义一个查询角色的接口——RoleDataSourceService，代码如下所示：\n\n```java\npackage com.ssm.chapter10.annotation.service;\nimport com.ssm.chapter10.annotation.pojo.Role;\npublic interface RoleDataSourceService {\n    public Role getRole(Long id);\n}\n```\n\n然后实现该接口，代码如下所示：\n\n```java\n@Component\npublic class RoleDataSourceServiceImpl implements RoleDataSourceService {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Override\n    public Role getRole(Long id) {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        Role role = null;\n        try {\n            conn = dataSource.getConnection();\n            ps = conn.prepareStatement(\"select id, role_name, note from t_role where id=?\");\n            ps.setLong(1, id);\n            rs = ps.executeQuery();\n            while (rs.next()) {\n                role = new Role();\n                role.setId(rs.getLong(\"id\"));\n                role.setRoleName(rs.getString(\"role_name\"));\n                role.setNote(rs.getString(\"note\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            /*close database resources*/\n        }\n        return role;\n    }\n}\n```\n\n这样便能把XML所配置的DataSource注入RoleDataSourceServiceImplement中了，同样也可以注入其他资源。\n\n有时所有配置都放在一个ApplicationConfig类里面会造成配置复杂，因此就希望分为多个类似于ApplicationConfig的配置类，比如ApplicationConfig2、ApplicationConfig3等，Spring也提供了注解@Import的方式注入这些配置类，代码如下所示：\n\n```java\n@ComponentScan(basePackages = {\"com.ssm.chapter10.annotation\"})\n@Import({ApplicationConfig2.class, ApplicationConfig3.class})\npublic class ApplicationConfig {\n}\n```\n\n通过这样的形式加载了多个配置文件。\n\n有多个XML文件，而你希望通过其中的一个XML文件去引入其他的XML文件，假设目前有spring-bean.xml，需要引入spring-dataSource.xml，那么可以在spring-bean.xml使用import元素来加载它，如下所示：\n\n```xml\n<import resource=\"spring-datasource.xml\" />\n```\n\nSpring还支持通过XML的配置扫描注解的包，只需要通过\\<context:component-scan\\>定义扫描的包就可以了，比如下面的代码功能是等同的：\n\n```java\n@ComponentScan(basePackages={\"com.ssm.chapter10.annotation\"})\n```\n\n```xml\n<context:component-scan base-package=\"com.ssm.chapter10.annotation\"/>\n```\n\n## 10.6	使用Profile\n\n有时有需要在不同环境中切换的需求，比如测试环境和开发环境的切换。Spring提供了Bean的Profile属性来实现这种需求。\n\n### 10.6.1	使用注解@Profile配置\n\n配置两个数据库连接池，一个用于开发（dev），一个用于测试(test)，代码如下所示：\n\n```java\n@Bean(name = \"dataSource\")\n@Profile(\"dev\")\npublic DataSource getDataSource() {\n    ...\n}\n```\n\n```java\n@Bean(name = \"dataSource\")\n@Profile(\"test\")\npublic DataSource getDataSource() {\n	...\n}\n```\n\n这里定义了两个Bean，都加入了@Profile注解，但一个值是dev，一个值是test。\n\n### 10.6.2	使用XML定义Profile\n\n在一个XML中允许配置多个Profile，代码如下所示：\n\n```xml\n<beans profile=\"dev\">\n    <bean id=\"devDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/chapter10\" />\n        <property name=\"username\" value=\"root\" />\n        <property name=\"password\" value=\"123456\" />\n    </bean>\n</beans>\n\n<beans profile=\"test\">\n    <bean id=\"testDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/chapter10\" />\n        <property name=\"username\" value=\"root\" />\n        <property name=\"password\" value=\"123456\" />\n    </bean>\n</beans>\n```\n\n## 10.7	加载属性（properties）文件\n\n在开发中，配置文件往往使用properties文件，比如使用配置数据库文件，新建一个database-config.properties文件，代码如下所示：\n\n```properties\njdbc.database.driver=com.mysql.jdbc.Driver\njdbc.database.url=jdbc:mysql://localhost:3306/chapter10\njdbc.database.username=root\njdbc.database.password=123456\n```\n\n在Spring中可以使用注解或者XML的方式加载属性文件。\n\n### 10.7.1	使用注解方式加载属性文件\n\nSpring提供了注解@PropertySource来加载属性文件，它的配置项有：\n\n- name：字符串，配置该属性配置的名称。\n- value：字符串数组，可以配置多个属性文件。\n- ignoreResourceNotFound：布尔值，默认为false，其含义为如果找不到对应的属性文件是否抛出异常。\n- encoding：文件编码，默认为空字符串“”。\n\n定义Java配置类，代码如下所示：\n\n```java\n@Configuration\n@PropertySource(value={\"classpath:database-config.properties\"},ignoreResourceNotFound=true)\npublic class ApplicationConfig{   \n}\n```\n\n### 10.7.2	使用XML方式加载属性文件\n\n同样可以使用XML方式加载属性文件，只需要使用\\<context:propterty-placeholder\\>元素加载配置项即可。代码如下：\n\n```xml\n<context:property-placeholder ignore-resource-not-found=\"true\" location=\"classpath:database-confg.properties\"/>\n```\n\nignore-resource-not-found属性表示是否忽略文件不存在，默认值为false，当为默认值时找不到中文将会抛出异常。配置多个文件时，文件名用逗号分隔。也可以这样配置，代码如下：\n\n```xml\n<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n    <property name=\"locations\">\n        <array>\n             <value>classpath:database-config.properties</value>\n        	 <value>classpath:log4j.properties</value>\n        </array>\n    </property>\n</bean>\n```\n\n当需要大量配置文件的时候，使用上述方法更好。\n\n## 10.8	条件化装配Bean\n\n在某些条件下不需要装配Bean。比如属性文件中没有database-confg.properties属性配置时，就不需要创建数据源，这时我们需要通过条件化去判断。Spring提供了注解@Conditional，它可以配置一个或者多个类。只是这些了都需要实现接口Condition，我们修改关于DBCP的数据源，代码如下所示：\n\n```JAVA\n@Bean(name = \"dataSource\")\n@Conditional({DataSourceCondition.class})\npublic DataSource getDataSource(@Value(\"${jdbc.database.driver}\") String driver, @Value(\"${jdbc.database.url}\") String url, @Value(\"${jdbc.database.username}\") String username, @Value(\"${jdbc.database.password}\" String password){\n    Properties properties = new Properties();\n    properties.setProperty(\"driver\", \"com.mysql.jdbc.Driver\");\n    properties.setProperty(\"url\", \"jdbc:mysql://localhost:3306/ssm_learn\");\n    properties.setProperty(\"username\", \"root\");\n    properties.setProperty(\"password\", \"1234\");\n    DataSource dataSource = null;\n    try {\n        dataSource = BasicDataSourceFactory.createDataSource(properties);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return dataSource;\n}\n```\n\n这里通过@Value往参数里注入了对应属性文件的配置，但是我们没有办法确定这些数据源连接池的属性是否在属性文件中已经配置完整，如果是不充足的属性配置，则会引起创建失败，为此要判断属性文件的配置是否充足才能继续创建Bean。通过@Conditional去引入了一个类——DataSourceCondition，由它来判断。这个类的代码如下所示：\n\n```java\npublic class DataSourceCondition implements Condition {\n	@Override\n	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n		//获取上下文环境\n		Environment env = context.getEnvironment();\n		//判断是否存在关于数据源的基础配置\n		return env.containsProperty(\"jdbc.database.driver\") \n				&& env.containsProperty(\"jdbc.database.url\")\n				&& env.containsProperty(\"jdbc.database.username\")\n				&& env.containsProperty(\"jdbc.database.password\");\n	}\n}\n```\n\n这里要求DataSourceCondition实现接口Condition的matches方法，该方法有两个参数，一个是ConditionContext，通过它可以获得Spring的上下文，另一个是AnnotatedTypeMetadata，通过它可以获得关于该Bean的注解信息。这里获取了上下文环境，然后判断该环境中的属性文件是否配置了数据库的相关参数，有则返回true，那么Spring会去创建对应的Bean，否则不创建。\n\n## 10.9	Bean的作用域\n\n在默认情况下，Spring IoC容器只会为一个Bean创建一个实例，比如下面的测试：\n\n```java\nAplicationContext ctx = new ClassPathApplicationContext(\"spring-props.xml\");\nRoleDataSourceService roleService1 = ctx.getBean(RoleDataSourceService.class);\nRoleDataSourceService roleService2 = ctx.getBean(RoleDataSourceService.class);\nSystem.out.println(roleService1 ==  roleService2);\n```\n\n由于roleService1与roleService2是同一个对象，结果将显示true。\n\n有时候我们希望通过容器获取某个Bean的多个实例，比如Strut2中的Action往往绑定从页面请求过来的订单，如果它也是一个实例，那么订单从头至尾只有一个，不符合互联网的并发要求。\n\nSpring提供了4种作用域，它会根据情况来决定是否生成新的对象。\n\n- 单例（Singleton）：默认选项，在整个应用中，Spring只为其生成一个Bean的实例。\n- 原型（prototype）：当每次注入或者通过容器获取Bean时，Spring都为其创建一个新的实例。\n- 会话（Session）：在Web应用中使用，在一次会话过程中，Spring只为其创建一个实例。\n- 请求（Request）：在Web应用中使用，在一次请求过程中，Spring只为其创建一个实例。\n\n会话和请求只能在Web应用中使用，比较少用。\n\n修改RoleDataSourceServiceImpl类，代码如下所示：\n\n```java\n@Component\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class RoleDataSourceServiceImpl implements RoleDataSourceService {\n	...\n}\n\n```\n\n将RoleDataSourceServiceImpl的作用域改为prototype，再次进行测试，会发现结果显示false，这表示它们是两个不相同的实例。\n\n## 10.10	使用Spring表达式（Spring EL）\n\nSpring提供了更为灵活的注入方式——Spring EL。它拥有很多功能：\n\n- 通过Bean的id来引用Bean。\n- 调用指定对象的方法和访问对象的属性，\n- 进行运算。\n- 提供正则表达式匹配。\n- 集合配置。\n\n### 10.10.1    Spring EL相关的类\n\n### 10.10.2	Bean的属性和方法\n\n使用注解@Value，读取属性文件使用的是“$”,而在SpringEL中则使用“#”。以Role类为例，初始化它的属性，代码如下所示：\n\n```java\n@Component(\"role\")\npublic class Role {\n	// 赋值long型\n	@Value(\"#{1}\")\n	private Long id;\n	// 字符串赋值\n	@Value(\"#{\'role_name_1\'}\")\n	private String roleName;\n	// 字符串赋值\n	@Value(\"#{\'note_1\'}\")\n	private String note;\n    /*getter and setter*/\n}\n\n```\n\n这样就定义了一个名为role的Bean了，并且为它的属性赋值。这时可以通过另外一个Bean去引用它的属性或者调用它的方法，比如新建一个ElBean作为测试，代码如下所示：\n\n```java\n@Component(\"elBean\")\npublic class ElBean {\n	\n    //通过beanName获取bean，然后注入\n	@Value(\"#{role}\")\n	private Role role;\n	\n    //获取bean的属性id\n	@Value(\"#{role.id}\")\n	private Long id;\n	\n    //调用bean的getNote方法，获取角色名称\n	@Value(\"#{role.getNote().toString()}\")\n	private String note;\n\n	 /*getter and setter*/\n}\n```\n\n我们可以通过BeanName进行注入，也可以通过OGNL获取其属性或者调用其方法来注入其他的Bean。\n\n### 10.10.3	使用类的静态常量和方法\n\n有时候我们可能希望使用一些静态方法和常量，比如圆周率π。而在Java中就是Math类的PI常量了，注入它非常简单，代码如下所示：\n\n```java\n@Value(\"#{T(Math).PI}\")\nprivate double pi;\n```\n\n这里的Math代表的是java.lang.*包下的Math类。当在Java代码中使用该包是不需要导入的，对于SpringEL也是如此。如果在Spring中使用一个非该包的内容，那么要给出该类的全限定名，类似这样：\n\n```java\n@Value(\"#{T(java.lang.Math).PI}\")\nprivate double pi;\n```\n\n### 10.10.4	Spring EL运算\n\nSpringEL还可以进行运算，比如在ElBean上增加一个数字num，其值默认是角色编号+1，那么我们可以写成：\n\n```java\n@Value(\"#{role.id + 1}\")\nprivate long num;\n```\n\n有时候“+”运算符也可以运用在字符串的连接上，比如：\n\n````java\n@Value(\"#{role.roleName + role.note}\")\nprivate String str;\n````\n\n数字和字符串都可以使用“eq”或者“==”进行相等比较。除此之外，还有大于、小于等数字运行，比如：\n\n```java\n@Value(\"#{role.id == 1}\")\nprivate boolean equalNum;\n\n@Value(\"#{role.note eq \'note_1\'}\")\nprivate boolean equalString;\n\n@Value(\"#{role.id > 2}\")\nprivate boolean greater;\n\n@Value(\"#{role.id < 2}\")\nprivate booleanless;\n```\n\n还可以使用三目运算符，比如：\n\n```java\nint max = (role.getId()>1 ? 5 : 1);\n```\n\n```java\nString defualtString = (role.getNote() == null ? \"hello\" : role.getNote());\n```\n\n通过Spring EL实现上述功能：\n\n```java\n@Value(\"#{role.getId()>1 ? 5 : 1}\")\nprivate int max;\n@Value(\"#{role.note?:\'hello\'}\")\nprivate String defaultString;\n```\n\nSpring EL的功能远不止这些，这里直接说最基础最常用的功能。', 'http://cdn.alanliang.site/note/landscape1.jpg', 1, 0, 0, 0, b'0', b'1', b'1', b'0', b'1', 5, 3, 1, 2, '2020-06-15 11:32:09', '2020-06-15 11:32:09');
INSERT INTO `t_article` VALUES (8, 'Spring MVC的初始化和流程', 'JavaEE互联网轻量级框架整合开发第十四章', '<h2 id=\"h2-14-1-mvc-\"><a name=\"14.1    MVC设计概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.1    MVC设计概述</h2><p>MVC出现的根本原因：解耦各个模块。</p>\n<h3 id=\"h3-14-1-1-spring-mvc-\"><a name=\"14.1.1    Spring MVC的架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.1.1    Spring MVC的架构</h3><p> <img src=\"http://cdn.alanliang.site/note/Spring MVC架构.jpg\" alt=\"Spring MVC架构\"></p>\n<h3 id=\"h3-14-1-2-spring-mvc-\"><a name=\"14.1.2    Spring MVC组件与流程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.1.2    Spring MVC组件与流程</h3><p>Spring MVC的核心在于其流程，这是使用Spring MVC框架的基础，Spring MVC是一种基于Servlet的技术，它提供了核心控制器DispatcherServlet和相关的组件，并制定了松散的结构，以适合各种灵活的需要。其组件和流程如下：<img src=\"http://q8rsjstig.bkt.clouddn.com/note/Spring MVC组件和流程图.jpg\" alt=\"Spring MVC组件和流程图\"></p>\n<p>当一个请求到来时，DispatcherServlet首先通过请求和事先解析好的HandlerMapping配置，找到对应的处理器（Handler），这里就准备开始运行处理器和拦截器组成的执行链，而运行处理器需要有一个对应的环境，这样就有了一个处理器的适配器（HandlerAdapter），通过这个适配器就能运行对应的处理器和拦截器，这里的处理器包含了控制器的内容和其它增强的功能，在处理器返回模型和视图给DispatcherServlet后，DispatcherServlet就会把对应的视图信息传递给视图解析器（ViewResolver），然后把模型渲染到视图中去。</p>\n<h3 id=\"h3-14-1-3-spring-mvc-\"><a name=\"14.1.3    Spring MVC入门的实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.1.3    Spring MVC入门的实例</h3><p>首先需要配置Web工程的web.xml文件，代码如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;\n    &lt;!--配置Spring IoC配置文件路径--&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;/web/WEB-INF/applicationContext.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n    &lt;!--配置ContextLoaderListener用于初始化Spring IoCrongqi--&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n    &lt;!--配置DispatcherServlet--&gt;\n    &lt;servlet&gt;\n        &lt;!--注意：Spring MVC会根据servlet-name配置，找到WEB-INF/dispatcher-servlet作为配置文件载入Web工程中--&gt;\n        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!--使得Dispatch而在服务器启动时就初始化--&gt;\n        &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre>\n<ul>\n<li>contextConfigLocation。它配置Spring IoC的配置文件路径，如果是多个配置文件则用逗号隔开，其默认值为/WEB-INF/application.xml。</li><li>ContextLoaderListener。它实现了接口ServletContextListener，可以在Web工程初始化之前完成对Spring IoC容器的初始化，也可以在Web工程关闭之时完成对容器的资源释放。</li><li>DispatcherServlet。首先配置了servlet-name为dispatcher，这就意味着需要一个/WEB-INF/dispacher-servlet.xml文件（注意名字的对应关系），并且配置了在服务器启动时就初始化它。</li><li>配置DispatcherServlet拦截以后缀“do”结束的请求。这样以“do”结尾的请求都会被拦截。</li></ul>\n<p>在这个例子中，暂时不需要配置ApplicationContext.xml的任何内容。但是需要配置/WEB-INF/dispacher-servlet.xml文件，内容如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\n       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;\n    &lt;!--使用注解驱动--&gt;\n    &lt;mvc:annotation-driven/&gt;\n    &lt;!--定义扫描装载的包--&gt;\n    &lt;context:component-scan base-package=&quot;com.*&quot;/&gt;\n    &lt;!--定义视图解析器--&gt;\n    &lt;!--找到Web工程/WEB-INF/JSP文件夹、且文件结尾为jsp的文件作为映射--&gt;\n    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; p:prefix=&quot;/WEB-INF/jsp/&quot;\n          p:suffix=&quot;/jsp&quot;/&gt;\n    &lt;!--如果有配置数据库事务，需要开启事务注解的话，需要开启以下这段代码--&gt;\n    &lt;!--\n        &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;\n    --&gt;\n&lt;/beans&gt;\n</code></pre>\n<ul>\n<li>\\&lt;mvc-annotation-dirven/\\&gt;表示使用注解驱动Spring MVC。</li><li>\\&lt;context:component-scan\\&gt;表示扫描组件，base-package属性配置需要扫描的包，加载控制器和其他的一些组件。</li><li>定义视图解析器，解析器中定义了视图的前缀和后缀，这样解析器就会在/WEB-INF/JSP文件夹找到对应的JSP文件作为视图响应用户请求。</li></ul>\n<p>我们再开发一个简单的Controller，代码如下所示：</p>\n<pre><code class=\"lang-java\">//注解@Controller表示它是一个控制器\n@Controller(&quot;myController&quot;)\n//表明当请求的URI在/my下的时候才由该控制器响应\n@RequestMapping(&quot;/my&quot;)\npublic class MyController {\n    @RequestMapping(&quot;/index&quot;)\n    //表明URI是/index的时候该方法才请求\n    public ModelAndView index() {\n        //模型和视图\n        ModelAndView mv = new ModelAndView();\n        //视图逻辑名称为index\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n}\n</code></pre>\n<p>首先注解<a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a>表明该类是一个控制器，Spring MVC扫描时会将它作为控制器加载。然后<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>指定了对应的请求的URI，Spring MVC在初始化的时候就会解析这些信息并存放起来，于是便有了HandlerMapping。当发生请求时，Spring MVC就会使用这些信息去找到对应的控制器提供服务。</p>\n<p>方法定义返回ModelAndView，在方法中把视图名称定义为index。根据配置，解析器会找到/WEB-INF/jsp/index.jsp作为响应。于是还需要开发这个jsp文件，代码如下所示：</p>\n<pre><code class=\"lang-html\">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;\n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Welcome to Spring Web MVC project&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n  &lt;h1&gt;Hello, Spring MVC&lt;/h1&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这个例子的执行流程如下：</p>\n<p><img src=\"http://cdn.alanliang.site/note/实例组件和运行流程.jpg\" alt=\"实例组件和运行流程\"></p>\n<p>当Spring MVC启动时就会解析MyController的注解，然后生成对应URI和请求的映射关系，并注册对应的方法。当收到请求时，首先根据URI找到对应的HandlerMapping，然后组织为一个执行链，通过请求类型找到RequestMappingHandlerAdapter，它的实例是在DispatcherServlet初始化的时候创建的。然后通过它去执行HandleExecutionChain的内容，最终在MyController的方法中将index视图返回DispatcherServlet。根据配置，最后它会找到/WEB-INF/jsp/index.jsp文件作为视图，响应最终的请求。</p>\n<h2 id=\"h2-14-2-spring-mvc-\"><a name=\"14.2    Spring MVC初始化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.2    Spring MVC初始化</h2><h3 id=\"h3-14-2-1-spring-ioc-\"><a name=\"14.2.1    初始化Spring IoC上下文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.2.1    初始化Spring IoC上下文</h3><p>通过实现ServletContextListener接口可以在DispatcherServlet初始化前就可以完成Spring IoC容器的初始化，也可以在结束期完成对Spring IoC容器的销毁。部分源码如下：</p>\n<pre><code class=\"lang-java\">package org.springframework.web.context;\n\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\n\npublic class ContextLoaderListener extends ContextLoader implements ServletContextListener {\n    ...\n    /*初始化容器，使用的是满足ApplicationContext接口的Spring Web IoC容器*/\n    public void contextInitialized(ServletContextEvent event) {\n        this.initWebApplicationContext(event.getServletContext());\n    }\n\n    public void contextDestroyed(ServletContextEvent event) {\n        //关闭Web IoC容器\n        this.closeWebApplicationContext(event.getServletContext());\n        //清除相关参数\n        ContextCleanupListener.cleanupAttributes(event.getServletContext());\n    }\n}\n</code></pre>\n<h3 id=\"h3-14-2-2-\"><a name=\"14.2.2    初始化映射请求上下文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.2.2    初始化映射请求上下文</h3><p>映射请求上下文是通过DispatcherServlet初始化。在大部分场景下，都应该让DispatcherServlet在服务器启动期间就完成Spring IoC容器的初始化，建议在Web容器刚开始时初始化。</p>\n<pre><code class=\"lang-java\">@Override\nprotected void onRefresh(ApplicationContext context){\n    initStrategies(context);\n}\n\nprotected void initStrategies(ApplicationContext context){\n    //初始化文件的解析\n    initMultipartResolver(context);\n    //本地解析化\n    initLocaleResolver(context);\n    //主题解析\n    initThemeResolver(context);\n    //处理器映射\n    initHandlerMappings(context);\n      //处理器的适配器\n    initHandlerAdapters(context);\n    //Handler的异常处理解析器\n    initHandlerExceptionResolvers(context);\n       //当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名\n    initRequestToViewNameTranslator(context);\n     //视图逻辑名称转化器，即允许返回逻辑视图名称，然后它将找到真实的视图\n    initViewResolvers(context);\n    //这是一个关注Flash开发的Map管理器\n    initFlashMapManager(context);\n}\n</code></pre>\n<ul>\n<li>MultipartResolver：文件解析器，用户支持服务器的文件上传。</li><li>LocaleResolver：国际化解析器，可以提供国际化的功能。</li><li>ThemeResolver：主题解析器，类似于软件皮肤的转换功能。</li><li>HandlerMapping：Spring MVC中非常重要的内容，它会包装用户提供一个控制器的方法和它的一些拦截器，通过调用它就能运行控制器。</li><li>HandlerAdapter：处理器适配器，因为处理器会在不同的上下文中运行，所以Spring MVC会找到合适的适配器并运行处理器服务方法，比如处理控制器的SimpleControllerHandlerAdapter、处理普通请求的HttpRequestHandlerAdapter等。</li><li>HandlerExceptionResolver：处理器异常解析器，出现异常后，可以转到指定的异常页面，这样使得用户的UI体验得到了改善。</li><li>RequestToViewNameTranslator：视图逻辑名称转换器，有时候在控制器中返回一个视图名称，通过它可以找到实际的视图。当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名。</li><li>ViewResolver：视图解析器，当控制器返回后，通过视图解析器会把逻辑视图名称进行解析，然后定位实际视图。</li></ul>\n<h3 id=\"h3-14-2-3-\"><a name=\"14.2.3    使用注解配置方式初始化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.2.3    使用注解配置方式初始化</h3><p>使用注解方式很简单，首先继承AbstractAnnotationConfigDispatcherServletInitializer，然后实现它所定义的方法。代码如下：</p>\n<pre><code class=\"lang-java\">public class MyWebApplInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class&lt;?&gt;[] getRootConfigClasses() {\n        //可以返回Spring的Java配置文件数组\n        return new Class&lt;?&gt;[]{};\n    }\n\n    //DispatcherServlet的URI映射关系\n    @Override\n    protected Class&lt;?&gt;[] getServletConfigClasses() {\n        //可以返回Spring的Java配置文件数组\n        return new Class&lt;?&gt;[]{WebConfig.class};\n    }\n\n    //DispatcherServlet拦截内容\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{&quot;*.do&quot;};\n    }\n}\n</code></pre>\n<p>这里使用它去代替XML配置。</p>\n<h2 id=\"h2-14-3-spring-mvc-\"><a name=\"14.3    Spring MVC开发流程详解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.3    Spring MVC开发流程详解</h2><p>在目前的开发中，大部分都会采用注解的开发方式，使用注解十分简单，主要是以一个注解<a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a>标注，一般只需要通过配置扫描，只是往往还要结合注解<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>配置。<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>可以配置在类或者方法上，它的作用是指定URI和哪个类（或者方法）作为一个处理请求的处理器，为了更加灵活，Spring MVC还定义了处理器的拦截器，当启动Spring MVC时，Spring MVC就会去解析<a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a>中的<a href=\"https://github.com/requestMapping\" title=\"&#64;requestMapping\" class=\"at-link\">@requestMapping</a>的配置，再结合配置的拦截器，这样它就会组成多个拦截器和一个控制器的形式，存放到HandlerMapping中去。当请求来到服务器，首先是通过请求信息找到对应的HandlerMapping，进而找到对应的拦截器和处理器，这样就能运行对应的控制器和拦截器。</p>\n<h3 id=\"h3-14-3-1-requestmapping\"><a name=\"14.3.1    配置@RequestMapping\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.3.1    配置<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></h3><p><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>中最常用的是请求路径和请求类型，其他的大部分作为限定项，根据需要进行匹配。比如在入门实例MyController中加入一个index2方法，代码如下所示：</p>\n<pre><code class=\"lang-java\">@RequestMapping(value = &quot;/index2&quot;, method = RequestMethod.GET)\npublic ModelAndView index2() {\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(&quot;index&quot;);\n    return mv;\n}\n</code></pre>\n<p>这样就能够响应/my/index2.do的HTTP GET请求（只能响应GET请求，没配置method会响应所有类型的请求）了。</p>\n<h3 id=\"h3-14-3-2-\"><a name=\"14.3.2    控制器的开发\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.3.2    控制器的开发</h3><p>控制器开发一般分为3步：</p>\n<ul>\n<li>获取请求参数。</li><li>处理业务逻辑。</li><li>绑定模型和视图。</li></ul>\n<h4 id=\"h4-14-3-2-1-\"><a name=\"14.3.2.1    获取请求参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.3.2.1    获取请求参数</h4><p>在Spring MVC中建议不要使用Servlet容器提供的API，不然这样做控制器将会依赖于Servlet容器，比如以下代码：</p>\n<pre><code class=\"lang-java\">@RequestMapping(value=&quot;/index2&quot;, method=RequestMethod.GET)\npublic ModelAndView index2(HttpSession session, HttpServletRequest request){\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(&quot;index&quot;);\n    return mv;\n}\n</code></pre>\n<p>Spring MVC会自动解析代码中的方法参数session、request，然后传递关于Servlet容器的API参数，所以是可以获取到的。但如果这样做，那么对于index2方法而言，它就和Servlet容器紧密关联了，不利于扩展和测试。为了更加灵活，Spring MVC提供了更多的方法和注解用于获取参数。</p>\n<p>如果要获取一个HTTP请求的参数——Long类型的id，那么可以直接使用注解<a href=\"https://github.com/requestParam\" title=\"&#64;requestParam\" class=\"at-link\">@requestParam</a>来获取它，index方法可以写成如下代码：</p>\n<pre><code class=\"lang-java\">@RequestMapping(value = &quot;/index2&quot;, method = RequestMethod.GET)\npublic ModelAndView index2(@RequestParam(&quot;id&quot;) Long id) {\n    System.out.println(&quot;params[id] = &quot; + id);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(&quot;index&quot;);\n    return mv;\n}\n</code></pre>\n<p>通过<a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a>注解就能从HTTP请求中获取参数，相当于以下代码：</p>\n<pre><code class=\"lang-java\">String idStr = request.getParameter(&quot;id&quot;);\nLong id = Long.parseLong(idStr);\n</code></pre>\n<p>在默认情况下，对于使用了注解<a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a>的参数而言，它要求参数不能为空，否则Spring MVC将抛出异常。有时我们还希望给参数一个默认值。<a href=\"https://github.com/requestParam\" title=\"&#64;requestParam\" class=\"at-link\">@requestParam</a>还给出了两个有用的配置项。</p>\n<ul>\n<li><p>required：表示该属性是否必须有值，默认为true。也就是不允许参数为空，如果允许为空则配置为false。</p>\n</li><li><p>defaultValue：表示该属性的默认值。</p>\n</li></ul>\n<p>通过注解和约定，消除了对Servlet API的依赖，以便进行测试和扩展。</p>\n<p>除此之外，假设在登录系统时在Session设置了userName，那么可以使用Spring MVC提供的注解<a href=\"https://github.com/SessionAtrribute\" title=\"&#64;SessionAtrribute\" class=\"at-link\">@SessionAtrribute</a>来获取。代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(value = &quot;/index2&quot;, method = RequestMethod.GET)\n    public ModelAndView index2(@SessionAttribute(&quot;userName&quot;) String userName) {\n        System.out.println(&quot;session[userName] = &quot; + userName);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n</code></pre>\n<h3 id=\"h3-14-3-2-2-\"><a name=\"14.3.2.2    实现逻辑和绑定视图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14.3.2.2    实现逻辑和绑定视图</h3><p>一般而言，实现的逻辑和数据库有关联，首先修改applicationContext.xml文件，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;\n    &lt;!--使用注解驱动--&gt;\n    &lt;context:annotation-config/&gt;\n    &lt;!--数据库连接池--&gt;\n    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm_learn&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;\n        &lt;property name=&quot;maxTotal&quot; value=&quot;255&quot;/&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot;/&gt;\n        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;\n    &lt;/bean&gt;\n    &lt;!--集成mybatis--&gt;\n    &lt;bean id=&quot;factory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/mybatis/mybatis-config.xml&quot;/&gt;\n    &lt;/bean&gt;\n    &lt;!--配置数据源事务管理器--&gt;\n    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n    &lt;/bean&gt;\n    &lt;!--采用自动扫描方式创建mapper bean--&gt;\n    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n        &lt;property name=&quot;basePackage&quot; value=&quot;com.ssm.chapter14&quot;/&gt;\n        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;factory&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>假设上述的XML配置文件已经通过扫描的方式初始化了一个Spring IoC中的Bean——RoleService，而且它提供一个参数类型为Long的方法getRole来获取角色，那么可以通过自动装配的方式在控制器中注入它，代码如下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;role&quot;)\npublic class RoleController {\n    //注入RoleService\n    @Autowired\n    private RoleService roleService;\n\n    @RequestMapping(value = &quot;/getRole&quot;, method = RequestMethod.GET)\n    public ModelAndView getRole(@RequestParam(&quot;id&quot;) Long id) {\n        Role role = roleService.getRole(id);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;roleDetails&quot;);\n        //给数据模型添加一个角色对象\n        mv.addObject(&quot;role&quot;, role);\n        return mv;\n    }\n}\n</code></pre>\n', '\n\n## 14.1	MVC设计概述\n\nMVC出现的根本原因：解耦各个模块。\n\n### 14.1.1	Spring MVC的架构\n\n ![Spring MVC架构](http://cdn.alanliang.site/note/Spring MVC架构.jpg)\n\n### 14.1.2	Spring MVC组件与流程\n\nSpring MVC的核心在于其流程，这是使用Spring MVC框架的基础，Spring MVC是一种基于Servlet的技术，它提供了核心控制器DispatcherServlet和相关的组件，并制定了松散的结构，以适合各种灵活的需要。其组件和流程如下：![Spring MVC组件和流程图](http://q8rsjstig.bkt.clouddn.com/note/Spring MVC组件和流程图.jpg)\n\n当一个请求到来时，DispatcherServlet首先通过请求和事先解析好的HandlerMapping配置，找到对应的处理器（Handler），这里就准备开始运行处理器和拦截器组成的执行链，而运行处理器需要有一个对应的环境，这样就有了一个处理器的适配器（HandlerAdapter），通过这个适配器就能运行对应的处理器和拦截器，这里的处理器包含了控制器的内容和其它增强的功能，在处理器返回模型和视图给DispatcherServlet后，DispatcherServlet就会把对应的视图信息传递给视图解析器（ViewResolver），然后把模型渲染到视图中去。\n\n### 14.1.3	Spring MVC入门的实例\n\n首先需要配置Web工程的web.xml文件，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!--配置Spring IoC配置文件路径-->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/web/WEB-INF/applicationContext.xml</param-value>\n    </context-param>\n    <!--配置ContextLoaderListener用于初始化Spring IoCrongqi-->\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <!--配置DispatcherServlet-->\n    <servlet>\n        <!--注意：Spring MVC会根据servlet-name配置，找到WEB-INF/dispatcher-servlet作为配置文件载入Web工程中-->\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <!--使得Dispatch而在服务器启动时就初始化-->\n        <load-on-startup>2</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n- contextConfigLocation。它配置Spring IoC的配置文件路径，如果是多个配置文件则用逗号隔开，其默认值为/WEB-INF/application.xml。\n- ContextLoaderListener。它实现了接口ServletContextListener，可以在Web工程初始化之前完成对Spring IoC容器的初始化，也可以在Web工程关闭之时完成对容器的资源释放。\n- DispatcherServlet。首先配置了servlet-name为dispatcher，这就意味着需要一个/WEB-INF/dispacher-servlet.xml文件（注意名字的对应关系），并且配置了在服务器启动时就初始化它。\n- 配置DispatcherServlet拦截以后缀“do”结束的请求。这样以“do”结尾的请求都会被拦截。\n\n在这个例子中，暂时不需要配置ApplicationContext.xml的任何内容。但是需要配置/WEB-INF/dispacher-servlet.xml文件，内容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\n       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\">\n    <!--使用注解驱动-->\n    <mvc:annotation-driven/>\n    <!--定义扫描装载的包-->\n    <context:component-scan base-package=\"com.*\"/>\n    <!--定义视图解析器-->\n    <!--找到Web工程/WEB-INF/JSP文件夹、且文件结尾为jsp的文件作为映射-->\n    <bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/WEB-INF/jsp/\"\n          p:suffix=\"/jsp\"/>\n    <!--如果有配置数据库事务，需要开启事务注解的话，需要开启以下这段代码-->\n    <!--\n        <tx:annotation-driven transaction-manager=\"transactionManager\"/>\n    -->\n</beans>\n```\n\n- \\<mvc-annotation-dirven/\\>表示使用注解驱动Spring MVC。\n- \\<context:component-scan\\>表示扫描组件，base-package属性配置需要扫描的包，加载控制器和其他的一些组件。\n- 定义视图解析器，解析器中定义了视图的前缀和后缀，这样解析器就会在/WEB-INF/JSP文件夹找到对应的JSP文件作为视图响应用户请求。\n\n我们再开发一个简单的Controller，代码如下所示：\n\n```java\n//注解@Controller表示它是一个控制器\n@Controller(\"myController\")\n//表明当请求的URI在/my下的时候才由该控制器响应\n@RequestMapping(\"/my\")\npublic class MyController {\n    @RequestMapping(\"/index\")\n    //表明URI是/index的时候该方法才请求\n    public ModelAndView index() {\n        //模型和视图\n        ModelAndView mv = new ModelAndView();\n        //视图逻辑名称为index\n        mv.setViewName(\"index\");\n        return mv;\n    }\n}\n```\n\n首先注解@Controller表明该类是一个控制器，Spring MVC扫描时会将它作为控制器加载。然后@RequestMapping指定了对应的请求的URI，Spring MVC在初始化的时候就会解析这些信息并存放起来，于是便有了HandlerMapping。当发生请求时，Spring MVC就会使用这些信息去找到对应的控制器提供服务。\n\n方法定义返回ModelAndView，在方法中把视图名称定义为index。根据配置，解析器会找到/WEB-INF/jsp/index.jsp作为响应。于是还需要开发这个jsp文件，代码如下所示：\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n  <head>\n    <title>Welcome to Spring Web MVC project</title>\n  </head>\n  <body>\n  <h1>Hello, Spring MVC</h1>\n  </body>\n</html>\n```\n\n这个例子的执行流程如下：\n\n![实例组件和运行流程](http://cdn.alanliang.site/note/实例组件和运行流程.jpg)\n\n当Spring MVC启动时就会解析MyController的注解，然后生成对应URI和请求的映射关系，并注册对应的方法。当收到请求时，首先根据URI找到对应的HandlerMapping，然后组织为一个执行链，通过请求类型找到RequestMappingHandlerAdapter，它的实例是在DispatcherServlet初始化的时候创建的。然后通过它去执行HandleExecutionChain的内容，最终在MyController的方法中将index视图返回DispatcherServlet。根据配置，最后它会找到/WEB-INF/jsp/index.jsp文件作为视图，响应最终的请求。\n\n## 14.2	Spring MVC初始化\n\n### 14.2.1	初始化Spring IoC上下文\n\n通过实现ServletContextListener接口可以在DispatcherServlet初始化前就可以完成Spring IoC容器的初始化，也可以在结束期完成对Spring IoC容器的销毁。部分源码如下：\n\n```java\npackage org.springframework.web.context;\n\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\n\npublic class ContextLoaderListener extends ContextLoader implements ServletContextListener {\n    ...\n    /*初始化容器，使用的是满足ApplicationContext接口的Spring Web IoC容器*/\n    public void contextInitialized(ServletContextEvent event) {\n        this.initWebApplicationContext(event.getServletContext());\n    }\n	\n    public void contextDestroyed(ServletContextEvent event) {\n        //关闭Web IoC容器\n        this.closeWebApplicationContext(event.getServletContext());\n        //清除相关参数\n        ContextCleanupListener.cleanupAttributes(event.getServletContext());\n    }\n}\n```\n\n### 14.2.2	初始化映射请求上下文\n\n映射请求上下文是通过DispatcherServlet初始化。在大部分场景下，都应该让DispatcherServlet在服务器启动期间就完成Spring IoC容器的初始化，建议在Web容器刚开始时初始化。\n\n```java\n@Override\nprotected void onRefresh(ApplicationContext context){\n    initStrategies(context);\n}\n\nprotected void initStrategies(ApplicationContext context){\n    //初始化文件的解析\n    initMultipartResolver(context);\n    //本地解析化\n    initLocaleResolver(context);\n    //主题解析\n    initThemeResolver(context);\n    //处理器映射\n    initHandlerMappings(context);\n  	//处理器的适配器\n    initHandlerAdapters(context);\n    //Handler的异常处理解析器\n    initHandlerExceptionResolvers(context);\n   	//当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名\n    initRequestToViewNameTranslator(context);\n     //视图逻辑名称转化器，即允许返回逻辑视图名称，然后它将找到真实的视图\n    initViewResolvers(context);\n    //这是一个关注Flash开发的Map管理器\n    initFlashMapManager(context);\n}\n```\n\n- MultipartResolver：文件解析器，用户支持服务器的文件上传。\n- LocaleResolver：国际化解析器，可以提供国际化的功能。\n- ThemeResolver：主题解析器，类似于软件皮肤的转换功能。\n- HandlerMapping：Spring MVC中非常重要的内容，它会包装用户提供一个控制器的方法和它的一些拦截器，通过调用它就能运行控制器。\n- HandlerAdapter：处理器适配器，因为处理器会在不同的上下文中运行，所以Spring MVC会找到合适的适配器并运行处理器服务方法，比如处理控制器的SimpleControllerHandlerAdapter、处理普通请求的HttpRequestHandlerAdapter等。\n- HandlerExceptionResolver：处理器异常解析器，出现异常后，可以转到指定的异常页面，这样使得用户的UI体验得到了改善。\n- RequestToViewNameTranslator：视图逻辑名称转换器，有时候在控制器中返回一个视图名称，通过它可以找到实际的视图。当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名。\n- ViewResolver：视图解析器，当控制器返回后，通过视图解析器会把逻辑视图名称进行解析，然后定位实际视图。\n\n###14.2.3	使用注解配置方式初始化\n\n使用注解方式很简单，首先继承AbstractAnnotationConfigDispatcherServletInitializer，然后实现它所定义的方法。代码如下：\n\n```java\npublic class MyWebApplInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        //可以返回Spring的Java配置文件数组\n        return new Class<?>[]{};\n    }\n\n    //DispatcherServlet的URI映射关系\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        //可以返回Spring的Java配置文件数组\n        return new Class<?>[]{WebConfig.class};\n    }\n\n    //DispatcherServlet拦截内容\n    @Override\n    protected String[] getServletMappings() {\n        return new String[]{\"*.do\"};\n    }\n}\n```\n\n这里使用它去代替XML配置。\n\n## 14.3	Spring MVC开发流程详解\n\n在目前的开发中，大部分都会采用注解的开发方式，使用注解十分简单，主要是以一个注解@Controller标注，一般只需要通过配置扫描，只是往往还要结合注解@RequestMapping配置。@RequestMapping可以配置在类或者方法上，它的作用是指定URI和哪个类（或者方法）作为一个处理请求的处理器，为了更加灵活，Spring MVC还定义了处理器的拦截器，当启动Spring MVC时，Spring MVC就会去解析@Controller中的@requestMapping的配置，再结合配置的拦截器，这样它就会组成多个拦截器和一个控制器的形式，存放到HandlerMapping中去。当请求来到服务器，首先是通过请求信息找到对应的HandlerMapping，进而找到对应的拦截器和处理器，这样就能运行对应的控制器和拦截器。\n\n### 14.3.1	配置@RequestMapping\n\n@RequestMapping中最常用的是请求路径和请求类型，其他的大部分作为限定项，根据需要进行匹配。比如在入门实例MyController中加入一个index2方法，代码如下所示：\n\n```java\n@RequestMapping(value = \"/index2\", method = RequestMethod.GET)\npublic ModelAndView index2() {\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(\"index\");\n    return mv;\n}\n```\n\n这样就能够响应/my/index2.do的HTTP GET请求（只能响应GET请求，没配置method会响应所有类型的请求）了。\n\n### 14.3.2	控制器的开发\n\n控制器开发一般分为3步：\n\n- 获取请求参数。\n- 处理业务逻辑。\n- 绑定模型和视图。\n\n#### 14.3.2.1    获取请求参数\n\n在Spring MVC中建议不要使用Servlet容器提供的API，不然这样做控制器将会依赖于Servlet容器，比如以下代码：\n\n```java\n@RequestMapping(value=\"/index2\", method=RequestMethod.GET)\npublic ModelAndView index2(HttpSession session, HttpServletRequest request){\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(\"index\");\n    return mv;\n}\n```\n\nSpring MVC会自动解析代码中的方法参数session、request，然后传递关于Servlet容器的API参数，所以是可以获取到的。但如果这样做，那么对于index2方法而言，它就和Servlet容器紧密关联了，不利于扩展和测试。为了更加灵活，Spring MVC提供了更多的方法和注解用于获取参数。\n\n如果要获取一个HTTP请求的参数——Long类型的id，那么可以直接使用注解@requestParam来获取它，index方法可以写成如下代码：\n\n```java\n@RequestMapping(value = \"/index2\", method = RequestMethod.GET)\npublic ModelAndView index2(@RequestParam(\"id\") Long id) {\n    System.out.println(\"params[id] = \" + id);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(\"index\");\n    return mv;\n}\n```\n\n通过@RequestParam注解就能从HTTP请求中获取参数，相当于以下代码：\n\n```java\nString idStr = request.getParameter(\"id\");\nLong id = Long.parseLong(idStr);\n```\n\n在默认情况下，对于使用了注解@RequestParam的参数而言，它要求参数不能为空，否则Spring MVC将抛出异常。有时我们还希望给参数一个默认值。@requestParam还给出了两个有用的配置项。\n\n- required：表示该属性是否必须有值，默认为true。也就是不允许参数为空，如果允许为空则配置为false。\n\n- defaultValue：表示该属性的默认值。\n\n通过注解和约定，消除了对Servlet API的依赖，以便进行测试和扩展。\n\n除此之外，假设在登录系统时在Session设置了userName，那么可以使用Spring MVC提供的注解@SessionAtrribute来获取。代码如下：\n\n```java\n@RequestMapping(value = \"/index2\", method = RequestMethod.GET)\n    public ModelAndView index2(@SessionAttribute(\"userName\") String userName) {\n        System.out.println(\"session[userName] = \" + userName);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n```\n\n### 14.3.2.2	实现逻辑和绑定视图\n\n一般而言，实现的逻辑和数据库有关联，首先修改applicationContext.xml文件，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        \n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n    <!--使用注解驱动-->\n    <context:annotation-config/>\n    <!--数据库连接池-->\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm_learn\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"1234\"/>\n        <property name=\"maxTotal\" value=\"255\"/>\n        <property name=\"maxIdle\" value=\"5\"/>\n        <property name=\"maxWaitMillis\" value=\"10000\"/>\n    </bean>\n    <!--集成mybatis-->\n    <bean id=\"factory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"configLocation\" value=\"classpath:/mybatis/mybatis-config.xml\"/>\n    </bean>\n    <!--配置数据源事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!--采用自动扫描方式创建mapper bean-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"basePackage\" value=\"com.ssm.chapter14\"/>\n        <property name=\"sqlSessionFactoryBeanName\" value=\"factory\"/>\n    </bean>\n</beans>\n```\n\n假设上述的XML配置文件已经通过扫描的方式初始化了一个Spring IoC中的Bean——RoleService，而且它提供一个参数类型为Long的方法getRole来获取角色，那么可以通过自动装配的方式在控制器中注入它，代码如下：\n\n```java\n@Controller\n@RequestMapping(\"role\")\npublic class RoleController {\n    //注入RoleService\n    @Autowired\n    private RoleService roleService;\n\n    @RequestMapping(value = \"/getRole\", method = RequestMethod.GET)\n    public ModelAndView getRole(@RequestParam(\"id\") Long id) {\n        Role role = roleService.getRole(id);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"roleDetails\");\n        //给数据模型添加一个角色对象\n        mv.addObject(\"role\", role);\n        return mv;\n    }\n}\n```\n\n', 'http://cdn.alanliang.site/note/landscape2.jpg', 1, 0, 0, 0, b'0', b'1', b'0', b'1', b'1', 4, 3, 1, 2, '2020-06-15 11:47:17', '2020-06-15 11:47:17');
INSERT INTO `t_article` VALUES (9, '深入Spring MVC组件开发', 'JavaEE互联网轻量级框架整合开发第十五章', '<h2 id=\"h2-15-1-\"><a name=\"15.1    控制器接收各类请求参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.1    控制器接收各类请求参数</h2><p>为了应付多种传递参数的方式，先探索Spring MVC的传参方法。</p>\n<p>为此先创建一个接收各类参数的控制器——ParamsController，代码如下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/params&quot;)\npublic class ParamsController {\n    //待开发代码\n}\n</code></pre>\n<p>然后，将在接收参数控制器的基础上增加方法来演示如何接收各类参数，以角色表单为例，内容如下：</p>\n<pre><code class=\"lang-html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n        &lt;title&gt;参数&lt;/title&gt;\n        &lt;!-- 加载Query文件--&gt;\n        &lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.2.0.js&quot;&gt;\n        &lt;/script&gt;\n        &lt;script type=&quot;text/javascript&quot;&gt;\n          &lt;!--\n            此处插入JavaScript脚本\n            --&gt;\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;form id=&quot;form&quot;&gt;\n            &lt;table&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;角色名称&lt;/td&gt;\n                    &lt;td&gt;&lt;input id=&quot;roleName&quot; name=&quot;roleName&quot; value=&quot;&quot; /&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;备注&lt;/td&gt;\n                    &lt;td&gt;&lt;input id=&quot;note&quot; name=&quot;note&quot; /&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;&lt;/td&gt;\n                    &lt;td align=&quot;right&quot;&gt;&lt;input id=&quot;commit&quot; type=&quot;button&quot; value=&quot;提交&quot; /&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/table&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3 id=\"h3-15-1-1-\"><a name=\"15.1.1    接收普通请求参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.1.1    接收普通请求参数</h3><p>如果传递的参数名称和HTTP的保存一致，那么无需任何注解也可以获取参数。以上表单传递了两个HTTP参数：角色名称和备注，响应的请求是”./params/commonParams.do”，也就是提交表单后，它就会请求对应的URL。</p>\n<p>首先，在ParamsController增加对应的方法并获取参数，以下代码就是一个无注解获取HTTP请求参数的代码。</p>\n<pre><code class=\"lang-java\"> @RequestMapping(&quot;/commonParams&quot;)\n    public ModelAndView commonParams(String roleName, String note) {\n        System.out.println(&quot;roleName=&gt;&quot; + roleName);\n        System.out.println(&quot;note=&gt;&quot; + note);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n</code></pre>\n<p>通过参数名称和HTTP请求参数名称一致来获取参数，如果不一致将无法获取，这样的方式允许参数为空。</p>\n<p>但是，在参数很多的情况下，比如新增一个用户可能需要十几个字段，这时应该考虑使用一个POJO来管理这些参数。在没有任何注解的情况下，Spring MVC也有映射POJO的能力。新建一个角色参数类，代码如下：</p>\n<pre><code class=\"lang-java\">public class RoleParams {\n    private String roleName;\n    private String note;\n    /*getter and setter*/\n}\n</code></pre>\n<p>然后，在ParamController中增加一个方法来通过这个POJO获取HTTP请求参数，代码如下：</p>\n<pre><code class=\"lang-java\"> @RequestMapping(&quot;/commonParamsPojo&quot;)\n    public ModelAndView commonParamsPojo(RoleParams roleParams) {\n        System.out.println(&quot;roleName=&gt;&quot; + roleParams.getRoleName());\n        System.out.println(&quot;note=&gt;&quot; + roleParams.getNote());\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n</code></pre>\n<p>显然通过POJO也会获取到对应参数，需要注意的是POJO的属性名称也要和HTTP请求参数名称保持一致。但是有时候前端的参数命名规则和后台的不一样，比如前端把角色名称的参数命名为role_name，这时就要进行转换了。</p>\n<h3 id=\"h3-15-1-2-requestparam-\"><a name=\"15.1.2    使用@RequestParam注解获取参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.1.2    使用<a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a>注解获取参数</h3><p>Spring MVC提供了<a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a>注解来解决前后端参数名称命名不一致的问题。</p>\n<p>把HTTP的参数名称从roleName修改为role_name，那么需要重新绑定规则，此时使用<a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a>注解，代码如下：</p>\n<pre><code class=\"lang-java\"> @RequestMapping(&quot;/requestParam&quot;)\n    public ModelAndView requestParam(@RequestParam(&quot;role_name&quot;)String roleName,\n                                     @RequestParam(&quot;note&quot;) String note){\n        System.out.println(&quot;roleName=&gt;&quot; + roleName);\n        System.out.println(&quot;note=&gt;&quot; + note);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n</code></pre>\n<h3 id=\"h3-15-1-3-url-\"><a name=\"15.1.3    使用URL传递参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.1.3    使用URL传递参数</h3><p>一些网站使用URL形式传递参数，这样符合RESTful风格，对于一些业务比较简单的应用是非常常见的，比如以下代码，获取一个角色的信息，我们希望把URL写成/params/getRole/1，其中1就是一个参数，代表角色编号。现在写一个方法，它将只支持HTTP的GET请求，通过URL：/params/getRole/1来获取角色并且打印出JSON数据，他需要<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>和<a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a>两个注解共同协作完成，代码如下所示：</p>\n<pre><code class=\"lang-java\">//注入RoleService\n@Autowired\nprivate RoleService roleService;\n\n//{id}表示接受一个参数\n@RequestMapping(&quot;/getRole/{id}&quot;)\n//注解@PathVariable表示从URL的请求地址中获取参数\npublic ModelAndView pathVariable(@PathVariable(&quot;id&quot;) Long id) {\n    Role role = roleService.getRole(id);\n    ModelAndView mv = new ModelAndView();\n    //绑定数据模型\n    mv.addObject(role);\n    //设置为JSON视图\n    mv.setView(new MappingJackson2JsonView());\n    return mv;\n}\n</code></pre>\n<p>{id}表示处理器需要接受一个由URL组成的参数，且参数名称为id，那么在方法中的<a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a>(“id”)表示将获取这个在<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>中定义名称为id的参数，这样就可以在方法内获取这个参数了。</p>\n<p>测试结果如下：</p>\n<p><img src=\"http://cdn.alanliang.site/note/图15-2 通过URL获取参数.png\" alt=\"图15-2 通过URL获取参数\"></p>\n<h3 id=\"h3-15-1-4-json-\"><a name=\"15.1.4    传递JSON参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.1.4    传递JSON参数</h3><p>有时候参数的传递还需要更多参数，比如查询可能需要分页参数，这是非常常见的场景。对于查询参数，假设还有开始行start和限制返回大小的limit，由PageParams类传递，代码如下：</p>\n<pre><code class=\"lang-java\">public class PageParams {\n    private int start;\n    private int limit;\n    /*getter and setter*/\n}\n</code></pre>\n<p>只需要在RoleParams的基础上加上一个PageParams属性就可以使用分页参数了，代码如下：</p>\n<pre><code class=\"lang-java\">public class RoleParams {\n    private String roleName;\n    private String note;\n    private PageParams pageParams = null;//分页参数\n    /*getter and setter*/\n}\n</code></pre>\n<p>这个查询参数和分页参数都可以被传递了。这时客户端还需要写一段JavaScript代码来模拟这个过程，往表单插入一定JavaScript代码，代码如下：</p>\n<pre><code class=\"lang-javascript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    $(document).ready(function () {\n    $(&quot;#commit&quot;).click(function() {\n        var str = $(&quot;form&quot;).serialize();\n        //提交表单\n        $.post({\n            url: &quot;./params/commonParamPojo2.do&quot;,\n            //将form数据序列化，传递给后台，则将数据以roleName=xxx&amp;&amp;note=xxx传递\n            data: $(&quot;form&quot;).serialize(),\n            //成功后的方法\n            success: function (result) {\n            }\n        });\n    });\n});\n&lt;/script&gt;\n</code></pre>\n<p>注意，传递的JSON数据需要和对应参数的POJO保持一致。另外，在请求时需要告知请求的参数类型为JSON，这是不可缺少的，传递的参数是一个字符串，而不是一个JSON，所以这里使用JSON.stringify()方法将JSON数据转换为字符串。</p>\n<p>这个时候可以使用Spring MVC提供的注解<a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a>接收参数，代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/findRoles&quot;)\npublic ModelAndView findRoles(@RequestBody RoleParams roleParams){\n    List&lt;Role&gt; roleList = roleService.findRoles(roleParams);\n    ModelAndView mv = new ModelAndView();\n    mv.addObject(roleList);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n</code></pre>\n<h3 id=\"h3-15-1-5-\"><a name=\"15.1.5    接收列表数据和表单序列化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.1.5    接收列表数据和表单序列化</h3><p>在一些场景，如果需要一次性删除多个角色，那么一般将一个角色编号的数组传递给后台，或新增角色，甚至同时新增多个角色。无论如何，这都需要用到Java的集合或者数组来保存对应的参数。</p>\n<p>Spring MVC也支持这样的场景，假设要删除多个角色，显然你希望传递一个角色编号的数组给后台处理。通过JavaScript模仿传递角色数组给后台控制器，代码如下：</p>\n<pre><code class=\"lang-javascript\">/**传递数组**/\n$(document).ready(function () {\n    //删除角色数组\n    var idList = [1, 2, 3];\n    //jQuery的post请求\n    $.post({\n        url: &quot;./params/deleteRoles.do&quot;,\n        //将JSON转化为字符串传递\n        data: JSON.stringify(idList),\n        //指定传递数据类型，不可缺少\n        contentType: &quot;application/json&quot;,\n        //成功后的方法\n        success: function (result) {\n        }\n    });\n});\n</code></pre>\n<p>通过JSON的字符串化将参数传递到后台，这个时候就可以接收参数了，代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/deleteRoles&quot;)\npublic ModelAndView deleteRoles(@RequestBody List&lt;Long&gt; idList) {\n    ModelAndView mv = new ModelAndView();\n    //删除角色\n    int total = roleService.deleteRoles(idList);\n    mv.addObject(&quot;total&quot;, total);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n</code></pre>\n<p>这里注解<a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a>表示要求Spring MVC将传递过来的JSON数组数据，转换为对应的Java集合类型。把List转化为数组（Long[]）也是可行的，但是这里的参数只是一个非常简单的长整型，而在实际开发中也许要传递多个角色用于保存，这也是没问题的，修改JavaScript代码，代码如下：</p>\n<pre><code class=\"lang-javascript\">$(document).ready(function () {\n    //新增角色数组\n    var roleList = [\n        {roleName: &#39;role_name_1&#39;, note: &#39;note_1&#39;},\n        {roleName: &#39;role_name_2&#39;, note: &#39;note_2&#39;},\n        {roleName: &#39;role_name_3&#39;, note: &#39;note_3&#39;}\n    ];\n    //jQuery的post请求\n    $.post({\n        url: &quot;./params/addRoles.do&quot;,\n        //将JSON转化为字符串传递\n        data: JSON.stringify(roleList),\n        contentType: &quot;application/json&quot;,\n        //成功后的方法\n        success: function (result) {\n        }\n    });\n});\n</code></pre>\n<p>然后，使用<a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a>获取，代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/addRoles&quot;)\n    public ModelAndView addRoles(@RequestBody List&lt;Role&gt; roleList){\n        ModelAndView mv = new ModelAndView();\n        //新增角色\n        int total = roleService.insertRoles(roleList);\n        mv.addObject(&quot;total&quot;,total);\n        mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n        return mv;\n    }\n</code></pre>\n<p>通过表单序列化也可以将表单数据转换为字符串传递给后台，因为一些隐藏表单需要一定的计算，所以我们也需要在用户点击提交按钮后，通过序列化去提交表单。下面的表单就是通过表单序列化提交数据，代码如下：</p>\n<pre><code class=\"lang-javascript\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n        &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;\n        &lt;title&gt;参数&lt;/title&gt;\n        &lt;!-- 加载Query文件--&gt;\n        &lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.2.0.js&quot;&gt;\n        &lt;/script&gt;\n        &lt;script type=&quot;text/javascript&quot;&gt;\n        $(document).ready(function () {\n            $(&quot;#commit&quot;).click(function() {\n                var str = $(&quot;form&quot;).serialize();\n                //提交表单\n                $.post({\n                    url: &quot;./params/commonParamPojo2.do&quot;,\n                    //将form数据序列化，传递给后台，则将数据以roleName=xxx&amp;&amp;note=xxx传递\n                    data: $(&quot;form&quot;).serialize(),\n                    //成功后的方法\n                    success: function (result) {\n                    }\n                });\n            });\n        });\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;form id=&quot;form&quot;&gt;\n            &lt;table&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;角色名称&lt;/td&gt;\n                    &lt;td&gt;&lt;input id=&quot;roleName&quot; name=&quot;roleName&quot; value=&quot;&quot; /&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;备注&lt;/td&gt;\n                    &lt;td&gt;&lt;input id=&quot;note&quot; name=&quot;note&quot; /&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;&lt;/td&gt;\n                    &lt;td align=&quot;right&quot;&gt;&lt;input id=&quot;commit&quot; type=&quot;button&quot; value=&quot;提交&quot; /&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/table&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>由于序列化参数的传递规则变为roleName=xxx&amp;&amp;note=xxx，所以获取参数也是十分容易，代码如下：</p>\n<pre><code class=\"lang-java\"> @RequestMapping(&quot;/commonParamPojo2&quot;)\n    public ModelAndView commonParamPojo2(String roleName, String note) {\n        System.out.println(&quot;roleName=&gt;&quot; + roleName);\n        System.out.println(&quot;note=&gt;&quot; + note);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n</code></pre>\n<p>这样就能获取序列化表单后的参数了。</p>\n<h2 id=\"h2-15-2-\"><a name=\"15.2    重定向\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.2    重定向</h2><p>要将一个角色信息转化为JSON视图的功能，只要传递角色信息给它，它就能将信息转化为视图，代码如下：</p>\n<pre><code class=\"lang-java\">  @RequestMapping(&quot;/showRoleJsonInfo&quot;)\n    public ModelAndView showRoleJsonInfo(Long id, String roleName, String note) {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n        mv.addObject(&quot;id&quot;, id);\n        mv.addObject(&quot;roleName&quot;, roleName);\n        mv.addObject(&quot;note&quot;, note);\n        return mv;\n    }\n</code></pre>\n<p>现在的需求是，每当新增一个角色信息时，需要将其数据（因为角色编号会回填）以JSON视图的形式展示给请求者。在数据保存到数据库后，由数据库返回角色编号，再将角色信息传递给showRoleJsonInfo方法，就可以展示JSON视图给请求者了，代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/addRole&quot;)\n//Model为重定向数据模型，Spring MVC会自动初始化它\npublic String addRole(Model model, String roleName, String note) {\n    Role role = new Role();\n    role.setRoleName(roleName);\n    role.setNote(note);\n    //插入角色后，会回填角色编号\n    roleService.insertRole(role);\n    //绑定重定向数据模型\n    model.addAttribute(&quot;roleName&quot;, roleName);\n    model.addAttribute(&quot;note&quot;, note);\n    model.addAttribute(&quot;id&quot;, role.getId());\n    return &quot;redirect:./showRoleJsonInfo.do&quot;;\n}\n</code></pre>\n<p>这里Model代表一个数据模型，可以给它附上对应的数据模型，然后通过返回字符串来实现重定向的功能。Spring MVC约定，当返回的字符串带有redirect的时候，他就会认为需要的是一个重定向，而事实上，不仅可以通过返回字符串来实现重定向，也可以通过返回视图来实现重定向。代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/addRole2&quot;)\npublic ModelAndView addRole2(ModelAndView mv, String roleName, String note) {\n    Role role = new Role();\n    role.setRoleName(roleName);\n    role.setNote(note);\n    //插入角色后，会回填角色编号\n    roleService.insertRole(role);\n    //绑定重定向数据模型\n    mv.addObject(&quot;roleName&quot;, roleName);\n    mv.addObject(&quot;note&quot;, note);\n    mv.addObject(&quot;id&quot;, role.getId());\n    mv.setViewName(&quot;redirect:./showRoleJsonInfo.do&quot;);\n    return mv;\n}\n</code></pre>\n<p>这里只是传递一些简单的参数，有时需要传递角色POJO来完成任务，而不是一个个字段的传递，比如把获取角色信息JSON视图的代码改写为如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/showRoleJsonInfo2&quot;)\npublic ModelAndView showRoleJsonInfo(Role role) {\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    mv.addObject(&quot;role&quot;, role);\n    return mv;\n}\n</code></pre>\n<p>显然这样会比原来的转化方式要简洁得多，但在URL重定向的过程中，并不能有效传递对象，因为HTTP的重定向参数是以字符串传递的。这时Spring MVC提供了另外的一个办法——flash属性，你需要提供的数据模型是一个RedirectAttribute，实现如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/addRole3&quot;)\npublic String addRole3(RedirectAttributes ra, Role role) {\n    //插入角色后，会回填角色编号\n    roleService.insertRole(role);\n    //绑定重定向数据模型\n    ra.addFlashAttribute(role);\n    return &quot;redirect:./showRoleJsonInfo.do&quot;;\n}\n</code></pre>\n<p>这样就能传递POJO对象给下一个地址了。使用addFlashAttribute方法后，Spring MVC会将数据保存到Session中（Session在一个会话期有效），重定向后就会将其清除，这样就能传递数据给下一个地址了。</p>\n<h2 id=\"h2-15-3-\"><a name=\"15.3    保存并获取属性参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.3    保存并获取属性参数</h2><p>在Java EE的基础学习中，有时我们会暂存数据到HTTP的request对象或者Session对象中，在开发控制器时，有时也需要使用这些对象来保存或获取数据。Spring MVC提供了相关支持，它的注解有3个：<a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a>、<a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\">@SessionAttribute</a>和<a href=\"https://github.com/SessionAttributes\" title=\"&#64;SessionAttributes\" class=\"at-link\">@SessionAttributes</a>，它们的作用如下：</p>\n<ul>\n<li><a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a>获取HTTP的请求（request）对象属性值，用于传递给控制器的参数。</li><li><p><a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\"><a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\">@SessionAttribute</a></a>获取HTTP的请求（Session）对象属性值，用于传递给控制器的参数。</p>\n</li><li><p><a href=\"https://github.com/SessionAttributes\" title=\"&#64;SessionAttributes\" class=\"at-link\"><a href=\"https://github.com/SessionAttributes\" title=\"&#64;SessionAttributes\" class=\"at-link\">@SessionAttributes</a></a>,可以给它配置一个字符串数组，这个数组对应的是数据模型对应的键值对，然后将这些键值对保存到Session中。</p>\n</li></ul>\n<p>对于<a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a>这个注解，因为在请求的范围内，Spring MVC更希望你使用它所提供的数据模型。他的数据模型本身就是在请求的生命周期中存在。</p>\n<h3 id=\"h3-15-3-1-requestattribute\"><a name=\"15.3.1    注解@RequestAttribute\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.3.1    注解<a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a></h3><p><a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a>主要的作用是从HTTP的request对象中取出请求属性，只是它的范围周期是在一次请求中存在，首先创建一个JSP文件，代码如下：</p>\n<pre><code class=\"lang-html\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; \n    &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n        &lt;title&gt;Insert title here&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;%\n       //设置请求属性\n       request.setAttribute(&quot;id&quot;, 11L);\n       //转发给控制器\n       request.getRequestDispatcher(&quot;./attribute/requestAttribute.do&quot;).forward(request, response);\n       %&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>然后，用控制器AttributeController处理它，并且使用<a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a>获取对应属性，代码如下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/attributes&quot;)\npublic class AttributeController {\n    @Autowired\n    private RoleService roleService;\n\n    public ModelAndView reqAttr(@RequestAttribute(&quot;id&quot;) Long id) {\n        ModelAndView mv = new ModelAndView();\n        Role role = roleService.getRole(id);\n        mv.addObject(&quot;role&quot;, role);\n        mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n        return mv;\n    }\n}\n</code></pre>\n<p>显然通过JSP的跳转就会转发到这个控制器的reqAttr方法，在参数中使用了<a href=\"https://github.com/RequestAttribute\" title=\"&#64;RequestAttribute\" class=\"at-link\">@RequestAttribute</a>注解，这样就能获取请求的id属性了。</p>\n<h3 id=\"h3-15-3-2-sessionattribute-sessionattributes\"><a name=\"15.3.2    注解@SessionAttribute和注解@SessionAttributes\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.3.2    注解<a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\">@SessionAttribute</a>和注解<a href=\"https://github.com/SessionAttributes\" title=\"&#64;SessionAttributes\" class=\"at-link\">@SessionAttributes</a></h3><p>在控制器中可以使用注解<a href=\"https://github.com/SessionAttributes\" title=\"&#64;SessionAttributes\" class=\"at-link\">@SessionAttributes</a>来设置对应的键值对，不过这个注解只能标注类，不能标注方法或参数。它可以配置属性名称或者属性类型。它的作用是当类使用了该注解后，Spring MVC执行完控制器的逻辑后，将数据模型中对应的属性名称或者属性类型保存到HTTP的Session对象中。</p>\n<p>下面对AttributeController进行改造，代码如下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/attributes&quot;)\n//可以配置数据模型的名称和类型，两者取或关系\n@SessionAttributes(names = {&quot;id&quot;}, types = {Role.class})\npublic class AttributeController {\n    @Autowired\n    private RoleService roleService;\n\n       ...\n\n    @RequestMapping(&quot;/sessionAttributes&quot;)\n    public ModelAndView sessionAttrs(Long id) {\n        ModelAndView mv = new ModelAndView();\n        Role role = roleService.getRole(id);\n        //根据类型，Session将会保存角色信息\n        mv.addObject(&quot;role&quot;, role);\n        //根据名称，Session将会保存id\n        mv.addObject(&quot;id&quot;, id);\n        //视图名称，定义跳转到一个JSP文件上\n        mv.setViewName(&quot;sessionAttribute&quot;);\n        return mv;\n    }\n\n}\n</code></pre>\n<p>这时请求/attribute/sessionAttributes.do?id=1，然后通过JSP文件去验证<a href=\"https://github.com/SessionAttributes\" title=\"&#64;SessionAttributes\" class=\"at-link\">@SessionAttributes</a>配置是否有效，代码如下：</p>\n<pre><code class=\"lang-html\">&lt;%@ page language=&quot;java&quot; import=&quot;com.ssm.chapter15.pojo.Role&quot; contentType=&quot;text/html; charset=UTF-8&quot;\n         pageEncoding=&quot;UTF-8&quot; %&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;\n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n    &lt;title&gt;session&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;%\n    Role role = (Role) session.getAttribute(&quot;role&quot;);\n    out.println(&quot;id = &quot; + role.getId() + &quot;&lt;/p&gt;&quot;);\n    out.println(&quot;roleName = &quot; + role.getRoleName() + &quot;&lt;/p&gt;&quot;);\n    out.println(&quot;note = &quot; + role.getNote() + &quot;&lt;/p&gt;&quot;);\n\n    Long id = (Long)session.getAttribute(&quot;id&quot;);\n    out.println(&quot;id = &quot; + id + &quot;&lt;/p&gt;&quot;);\n%&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这样就可以不使用Servlet API提供了Session对象了，有利于测试和维护。Spring MVC还提供了<a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\">@SessionAttribute</a>来读取Session属性。</p>\n<p>首先创建一个JSP文件，保存Session属性，代码如下：</p>\n<pre><code class=\"lang-html\">&lt;%@ page language=&quot;java&quot; import=&quot;com.ssm.chapter15.pojo.Role&quot; contentType=&quot;text/html; charset=UTF-8&quot;\n         pageEncoding=&quot;UTF-8&quot; %&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;\n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n    &lt;title&gt;session&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%\n        //设置Session属性\n        session.setAttribute(&quot;id&quot;, 1L);\n        //执行跳转\n        response.sendRedirect(&quot;./attribute/sessionAttribute.do&quot;);\n    %&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>然后在控制器AttributeController上加入对应方法，实现通过注解<a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\">@SessionAttribute</a>获取Session属性，代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/sessionAttribute&quot;)\npublic ModelAndView sessionAttr(@SessionAttribute(&quot;id&quot;) Long id){\n    ModelAndView mv = new ModelAndView();\n    Role role = roleService.getRole(id);\n    mv.addObject(&quot;role&quot;,role);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n</code></pre>\n<p>和<a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a>一样，<a href=\"https://github.com/SessionAttribute\" title=\"&#64;SessionAttribute\" class=\"at-link\">@SessionAttribute</a>注解的参数默认不可以为空。</p>\n<h3 id=\"h3-15-3-3-cookievalue-requestheader\"><a name=\"15.3.3    注解@CookieValue和注解@RequestHeader\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.3.3    注解<a href=\"https://github.com/CookieValue\" title=\"&#64;CookieValue\" class=\"at-link\">@CookieValue</a>和注解<a href=\"https://github.com/RequestHeader\" title=\"&#64;RequestHeader\" class=\"at-link\">@RequestHeader</a></h3><p>从名称而言，这两个注解很明确，就是从Cookie和HTTP请求头获取对应的请求信息。对于Cookie而言，需要考虑到用户是可以禁用的。使用实例代码如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/getHeaderAndCookie&quot;)\npublic String testHeaderAndCookie(@RequestHeader(value = &quot;User-Agent&quot;, required = false, defaultValue = &quot;attribute&quot;) String userAgent,\n                                  @CookieValue(value = &quot;JSESSIONID&quot;, required = true, defaultValue = &quot;MyJsessionId&quot;) String JsessionId) {\n    System.out.println(&quot;User-Agent: &quot; + userAgent);\n    System.out.println(&quot;JSESSIONID: &quot; + JsessionId);\n    return &quot;index&quot;;\n}\n</code></pre>\n<p>这里演示了从HTTP请求头和Cookie中读取信息。</p>\n<h2 id=\"h2-15-4-\"><a name=\"15.4    拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.4    拦截器</h2><p>拦截器允许在执行处理器前后进行操作，甚至是在渲染视图后进行操作。Spring MVC会在启动期间通过<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>注解解析URI和处理器的关系，在运行的时候突发请求找到对应的HandlerMapping，然后构建HanderExecutionChain对象，它是一个执行的责任链对象。</p>\n<h3 id=\"h3-15-4-1-\"><a name=\"15.4.1    拦截器的定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.4.1    拦截器的定义</h3><p>Spring要求处理器的拦截器继承HandlerInterceptorAdapter，这个类定义了三个方法，代码如下：</p>\n<pre><code class=\"lang-java\">public class RoleInterceptor1 extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.err.println(&quot;preHandle1&quot;);\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.err.println(&quot;postHandle1&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.err.println(&quot;afterCompletion1&quot;);\n    }\n\n}\n</code></pre>\n<ul>\n<li>preHandle方法：在处理器之前执行的前置方法，这样Spring MVC可以在进入处理器前处理一些方法。注意，它将返回一个boolean值，会影响到后面Spring MVC的流程。</li><li>postHandle方法：在处理器之后执行的后置方法，处理器的逻辑完成后运行它。</li><li>afterCompletion方法：无论是否产生异常都会在渲染视图后执行的方法。</li></ul>\n<h3 id=\"h3-15-4-2-\"><a name=\"15.4.2    拦截器的执行流程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.4.2    拦截器的执行流程</h3><p>一个拦截器的流程如图：</p>\n<p><img src=\"http://cdn.alanliang.site/note/拦截器执行流程.jpg\" alt=\"拦截器执行流程\"></p>\n<p>注意，当前置方法返回false时，就不会执行后面的逻辑了。</p>\n<h3 id=\"h3-15-4-3-\"><a name=\"15.4.3    开发拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.4.3    开发拦截器</h3><p>注意，当XML配置文件加入了元素\\&lt;mvc:annotation-driven\\&gt;或者使用Java配置使用注解<a href=\"https://github.com/EnableWebMvc\" title=\"&#64;EnableWebMvc\" class=\"at-link\">@EnableWebMvc</a>时，系统就会初始化拦截器ConversionServiceExposingInterceptor，它是一个开始就被Spring MVC默认加载的拦截器，它的主要作用是根据配置在控制器上的注解来完成对应的功能。Spring MVC提供的公共拦截器HandlerInterceptorAdapter。下面完成一个角色拦截器，它只是一个简单的测试，代码如下：</p>\n<pre><code class=\"lang-java\">public class RoleInterceptor extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.err.println(&quot;preHandle&quot;);\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.err.println(&quot;postHandle&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, \n             Object handler, Exception ex) throws Exception {\n        System.err.println(&quot;afterCompletion&quot;);\n    }\n\n}\n</code></pre>\n<p>还需要进一步配置它才能使用。在Spring MVC的配置文件（比如dispatcher-servlet.xml）中加入代码:</p>\n<pre><code class=\"lang-xml\">&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/role/*.do&quot;/&gt;\n        &lt;bean class=&quot;com.ssm.chapter15.interceptor.RoleInterceptor&quot;/&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre>\n<p>用元素\\&lt;mvc:interceptors\\&gt;配置拦截器，在它里面可以配置多个拦截器。上述代码配置了一个角色拦截器，把class配置指定为开发的拦截器而元素\\&lt;mvc:mapping\\&gt;的属性path则告诉Spring MVC拦截什么请求，它使用了一个正则表达式匹配。 </p>\n<h3 id=\"h3-15-4-4-\"><a name=\"15.4.4    多个拦截器执行的顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.4.4    多个拦截器执行的顺序</h3><p>先创建3个角色拦截器，代码如下：</p>\n<pre><code class=\"lang-java\">public class RoleInterceptor1 extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.err.println(&quot;preHandle1&quot;);\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.err.println(&quot;postHandle1&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.err.println(&quot;afterCompletion1&quot;);\n    }\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class RoleInterceptor2 extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.err.println(&quot;preHandle2&quot;);\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.err.println(&quot;postHandle2&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.err.println(&quot;afterCompletion2&quot;);\n    }\n\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class RoleInterceptor3 extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        System.err.println(&quot;preHandle3&quot;);\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n            ModelAndView modelAndView) throws Exception {\n        System.err.println(&quot;postHandle3&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        System.err.println(&quot;afterCompletion3&quot;);\n    }\n\n}\n</code></pre>\n<p>修改配置文件，将这些拦截器按顺序配置，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/role/*.do&quot; /&gt;\n        &lt;bean class=&quot;com.ssm.chapter15.interceptor.RoleInterceptor1&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/role/*.do&quot; /&gt;\n        &lt;bean class=&quot;com.ssm.chapter15.interceptor.RoleInterceptor2&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;/role/*.do&quot; /&gt;\n        &lt;bean class=&quot;com.ssm.chapter15.interceptor.RoleInterceptor3&quot; /&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre>\n<p>测试结果如下：</p>\n<pre><code>......\npreHandle1\npreHandle2\npreHandle3\n......控制器逻辑日志......\npostHandle3\npostHandle2\npostHandle1\n......\nafterCompletion3\nafterCompletion2\nafterCompletion1\n......\n</code></pre><p>结果与责任链模式的运行顺序一致。</p>\n<h2 id=\"h2-15-5-\"><a name=\"15.5    验证表单\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.5    验证表单</h2><p>在实际开发中，获得数据后的第一步就是检验数据的正确性，一般会通过注解校验，发现错误后返回给用户，但是对于一些逻辑上的错误，比如购买金额=购买数量*单价，这样的规则就很难使用注解验证，这时可以使用Spring提供的验证器（Validator）规则去验证。</p>\n<h3 id=\"h3-15-5-1-jsr-303-\"><a name=\"15.5.1    使用JSR 303注解验证输入内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.5.1    使用JSR 303注解验证输入内容</h3><p>Spring提供了对Bean的功能校验，通过注解<a href=\"https://github.com/Valid\" title=\"&#64;Valid\" class=\"at-link\">@Valid</a>标明哪个Bean需要启用注解式的验证。在javax.validation.constrants.*中定义了一系列的JSR 303规范给出的注解，规则可查看<a href=\"https://www.jianshu.com/p/89d3cf1eaf14，为了使用这些注解，假设要完成一个交易表单，代码如下：\">https://www.jianshu.com/p/89d3cf1eaf14，为了使用这些注解，假设要完成一个交易表单，代码如下：</a></p>\n<pre><code class=\"lang-html\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;\n         pageEncoding=&quot;UTF-8&quot;%&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;\n    &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n        &lt;title&gt;validate&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n        &lt;form action = &quot;./validate/annotation.do&quot;&gt; \n        &lt;!-- \n        &lt;form action = &quot;./validate/validator.do&quot;&gt;\n        --&gt;\n            &lt;table&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;产品编号：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;productId&quot; id=&quot;productId&quot;/&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;用户编号：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;userId&quot; id=&quot;userId&quot;/&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;交易日期：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;date&quot; id=&quot;date&quot;/&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;价格：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;price&quot; id=&quot;price&quot;/&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;数量：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;quantity&quot; id=&quot;quantity&quot;/&gt; &lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;交易金额：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;amount&quot; id=&quot;amount&quot;/&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;用户邮件：&lt;/td&gt;\n                    &lt;td&gt;&lt;input name=&quot;email&quot; id=&quot;email&quot;/&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;备注：&lt;/td&gt;\n                    &lt;td&gt;&lt;textarea id=&quot;note&quot;  name=&quot;note&quot; cols=&quot;20&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;&lt;td colspan=&quot;2&quot; align=&quot;right&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/tr&gt;\n            &lt;/table&gt;\n        &lt;form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>假设数据需要满足如下规则：</p>\n<ul>\n<li>产品编号、用户编号、交易日期、价格、数量、交易金额不能为空。</li><li>交易日期格式为yyyy-MM-dd，且只能在未来。</li><li>价格最小值为0.1。</li><li>数量是一个整数，且最小值为1，最大值为100。</li><li>交易金额最小值为1，最大值为5万。</li><li>用户邮件需要满足邮件正则式。</li><li>备注内容不得多于256个字符。</li></ul>\n<p>创建一个POJO，如下：</p>\n<pre><code class=\"lang-java\">public class Transaction {\n    // 产品编号\n    @NotNull // 不能为空\n    private Long productId;\n\n    // 用户编号\n    @NotNull // 不能为空\n    private Long userId;\n\n    // 交易日期\n    @Future // 只能是将来的日期\n    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) // 日期格式化转换\n    @NotNull // 不能为空\n    private Date date;\n\n    // 价格\n    @NotNull // 不能为空\n    @DecimalMin(value = &quot;0.1&quot;) // 最小值0.1元\n    private Double price;\n\n    // 数量\n    @Min(1) // 最小值为1\n    @Max(100) // 最大值\n    @NotNull // 不能为空\n    private Integer quantity;\n\n    // 交易金额\n    @NotNull // 不能为空\n    @DecimalMax(&quot;500000.00&quot;) // 最大金额为5万元\n    @DecimalMin(&quot;1.00&quot;) // 最小交易金额1元\n    private Double amount;\n\n    // 邮件\n    @Pattern(// 正则式\n            regexp = &quot;^([a-zA-Z0-9]*[-_]?[a-zA-Z0-9]+)*@&quot;\n                    + &quot;([a-zA-Z0-9]*[-_]?[a-zA-Z0-9]+)+[\\\\.][A-Za-z]{2,3}([\\\\.][A-Za-z]{2})?$&quot;,\n            // 自定义消息提示\n            message = &quot;不符合邮件格式&quot;)\n    private String email;\n\n    // 备注\n    @Size(min = 0, max = 256) // 0到255个字符\n    private String note;\n}\n</code></pre>\n<p>这样就可以给每一个字段加入对应校验，它会生成默认的错误信息。在邮件的检验中，还使用了配置项message来重新定义了当校验失败后的错误信息，这样就能够启动Spring的校验规则来校验表单了。</p>\n<p>用控制器完成表单验证，代码如下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/validate&quot;)\npublic class ValidateController {\n\n    @RequestMapping(&quot;/annotation&quot;)\n    public ModelAndView annotationValidate(@Valid Transaction trans, Errors errors) {\n        // 是否存在错误\n        if (errors.hasErrors()) {\n            // 获取错误信息\n            List&lt;FieldError&gt; errorList = errors.getFieldErrors();\n            for (FieldError error : errorList) {\n                // 打印字段错误信息\n                System.err.println(&quot;fied :&quot; + error.getField() + &quot;\\t&quot; + &quot;msg:&quot; + error.getDefaultMessage());\n            }\n        }\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(&quot;index&quot;);\n        return mv;\n    }\n}\n</code></pre>\n<p>使用注解<a href=\"https://github.com/Valid\" title=\"&#64;Valid\" class=\"at-link\">@Valid</a>标明这个Bean将会被检验，而另外一个类型为Errors的参数则是用于保存是否存在错误信息的。</p>\n<p>有时检验并不简单，它可能还有其他一些复杂的规则。比如，交易日期往往就不是一个应该录入的数据，而是系统提取当前日期。又如规则：交易金额=数量*价格，这样又需要其他的一些验证规则了，Spring提供了验证框架。</p>\n<h3 id=\"h3-15-5-2-\"><a name=\"15.5.2    使用验证器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.5.2    使用验证器</h3><p>有时除了简单的输入格式、非空性等校验，也需要一定的业务校验，Spring提供了Validator接口来实现检验，它将在进入控制器逻辑之前对参数的合法性进行校验。</p>\n<p>Validator接口定义如下：</p>\n<pre><code class=\"lang-java\">public interface Validator {\n    /**\n    *判断当前验证器是否用于校验clazz类型的POJO\n    *@param clazz --POJO类型\n    *@return true启动校验，false则不再校验\n    */\n    boolean supports(Class&lt;?&gt; clazz);\n\n    /**\n    *检验POJO的合法性\n    *@param target POJO请求对象\n    *@param errors 错误信息\n    */\n    void validate(Object target, Errors errors);\n}\n</code></pre>\n<p>下面进行一项验证，要求：交易金额=价格*数量，代码如下：</p>\n<pre><code class=\"lang-java\">public class TransactionValidator implements Validator {\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) {\n        //判断验证是否为Transaction，如果是则进行判断[修改为：验证]\n        return Transaction.class.equals(clazz);\n    }\n\n    @Override\n    public void validate(Object target, Errors errors) {\n        Transaction trans = (Transaction) target;\n        //求交易金额和价格×数量的差额\n        double dis = trans.getAmount() - (trans.getPrice() * trans.getQuantity());\n        //如果差额大于0.01，则认为业务错误\n        if (Math.abs(dis) &gt; 0.01) {\n            //加入错误信息\n            errors.rejectValue(&quot;amount&quot;, null, &quot;交易金额和购买数量与价格不匹配&quot;);\n        }\n    }\n}\n</code></pre>\n<p>这样这个验证器就判断了是否为Transaction对象，如果是就去验证后面的逻辑，那么要将它捆绑到对应的控制器中，这时Spring MVC提供了注解<a href=\"https://github.com/initBinder\" title=\"&#64;initBinder\" class=\"at-link\">@initBinder</a>。在ValidateController中添加代码，代码如下：</p>\n<pre><code class=\"lang-java\">@InitBinder\npublic void initBinder(DataBinder binder) {\n    // 数据绑定器加入验证器\n    binder.setValidator(new TransactionValidator());\n}\n\n@RequestMapping(&quot;/validator&quot;)\npublic ModelAndView validator(@Valid Transaction trans, Errors errors) {\n    // 是否存在错误\n    if (errors.hasErrors()) {\n        // 获取错误信息\n        List&lt;FieldError&gt; errorList = errors.getFieldErrors();\n        for (FieldError error : errorList) {\n            // 打印字段错误信息\n            System.err.println(&quot;fied :&quot; + error.getField() + &quot;\\t&quot; + &quot;msg:&quot; + error.getDefaultMessage());\n        }\n    }\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(&quot;index&quot;);\n    return mv;\n}\n</code></pre>\n<p>注解<a href=\"https://github.com/Valid\" title=\"&#64;Valid\" class=\"at-link\">@Valid</a>就是为了启动这个验证器，而参数Errors则是记录验证器返回错误信息的。</p>\n<p>比较遗憾的是，JSR303注解方式和验证器不能同时使用，不过可以在使用JSR303注解方式得到基本的校验信息后，再使用自己得方法进行验证。</p>\n<h2 id=\"h2-15-6-\"><a name=\"15.6    数据模型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.6    数据模型</h2><p>视图是业务处理后展现给用户的内容，不过一般伴随着业务处理返回的数据，用来给用户查看。在此之前，我们一直使用ModelAndView来定义视图类型，包括JSON视图，也用它来加载数据模型，ModelAndView有一个类型为ModelMap的属性model，而ModelMap继承了LinkedHashMap，因此用它可以存放各种键值对。</p>\n<p>在控制器的方法中，可以把ModelAndView、Model、ModelMap作为参数。在Spring MVC，三者可以相互转换。</p>\n<h3 id=\"h3-15-7-\"><a name=\"15.7    视图和视图解析器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.7    视图和视图解析器</h3><p>视图是展示给用户的内容，而在此之前，要通过控制器得到对应的数据模型，如果是非逻辑视图，则不会经过视图解析器定位视图，而是直接渲染数据模型便结束了；而逻辑视图则要对其进一步解析，已定位真实视图，这就是视图解析器的作用。</p>\n<h3 id=\"h3-15-7-1-\"><a name=\"15.7.1    视图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15.7.1    视图</h3><p>为了满足各种需求，在Spring MVC中定义了多种视图，绑定到数据模型中，那么视图就可以展示数据模型的信息了。只是常用的并不多。它们都要实现接口——View，代码如下：</p>\n<pre><code class=\"lang-java\">public interface View {\n    //响应状态属性\n    String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + &quot;.responseStatus&quot;;\n    //定义数据模型下取出变量路径\n    String PATH_VARIABLES = View.class.getName() + &quot;.pathVariables&quot;;\n    //选择响应内容类型\n    String SELECTED_CONTENT_TYPE = View.class.getName() + &quot;.selectedContentType&quot;;\n    //选择响应客户端的类型\n    String getContentType();\n    //渲染方法，model是数据模型\n    void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;\n\n}\n</code></pre>\n<p>注意getContentType方法和render方法。getContentType表示返回一个字符串，标明给用户什么类型的文件响应、可以是HTML、JSON、PDF等。而render方法则是一个渲染视图的方法，其中Model是数据模型，HTPP请求对象和响应对象用于处理HTP请求的各类问题。</p>\n<p>当控制器返回ModelAndView时，视图解析器就会解析它，然后将数据模型传递给render方法，这样就能渲染视图了。在Spring MVC中实现视图的类很多，比如JSTL视图JstlView，JSON视图MappingJackon2JsonView，PDF视图AbstractPdfView等，通过它们的render方法，Spring MVC就可以将数据模型渲染成各类视图，以满足各种需求。</p>\n<p>视图又分为逻辑视图和非逻辑视图，比如MappingJackon2JsonView是一个非逻辑视图，它的目的就是将数据模型转换为一个JSON视图，展现给用户，，无须对视图名字再进行下一步解析，比如下面代码：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/RequestAttribute&quot;)\npublic ModelAndView reqAttr(@RequestAttribute(&quot;id&quot;) Long id) {\n    ModelAndView mv = new ModelAndView();\n    Role role = roleService.getRole(id);\n    mv.addObject(&quot;role&quot;, role);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n</code></pre>\n<p>MappingJackon2JsonView在没有视图解析器的情况下可以进行渲染，最终将其绑定的数据模型转换了JSON数据。</p>\n<p>InternalResourceView是一个逻辑视图，对于逻辑视图而言它需要一个视图解析器，常见配置如下：</p>\n<pre><code class=\"lang-xml\">&lt;!-- 找到Web工程/WEB-INF/JSP文件夹，且文件结尾为jsp的文件作为映射 --&gt;\n&lt;bean id=&quot;viewResolver&quot;\n      class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;\n      p:prefix=&quot;/WEB-INF/jsp/&quot; p:suffix=&quot;.jsp&quot; /&gt;\n</code></pre>\n<p>通过前缀和后缀加上视图名称就能找到对应的JSP文件，然后把数据模型渲染到JSP文件中，这样便能展示视图给用户了。</p>\n', '## 15.1	控制器接收各类请求参数\n\n为了应付多种传递参数的方式，先探索Spring MVC的传参方法。\n\n为此先创建一个接收各类参数的控制器——ParamsController，代码如下：\n\n```java\n@Controller\n@RequestMapping(\"/params\")\npublic class ParamsController {\n    //待开发代码\n}\n```\n\n然后，将在接收参数控制器的基础上增加方法来演示如何接收各类参数，以角色表单为例，内容如下：\n\n```html\n<html>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <title>参数</title>\n        <!-- 加载Query文件-->\n        <script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-3.2.0.js\">\n        </script>\n        <script type=\"text/javascript\">\n      	<!--\n        	此处插入JavaScript脚本\n            -->\n        </script>\n    </head>\n    <body>\n        <form id=\"form\">\n            <table>\n                <tr>\n                    <td>角色名称</td>\n                    <td><input id=\"roleName\" name=\"roleName\" value=\"\" /></td>\n                </tr>\n                <tr>\n                    <td>备注</td>\n                    <td><input id=\"note\" name=\"note\" /></td>\n                </tr>\n                <tr>\n                    <td></td>\n                    <td align=\"right\"><input id=\"commit\" type=\"button\" value=\"提交\" /></td>\n                </tr>\n            </table>\n        </form>\n    </body>\n</html>\n```\n\n### 15.1.1	接收普通请求参数\n\n如果传递的参数名称和HTTP的保存一致，那么无需任何注解也可以获取参数。以上表单传递了两个HTTP参数：角色名称和备注，响应的请求是\"./params/commonParams.do\"，也就是提交表单后，它就会请求对应的URL。\n\n首先，在ParamsController增加对应的方法并获取参数，以下代码就是一个无注解获取HTTP请求参数的代码。\n\n```java\n @RequestMapping(\"/commonParams\")\n    public ModelAndView commonParams(String roleName, String note) {\n        System.out.println(\"roleName=>\" + roleName);\n        System.out.println(\"note=>\" + note);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n```\n\n通过参数名称和HTTP请求参数名称一致来获取参数，如果不一致将无法获取，这样的方式允许参数为空。\n\n但是，在参数很多的情况下，比如新增一个用户可能需要十几个字段，这时应该考虑使用一个POJO来管理这些参数。在没有任何注解的情况下，Spring MVC也有映射POJO的能力。新建一个角色参数类，代码如下：\n\n```java\npublic class RoleParams {\n	private String roleName;\n	private String note;\n	/*getter and setter*/\n}\n```\n\n然后，在ParamController中增加一个方法来通过这个POJO获取HTTP请求参数，代码如下：\n\n```java\n @RequestMapping(\"/commonParamsPojo\")\n    public ModelAndView commonParamsPojo(RoleParams roleParams) {\n        System.out.println(\"roleName=>\" + roleParams.getRoleName());\n        System.out.println(\"note=>\" + roleParams.getNote());\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n```\n\n显然通过POJO也会获取到对应参数，需要注意的是POJO的属性名称也要和HTTP请求参数名称保持一致。但是有时候前端的参数命名规则和后台的不一样，比如前端把角色名称的参数命名为role_name，这时就要进行转换了。\n\n### 15.1.2	使用@RequestParam注解获取参数\n\nSpring MVC提供了@RequestParam注解来解决前后端参数名称命名不一致的问题。\n\n把HTTP的参数名称从roleName修改为role_name，那么需要重新绑定规则，此时使用@RequestParam注解，代码如下：\n\n```java\n @RequestMapping(\"/requestParam\")\n    public ModelAndView requestParam(@RequestParam(\"role_name\")String roleName,\n                                     @RequestParam(\"note\") String note){\n        System.out.println(\"roleName=>\" + roleName);\n        System.out.println(\"note=>\" + note);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n```\n\n### 15.1.3	使用URL传递参数\n\n一些网站使用URL形式传递参数，这样符合RESTful风格，对于一些业务比较简单的应用是非常常见的，比如以下代码，获取一个角色的信息，我们希望把URL写成/params/getRole/1，其中1就是一个参数，代表角色编号。现在写一个方法，它将只支持HTTP的GET请求，通过URL：/params/getRole/1来获取角色并且打印出JSON数据，他需要@RequestMapping和@PathVariable两个注解共同协作完成，代码如下所示：\n\n```java\n//注入RoleService\n@Autowired\nprivate RoleService roleService;\n\n//{id}表示接受一个参数\n@RequestMapping(\"/getRole/{id}\")\n//注解@PathVariable表示从URL的请求地址中获取参数\npublic ModelAndView pathVariable(@PathVariable(\"id\") Long id) {\n    Role role = roleService.getRole(id);\n    ModelAndView mv = new ModelAndView();\n    //绑定数据模型\n    mv.addObject(role);\n    //设置为JSON视图\n    mv.setView(new MappingJackson2JsonView());\n    return mv;\n}\n```\n\n{id}表示处理器需要接受一个由URL组成的参数，且参数名称为id，那么在方法中的@PathVariable(\"id\")表示将获取这个在@RequestMapping中定义名称为id的参数，这样就可以在方法内获取这个参数了。\n\n测试结果如下：\n\n![图15-2 通过URL获取参数](http://cdn.alanliang.site/note/图15-2 通过URL获取参数.png)\n\n### 15.1.4	传递JSON参数\n\n有时候参数的传递还需要更多参数，比如查询可能需要分页参数，这是非常常见的场景。对于查询参数，假设还有开始行start和限制返回大小的limit，由PageParams类传递，代码如下：\n\n```java\npublic class PageParams {\n	private int start;\n	private int limit;\n	/*getter and setter*/\n}\n```\n\n只需要在RoleParams的基础上加上一个PageParams属性就可以使用分页参数了，代码如下：\n\n```java\npublic class RoleParams {\n	private String roleName;\n	private String note;\n    private PageParams pageParams = null;//分页参数\n    /*getter and setter*/\n}\n```\n\n这个查询参数和分页参数都可以被传递了。这时客户端还需要写一段JavaScript代码来模拟这个过程，往表单插入一定JavaScript代码，代码如下：\n\n```javascript\n<script type=\"text/javascript\">\n    $(document).ready(function () {\n    $(\"#commit\").click(function() {\n        var str = $(\"form\").serialize();\n        //提交表单\n        $.post({\n            url: \"./params/commonParamPojo2.do\",\n            //将form数据序列化，传递给后台，则将数据以roleName=xxx&&note=xxx传递\n            data: $(\"form\").serialize(),\n            //成功后的方法\n            success: function (result) {\n            }\n        });\n    });\n});\n</script>\n```\n\n注意，传递的JSON数据需要和对应参数的POJO保持一致。另外，在请求时需要告知请求的参数类型为JSON，这是不可缺少的，传递的参数是一个字符串，而不是一个JSON，所以这里使用JSON.stringify()方法将JSON数据转换为字符串。\n\n这个时候可以使用Spring MVC提供的注解@RequestBody接收参数，代码如下：\n\n```java\n@RequestMapping(\"/findRoles\")\npublic ModelAndView findRoles(@RequestBody RoleParams roleParams){\n    List<Role> roleList = roleService.findRoles(roleParams);\n    ModelAndView mv = new ModelAndView();\n    mv.addObject(roleList);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n```\n\n### 15.1.5	接收列表数据和表单序列化\n\n在一些场景，如果需要一次性删除多个角色，那么一般将一个角色编号的数组传递给后台，或新增角色，甚至同时新增多个角色。无论如何，这都需要用到Java的集合或者数组来保存对应的参数。\n\nSpring MVC也支持这样的场景，假设要删除多个角色，显然你希望传递一个角色编号的数组给后台处理。通过JavaScript模仿传递角色数组给后台控制器，代码如下：\n\n```javascript\n/**传递数组**/\n$(document).ready(function () {\n    //删除角色数组\n    var idList = [1, 2, 3];\n    //jQuery的post请求\n    $.post({\n        url: \"./params/deleteRoles.do\",\n        //将JSON转化为字符串传递\n        data: JSON.stringify(idList),\n        //指定传递数据类型，不可缺少\n        contentType: \"application/json\",\n        //成功后的方法\n        success: function (result) {\n        }\n    });\n});\n```\n\n通过JSON的字符串化将参数传递到后台，这个时候就可以接收参数了，代码如下：\n\n```java\n@RequestMapping(\"/deleteRoles\")\npublic ModelAndView deleteRoles(@RequestBody List<Long> idList) {\n    ModelAndView mv = new ModelAndView();\n    //删除角色\n    int total = roleService.deleteRoles(idList);\n    mv.addObject(\"total\", total);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n```\n\n这里注解@RequestBody表示要求Spring MVC将传递过来的JSON数组数据，转换为对应的Java集合类型。把List转化为数组（Long[]）也是可行的，但是这里的参数只是一个非常简单的长整型，而在实际开发中也许要传递多个角色用于保存，这也是没问题的，修改JavaScript代码，代码如下：\n\n```javascript\n$(document).ready(function () {\n    //新增角色数组\n    var roleList = [\n        {roleName: \'role_name_1\', note: \'note_1\'},\n        {roleName: \'role_name_2\', note: \'note_2\'},\n        {roleName: \'role_name_3\', note: \'note_3\'}\n    ];\n    //jQuery的post请求\n    $.post({\n        url: \"./params/addRoles.do\",\n        //将JSON转化为字符串传递\n        data: JSON.stringify(roleList),\n        contentType: \"application/json\",\n        //成功后的方法\n        success: function (result) {\n        }\n    });\n});\n```\n\n然后，使用@RequestBody获取，代码如下：\n\n```java\n@RequestMapping(\"/addRoles\")\n    public ModelAndView addRoles(@RequestBody List<Role> roleList){\n        ModelAndView mv = new ModelAndView();\n        //新增角色\n        int total = roleService.insertRoles(roleList);\n        mv.addObject(\"total\",total);\n        mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n        return mv;\n    }\n```\n\n通过表单序列化也可以将表单数据转换为字符串传递给后台，因为一些隐藏表单需要一定的计算，所以我们也需要在用户点击提交按钮后，通过序列化去提交表单。下面的表单就是通过表单序列化提交数据，代码如下：\n\n```javascript\n<html>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n        <title>参数</title>\n        <!-- 加载Query文件-->\n        <script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-3.2.0.js\">\n        </script>\n        <script type=\"text/javascript\">\n        $(document).ready(function () {\n            $(\"#commit\").click(function() {\n            	var str = $(\"form\").serialize();\n            	//提交表单\n            	$.post({\n                    url: \"./params/commonParamPojo2.do\",\n                    //将form数据序列化，传递给后台，则将数据以roleName=xxx&&note=xxx传递\n                    data: $(\"form\").serialize(),\n                    //成功后的方法\n                    success: function (result) {\n                    }\n                });\n            });\n        });\n        </script>\n    </head>\n    <body>\n        <form id=\"form\">\n            <table>\n                <tr>\n                    <td>角色名称</td>\n                    <td><input id=\"roleName\" name=\"roleName\" value=\"\" /></td>\n                </tr>\n                <tr>\n                    <td>备注</td>\n                    <td><input id=\"note\" name=\"note\" /></td>\n                </tr>\n                <tr>\n                    <td></td>\n                    <td align=\"right\"><input id=\"commit\" type=\"button\" value=\"提交\" /></td>\n                </tr>\n            </table>\n        </form>\n    </body>\n</html>\n```\n\n由于序列化参数的传递规则变为roleName=xxx&&note=xxx，所以获取参数也是十分容易，代码如下：\n\n```java\n @RequestMapping(\"/commonParamPojo2\")\n    public ModelAndView commonParamPojo2(String roleName, String note) {\n        System.out.println(\"roleName=>\" + roleName);\n        System.out.println(\"note=>\" + note);\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n```\n\n这样就能获取序列化表单后的参数了。\n\n## 15.2	重定向\n\n要将一个角色信息转化为JSON视图的功能，只要传递角色信息给它，它就能将信息转化为视图，代码如下：\n\n```java\n  @RequestMapping(\"/showRoleJsonInfo\")\n    public ModelAndView showRoleJsonInfo(Long id, String roleName, String note) {\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n        mv.addObject(\"id\", id);\n        mv.addObject(\"roleName\", roleName);\n        mv.addObject(\"note\", note);\n        return mv;\n    }\n```\n\n现在的需求是，每当新增一个角色信息时，需要将其数据（因为角色编号会回填）以JSON视图的形式展示给请求者。在数据保存到数据库后，由数据库返回角色编号，再将角色信息传递给showRoleJsonInfo方法，就可以展示JSON视图给请求者了，代码如下：\n\n```java\n@RequestMapping(\"/addRole\")\n//Model为重定向数据模型，Spring MVC会自动初始化它\npublic String addRole(Model model, String roleName, String note) {\n    Role role = new Role();\n    role.setRoleName(roleName);\n    role.setNote(note);\n    //插入角色后，会回填角色编号\n    roleService.insertRole(role);\n    //绑定重定向数据模型\n    model.addAttribute(\"roleName\", roleName);\n    model.addAttribute(\"note\", note);\n    model.addAttribute(\"id\", role.getId());\n    return \"redirect:./showRoleJsonInfo.do\";\n}\n```\n\n这里Model代表一个数据模型，可以给它附上对应的数据模型，然后通过返回字符串来实现重定向的功能。Spring MVC约定，当返回的字符串带有redirect的时候，他就会认为需要的是一个重定向，而事实上，不仅可以通过返回字符串来实现重定向，也可以通过返回视图来实现重定向。代码如下：\n\n```java\n@RequestMapping(\"/addRole2\")\npublic ModelAndView addRole2(ModelAndView mv, String roleName, String note) {\n    Role role = new Role();\n    role.setRoleName(roleName);\n    role.setNote(note);\n    //插入角色后，会回填角色编号\n    roleService.insertRole(role);\n    //绑定重定向数据模型\n    mv.addObject(\"roleName\", roleName);\n    mv.addObject(\"note\", note);\n    mv.addObject(\"id\", role.getId());\n    mv.setViewName(\"redirect:./showRoleJsonInfo.do\");\n    return mv;\n}\n```\n\n这里只是传递一些简单的参数，有时需要传递角色POJO来完成任务，而不是一个个字段的传递，比如把获取角色信息JSON视图的代码改写为如下：\n\n```java\n@RequestMapping(\"/showRoleJsonInfo2\")\npublic ModelAndView showRoleJsonInfo(Role role) {\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    mv.addObject(\"role\", role);\n    return mv;\n}\n```\n\n显然这样会比原来的转化方式要简洁得多，但在URL重定向的过程中，并不能有效传递对象，因为HTTP的重定向参数是以字符串传递的。这时Spring MVC提供了另外的一个办法——flash属性，你需要提供的数据模型是一个RedirectAttribute，实现如下：\n\n```java\n@RequestMapping(\"/addRole3\")\npublic String addRole3(RedirectAttributes ra, Role role) {\n    //插入角色后，会回填角色编号\n    roleService.insertRole(role);\n    //绑定重定向数据模型\n    ra.addFlashAttribute(role);\n    return \"redirect:./showRoleJsonInfo.do\";\n}\n```\n\n这样就能传递POJO对象给下一个地址了。使用addFlashAttribute方法后，Spring MVC会将数据保存到Session中（Session在一个会话期有效），重定向后就会将其清除，这样就能传递数据给下一个地址了。\n\n## 15.3	保存并获取属性参数\n\n在Java EE的基础学习中，有时我们会暂存数据到HTTP的request对象或者Session对象中，在开发控制器时，有时也需要使用这些对象来保存或获取数据。Spring MVC提供了相关支持，它的注解有3个：@RequestAttribute、@SessionAttribute和@SessionAttributes，它们的作用如下：\n\n- @RequestAttribute获取HTTP的请求（request）对象属性值，用于传递给控制器的参数。\n- @SessionAttribute获取HTTP的请求（Session）对象属性值，用于传递给控制器的参数。\n\n- @SessionAttributes,可以给它配置一个字符串数组，这个数组对应的是数据模型对应的键值对，然后将这些键值对保存到Session中。\n\n对于@RequestAttribute这个注解，因为在请求的范围内，Spring MVC更希望你使用它所提供的数据模型。他的数据模型本身就是在请求的生命周期中存在。\n\n### 15.3.1	注解@RequestAttribute\n\n@RequestAttribute主要的作用是从HTTP的request对象中取出请求属性，只是它的范围周期是在一次请求中存在，首先创建一个JSP文件，代码如下：\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n    \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <title>Insert title here</title>\n    </head>\n    <body>\n       <%\n       //设置请求属性\n       request.setAttribute(\"id\", 11L);\n       //转发给控制器\n       request.getRequestDispatcher(\"./attribute/requestAttribute.do\").forward(request, response);\n       %>\n    </body>\n</html>\n```\n\n然后，用控制器AttributeController处理它，并且使用@RequestAttribute获取对应属性，代码如下：\n\n```java\n@Controller\n@RequestMapping(\"/attributes\")\npublic class AttributeController {\n    @Autowired\n    private RoleService roleService;\n\n    public ModelAndView reqAttr(@RequestAttribute(\"id\") Long id) {\n        ModelAndView mv = new ModelAndView();\n        Role role = roleService.getRole(id);\n        mv.addObject(\"role\", role);\n        mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n        return mv;\n    }\n}\n```\n\n显然通过JSP的跳转就会转发到这个控制器的reqAttr方法，在参数中使用了@RequestAttribute注解，这样就能获取请求的id属性了。\n\n### 15.3.2	注解@SessionAttribute和注解@SessionAttributes\n\n在控制器中可以使用注解@SessionAttributes来设置对应的键值对，不过这个注解只能标注类，不能标注方法或参数。它可以配置属性名称或者属性类型。它的作用是当类使用了该注解后，Spring MVC执行完控制器的逻辑后，将数据模型中对应的属性名称或者属性类型保存到HTTP的Session对象中。\n\n下面对AttributeController进行改造，代码如下：\n\n```java\n@Controller\n@RequestMapping(\"/attributes\")\n//可以配置数据模型的名称和类型，两者取或关系\n@SessionAttributes(names = {\"id\"}, types = {Role.class})\npublic class AttributeController {\n    @Autowired\n    private RoleService roleService;\n\n   	...\n\n    @RequestMapping(\"/sessionAttributes\")\n    public ModelAndView sessionAttrs(Long id) {\n        ModelAndView mv = new ModelAndView();\n        Role role = roleService.getRole(id);\n        //根据类型，Session将会保存角色信息\n        mv.addObject(\"role\", role);\n        //根据名称，Session将会保存id\n        mv.addObject(\"id\", id);\n        //视图名称，定义跳转到一个JSP文件上\n        mv.setViewName(\"sessionAttribute\");\n        return mv;\n    }\n\n}\n```\n\n这时请求/attribute/sessionAttributes.do?id=1，然后通过JSP文件去验证@SessionAttributes配置是否有效，代码如下：\n\n```html\n<%@ page language=\"java\" import=\"com.ssm.chapter15.pojo.Role\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\" %>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>session</title>\n</head>\n<body>\n<%\n    Role role = (Role) session.getAttribute(\"role\");\n    out.println(\"id = \" + role.getId() + \"</p>\");\n    out.println(\"roleName = \" + role.getRoleName() + \"</p>\");\n    out.println(\"note = \" + role.getNote() + \"</p>\");\n\n    Long id = (Long)session.getAttribute(\"id\");\n    out.println(\"id = \" + id + \"</p>\");\n%>\n</body>\n</html>\n```\n\n这样就可以不使用Servlet API提供了Session对象了，有利于测试和维护。Spring MVC还提供了@SessionAttribute来读取Session属性。\n\n首先创建一个JSP文件，保存Session属性，代码如下：\n\n```html\n<%@ page language=\"java\" import=\"com.ssm.chapter15.pojo.Role\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\" %>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>session</title>\n</head>\n<body>\n    <%\n        //设置Session属性\n        session.setAttribute(\"id\", 1L);\n        //执行跳转\n        response.sendRedirect(\"./attribute/sessionAttribute.do\");\n    %>\n</body>\n</html>\n```\n\n然后在控制器AttributeController上加入对应方法，实现通过注解@SessionAttribute获取Session属性，代码如下：\n\n```java\n@RequestMapping(\"/sessionAttribute\")\npublic ModelAndView sessionAttr(@SessionAttribute(\"id\") Long id){\n    ModelAndView mv = new ModelAndView();\n    Role role = roleService.getRole(id);\n    mv.addObject(\"role\",role);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n```\n\n和@RequestParam一样，@SessionAttribute注解的参数默认不可以为空。\n\n### 15.3.3	注解@CookieValue和注解@RequestHeader\n\n从名称而言，这两个注解很明确，就是从Cookie和HTTP请求头获取对应的请求信息。对于Cookie而言，需要考虑到用户是可以禁用的。使用实例代码如下：\n\n```java\n@RequestMapping(\"/getHeaderAndCookie\")\npublic String testHeaderAndCookie(@RequestHeader(value = \"User-Agent\", required = false, defaultValue = \"attribute\") String userAgent,\n                                  @CookieValue(value = \"JSESSIONID\", required = true, defaultValue = \"MyJsessionId\") String JsessionId) {\n    System.out.println(\"User-Agent: \" + userAgent);\n    System.out.println(\"JSESSIONID: \" + JsessionId);\n    return \"index\";\n}\n```\n\n这里演示了从HTTP请求头和Cookie中读取信息。\n\n## 15.4	拦截器\n\n拦截器允许在执行处理器前后进行操作，甚至是在渲染视图后进行操作。Spring MVC会在启动期间通过@RequestMapping注解解析URI和处理器的关系，在运行的时候突发请求找到对应的HandlerMapping，然后构建HanderExecutionChain对象，它是一个执行的责任链对象。\n\n### 15.4.1	拦截器的定义\n\nSpring要求处理器的拦截器继承HandlerInterceptorAdapter，这个类定义了三个方法，代码如下：\n\n```java\npublic class RoleInterceptor1 extends HandlerInterceptorAdapter {\n	\n	@Override\n	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n			throws Exception {\n		System.err.println(\"preHandle1\");\n		return true;\n	}\n\n	@Override\n	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n			ModelAndView modelAndView) throws Exception {\n		System.err.println(\"postHandle1\");\n	}\n\n	@Override\n	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n			throws Exception {\n		System.err.println(\"afterCompletion1\");\n	}\n\n}\n```\n\n- preHandle方法：在处理器之前执行的前置方法，这样Spring MVC可以在进入处理器前处理一些方法。注意，它将返回一个boolean值，会影响到后面Spring MVC的流程。\n- postHandle方法：在处理器之后执行的后置方法，处理器的逻辑完成后运行它。\n- afterCompletion方法：无论是否产生异常都会在渲染视图后执行的方法。\n\n### 15.4.2    拦截器的执行流程\n\n一个拦截器的流程如图：\n\n![拦截器执行流程](http://cdn.alanliang.site/note/拦截器执行流程.jpg)\n\n注意，当前置方法返回false时，就不会执行后面的逻辑了。\n\n### 15.4.3	开发拦截器\n\n注意，当XML配置文件加入了元素\\<mvc:annotation-driven\\>或者使用Java配置使用注解@EnableWebMvc时，系统就会初始化拦截器ConversionServiceExposingInterceptor，它是一个开始就被Spring MVC默认加载的拦截器，它的主要作用是根据配置在控制器上的注解来完成对应的功能。Spring MVC提供的公共拦截器HandlerInterceptorAdapter。下面完成一个角色拦截器，它只是一个简单的测试，代码如下：\n\n```java\npublic class RoleInterceptor extends HandlerInterceptorAdapter {\n	\n	@Override\n	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n			throws Exception {\n		System.err.println(\"preHandle\");\n		return true;\n	}\n\n	@Override\n	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n			ModelAndView modelAndView) throws Exception {\n		System.err.println(\"postHandle\");\n	}\n\n	@Override\n	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, \n             Object handler, Exception ex) throws Exception {\n		System.err.println(\"afterCompletion\");\n	}\n\n}\n```\n\n还需要进一步配置它才能使用。在Spring MVC的配置文件（比如dispatcher-servlet.xml）中加入代码:\n\n```xml\n<mvc:interceptors>\n    <mvc:interceptor>\n        <mvc:mapping path=\"/role/*.do\"/>\n        <bean class=\"com.ssm.chapter15.interceptor.RoleInterceptor\"/>\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n用元素\\<mvc:interceptors\\>配置拦截器，在它里面可以配置多个拦截器。上述代码配置了一个角色拦截器，把class配置指定为开发的拦截器而元素\\<mvc:mapping\\>的属性path则告诉Spring MVC拦截什么请求，它使用了一个正则表达式匹配。 \n\n### 15.4.4	多个拦截器执行的顺序\n\n先创建3个角色拦截器，代码如下：\n\n```java\npublic class RoleInterceptor1 extends HandlerInterceptorAdapter {\n	\n	@Override\n	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n			throws Exception {\n		System.err.println(\"preHandle1\");\n		return true;\n	}\n\n	@Override\n	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n			ModelAndView modelAndView) throws Exception {\n		System.err.println(\"postHandle1\");\n	}\n\n	@Override\n	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n			throws Exception {\n		System.err.println(\"afterCompletion1\");\n	}\n\n}\n```\n\n```java\npublic class RoleInterceptor2 extends HandlerInterceptorAdapter {\n	\n	@Override\n	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n			throws Exception {\n		System.err.println(\"preHandle2\");\n		return true;\n	}\n\n	@Override\n	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n			ModelAndView modelAndView) throws Exception {\n		System.err.println(\"postHandle2\");\n	}\n\n	@Override\n	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n			throws Exception {\n		System.err.println(\"afterCompletion2\");\n	}\n\n}\n```\n\n```java\npublic class RoleInterceptor3 extends HandlerInterceptorAdapter {\n	\n	@Override\n	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n			throws Exception {\n		System.err.println(\"preHandle3\");\n		return true;\n	}\n\n	@Override\n	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n			ModelAndView modelAndView) throws Exception {\n		System.err.println(\"postHandle3\");\n	}\n\n	@Override\n	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n			throws Exception {\n		System.err.println(\"afterCompletion3\");\n	}\n\n}\n\n```\n\n修改配置文件，将这些拦截器按顺序配置，代码如下：\n\n```xml\n<mvc:interceptors>\n    <mvc:interceptor>\n        <mvc:mapping path=\"/role/*.do\" />\n        <bean class=\"com.ssm.chapter15.interceptor.RoleInterceptor1\" />\n    </mvc:interceptor>\n    <mvc:interceptor>\n        <mvc:mapping path=\"/role/*.do\" />\n        <bean class=\"com.ssm.chapter15.interceptor.RoleInterceptor2\" />\n    </mvc:interceptor>\n    <mvc:interceptor>\n        <mvc:mapping path=\"/role/*.do\" />\n        <bean class=\"com.ssm.chapter15.interceptor.RoleInterceptor3\" />\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n测试结果如下：\n\n```\n......\npreHandle1\npreHandle2\npreHandle3\n......控制器逻辑日志......\npostHandle3\npostHandle2\npostHandle1\n......\nafterCompletion3\nafterCompletion2\nafterCompletion1\n......\n```\n\n结果与责任链模式的运行顺序一致。\n\n## 15.5	验证表单\n\n在实际开发中，获得数据后的第一步就是检验数据的正确性，一般会通过注解校验，发现错误后返回给用户，但是对于一些逻辑上的错误，比如购买金额=购买数量*单价，这样的规则就很难使用注解验证，这时可以使用Spring提供的验证器（Validator）规则去验证。\n\n### 15.5.1	使用JSR 303注解验证输入内容\n\nSpring提供了对Bean的功能校验，通过注解@Valid标明哪个Bean需要启用注解式的验证。在javax.validation.constrants.*中定义了一系列的JSR 303规范给出的注解，规则可查看https://www.jianshu.com/p/89d3cf1eaf14，为了使用这些注解，假设要完成一个交易表单，代码如下：\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n    \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <title>validate</title>\n    </head>\n    <body>\n        \n        <form action = \"./validate/annotation.do\"> \n        <!-- \n        <form action = \"./validate/validator.do\">\n        -->\n            <table>\n                <tr>\n                    <td>产品编号：</td>\n                    <td><input name=\"productId\" id=\"productId\"/></td>\n                </tr>\n                <tr>\n                    <td>用户编号：</td>\n                    <td><input name=\"userId\" id=\"userId\"/></td>\n                </tr>\n                <tr>\n                    <td>交易日期：</td>\n                    <td><input name=\"date\" id=\"date\"/></td>\n                </tr>\n                <tr>\n                    <td>价格：</td>\n                    <td><input name=\"price\" id=\"price\"/></td>\n                </tr>\n                <tr>\n                    <td>数量：</td>\n                    <td><input name=\"quantity\" id=\"quantity\"/> </td>\n                </tr>\n                <tr>\n                    <td>交易金额：</td>\n                    <td><input name=\"amount\" id=\"amount\"/></td>\n                </tr>\n                <tr>\n                    <td>用户邮件：</td>\n                    <td><input name=\"email\" id=\"email\"/></td>\n                </tr>\n                <tr>\n                    <td>备注：</td>\n                    <td><textarea id=\"note\"  name=\"note\" cols=\"20\" rows=\"5\"></textarea></td>\n                </tr>\n                <tr><td colspan=\"2\" align=\"right\"> <input type=\"submit\" value=\"提交\"/> </tr>\n            </table>\n        <form>\n    </body>\n</html>\n```\n\n假设数据需要满足如下规则：\n\n- 产品编号、用户编号、交易日期、价格、数量、交易金额不能为空。\n- 交易日期格式为yyyy-MM-dd，且只能在未来。\n- 价格最小值为0.1。\n- 数量是一个整数，且最小值为1，最大值为100。\n- 交易金额最小值为1，最大值为5万。\n- 用户邮件需要满足邮件正则式。\n- 备注内容不得多于256个字符。\n\n创建一个POJO，如下：\n\n```java\npublic class Transaction {\n	// 产品编号\n	@NotNull // 不能为空\n	private Long productId;\n\n	// 用户编号\n	@NotNull // 不能为空\n	private Long userId;\n\n	// 交易日期\n	@Future // 只能是将来的日期\n	@DateTimeFormat(pattern = \"yyyy-MM-dd\") // 日期格式化转换\n	@NotNull // 不能为空\n	private Date date;\n\n	// 价格\n	@NotNull // 不能为空\n	@DecimalMin(value = \"0.1\") // 最小值0.1元\n	private Double price;\n\n	// 数量\n	@Min(1) // 最小值为1\n	@Max(100) // 最大值\n	@NotNull // 不能为空\n	private Integer quantity;\n\n	// 交易金额\n	@NotNull // 不能为空\n	@DecimalMax(\"500000.00\") // 最大金额为5万元\n	@DecimalMin(\"1.00\") // 最小交易金额1元\n	private Double amount;\n\n	// 邮件\n	@Pattern(// 正则式\n			regexp = \"^([a-zA-Z0-9]*[-_]?[a-zA-Z0-9]+)*@\"\n					+ \"([a-zA-Z0-9]*[-_]?[a-zA-Z0-9]+)+[\\\\.][A-Za-z]{2,3}([\\\\.][A-Za-z]{2})?$\",\n			// 自定义消息提示\n			message = \"不符合邮件格式\")\n	private String email;\n\n	// 备注\n	@Size(min = 0, max = 256) // 0到255个字符\n	private String note;\n}\n```\n\n这样就可以给每一个字段加入对应校验，它会生成默认的错误信息。在邮件的检验中，还使用了配置项message来重新定义了当校验失败后的错误信息，这样就能够启动Spring的校验规则来校验表单了。\n\n用控制器完成表单验证，代码如下：\n\n```java\n@Controller\n@RequestMapping(\"/validate\")\npublic class ValidateController {\n\n    @RequestMapping(\"/annotation\")\n    public ModelAndView annotationValidate(@Valid Transaction trans, Errors errors) {\n        // 是否存在错误\n        if (errors.hasErrors()) {\n            // 获取错误信息\n            List<FieldError> errorList = errors.getFieldErrors();\n            for (FieldError error : errorList) {\n                // 打印字段错误信息\n                System.err.println(\"fied :\" + error.getField() + \"\\t\" + \"msg:\" + error.getDefaultMessage());\n            }\n        }\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName(\"index\");\n        return mv;\n    }\n}\n```\n\n使用注解@Valid标明这个Bean将会被检验，而另外一个类型为Errors的参数则是用于保存是否存在错误信息的。\n\n有时检验并不简单，它可能还有其他一些复杂的规则。比如，交易日期往往就不是一个应该录入的数据，而是系统提取当前日期。又如规则：交易金额=数量*价格，这样又需要其他的一些验证规则了，Spring提供了验证框架。\n\n### 15.5.2	使用验证器\n\n有时除了简单的输入格式、非空性等校验，也需要一定的业务校验，Spring提供了Validator接口来实现检验，它将在进入控制器逻辑之前对参数的合法性进行校验。\n\nValidator接口定义如下：\n\n```java\npublic interface Validator {\n	/**\n	*判断当前验证器是否用于校验clazz类型的POJO\n	*@param clazz --POJO类型\n	*@return true启动校验，false则不再校验\n	*/\n	boolean supports(Class<?> clazz);\n    \n    /**\n    *检验POJO的合法性\n    *@param target POJO请求对象\n    *@param errors 错误信息\n    */\n	void validate(Object target, Errors errors);\n}\n```\n\n下面进行一项验证，要求：交易金额=价格*数量，代码如下：\n\n```java\npublic class TransactionValidator implements Validator {\n	@Override\n	public boolean supports(Class<?> clazz) {\n		//判断验证是否为Transaction，如果是则进行判断[修改为：验证]\n		return Transaction.class.equals(clazz);\n	}\n\n	@Override\n	public void validate(Object target, Errors errors) {\n		Transaction trans = (Transaction) target;\n		//求交易金额和价格×数量的差额\n		double dis = trans.getAmount() - (trans.getPrice() * trans.getQuantity());\n		//如果差额大于0.01，则认为业务错误\n		if (Math.abs(dis) > 0.01) {\n			//加入错误信息\n			errors.rejectValue(\"amount\", null, \"交易金额和购买数量与价格不匹配\");\n		}\n	}\n}\n```\n\n这样这个验证器就判断了是否为Transaction对象，如果是就去验证后面的逻辑，那么要将它捆绑到对应的控制器中，这时Spring MVC提供了注解@initBinder。在ValidateController中添加代码，代码如下：\n\n```java\n@InitBinder\npublic void initBinder(DataBinder binder) {\n    // 数据绑定器加入验证器\n    binder.setValidator(new TransactionValidator());\n}\n\n@RequestMapping(\"/validator\")\npublic ModelAndView validator(@Valid Transaction trans, Errors errors) {\n    // 是否存在错误\n    if (errors.hasErrors()) {\n        // 获取错误信息\n        List<FieldError> errorList = errors.getFieldErrors();\n        for (FieldError error : errorList) {\n            // 打印字段错误信息\n            System.err.println(\"fied :\" + error.getField() + \"\\t\" + \"msg:\" + error.getDefaultMessage());\n        }\n    }\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName(\"index\");\n    return mv;\n}\n```\n\n注解@Valid就是为了启动这个验证器，而参数Errors则是记录验证器返回错误信息的。\n\n比较遗憾的是，JSR303注解方式和验证器不能同时使用，不过可以在使用JSR303注解方式得到基本的校验信息后，再使用自己得方法进行验证。\n\n## 15.6	数据模型\n\n视图是业务处理后展现给用户的内容，不过一般伴随着业务处理返回的数据，用来给用户查看。在此之前，我们一直使用ModelAndView来定义视图类型，包括JSON视图，也用它来加载数据模型，ModelAndView有一个类型为ModelMap的属性model，而ModelMap继承了LinkedHashMap，因此用它可以存放各种键值对。\n\n在控制器的方法中，可以把ModelAndView、Model、ModelMap作为参数。在Spring MVC，三者可以相互转换。\n\n### 15.7	视图和视图解析器\n\n视图是展示给用户的内容，而在此之前，要通过控制器得到对应的数据模型，如果是非逻辑视图，则不会经过视图解析器定位视图，而是直接渲染数据模型便结束了；而逻辑视图则要对其进一步解析，已定位真实视图，这就是视图解析器的作用。\n\n### 15.7.1	视图\n\n为了满足各种需求，在Spring MVC中定义了多种视图，绑定到数据模型中，那么视图就可以展示数据模型的信息了。只是常用的并不多。它们都要实现接口——View，代码如下：\n\n```java\npublic interface View {\n	//响应状态属性\n	String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + \".responseStatus\";\n	//定义数据模型下取出变量路径\n	String PATH_VARIABLES = View.class.getName() + \".pathVariables\";\n	//选择响应内容类型\n	String SELECTED_CONTENT_TYPE = View.class.getName() + \".selectedContentType\";\n	//选择响应客户端的类型\n	String getContentType();\n	//渲染方法，model是数据模型\n	void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception;\n\n}\n```\n\n注意getContentType方法和render方法。getContentType表示返回一个字符串，标明给用户什么类型的文件响应、可以是HTML、JSON、PDF等。而render方法则是一个渲染视图的方法，其中Model是数据模型，HTPP请求对象和响应对象用于处理HTP请求的各类问题。\n\n当控制器返回ModelAndView时，视图解析器就会解析它，然后将数据模型传递给render方法，这样就能渲染视图了。在Spring MVC中实现视图的类很多，比如JSTL视图JstlView，JSON视图MappingJackon2JsonView，PDF视图AbstractPdfView等，通过它们的render方法，Spring MVC就可以将数据模型渲染成各类视图，以满足各种需求。\n\n视图又分为逻辑视图和非逻辑视图，比如MappingJackon2JsonView是一个非逻辑视图，它的目的就是将数据模型转换为一个JSON视图，展现给用户，，无须对视图名字再进行下一步解析，比如下面代码：\n\n```java\n@RequestMapping(\"/RequestAttribute\")\npublic ModelAndView reqAttr(@RequestAttribute(\"id\") Long id) {\n    ModelAndView mv = new ModelAndView();\n    Role role = roleService.getRole(id);\n    mv.addObject(\"role\", role);\n    mv.setViewName(String.valueOf(new MappingJackson2JsonView()));\n    return mv;\n}\n```\n\nMappingJackon2JsonView在没有视图解析器的情况下可以进行渲染，最终将其绑定的数据模型转换了JSON数据。\n\nInternalResourceView是一个逻辑视图，对于逻辑视图而言它需要一个视图解析器，常见配置如下：\n\n```xml\n<!-- 找到Web工程/WEB-INF/JSP文件夹，且文件结尾为jsp的文件作为映射 -->\n<bean id=\"viewResolver\"\n      class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\n      p:prefix=\"/WEB-INF/jsp/\" p:suffix=\".jsp\" />\n```\n\n通过前缀和后缀加上视图名称就能找到对应的JSP文件，然后把数据模型渲染到JSP文件中，这样便能展示视图给用户了。', 'http://cdn.alanliang.site/note/landscape3.jpg', 1, 6, 0, 2, b'0', b'1', b'1', b'1', b'1', 5, 3, 1, 2, '2020-06-15 11:50:17', '2020-06-15 11:50:17');
INSERT INTO `t_article` VALUES (10, 'friday权限管理系统项目总结', '基于Spring Boot2.X的后台权限管理系统，适合于学习Spring Boot开发、项目毕业设计以及研发团队快速搭建项目，提供纯净的权限管理功能，可作为开发项目的脚手架，作为基础项目。', '<h4 id=\"h4-u4ECBu7ECD\"><a name=\"介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>介绍</h4><p>基于Spring Boot2.X的后台权限管理系统，适合于学习Spring Boot开发、项目毕业设计以及研发团队快速搭建项目，提供纯净的权限管理功能，可作为开发项目的脚手架，作为基础项目。</p>\n<h4 id=\"h4-u8F6Fu4EF6u6280u672F\"><a name=\"软件技术\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>软件技术</h4><ol>\n<li>Spring Boot 2.2.5</li><li>Spring Security 5.2.2</li><li>Mybatis 3.5.4</li><li>Logback 1.2.3</li><li>Druid 1.1.10</li><li>Swagger 2.9.2</li><li>Lombok 1.18.12</li><li>X-admin 2.2</li><li>Thymeleaf 3.0.11</li><li>Layui 2.5.3</li><li>MySQL 5.6</li></ol>\n<h4 id=\"h4-u5185u7F6Eu529Fu80FD\"><a name=\"内置功能\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>内置功能</h4><ol>\n<li>用户管理：用户查询、添加用户、修改用户、用户角色设置、删除用户；</li><li>角色管理：角色查询、添加角色、修改角色、角色菜单权限配置、删除角色；</li><li>菜单管理：菜单查询、添加菜单、修改菜单、删除菜单；</li><li>登录、登出：基于Spring Security的认证和授权；</li><li>Druid数据源监控功能；</li><li>Swagger接口文档功能；</li><li>修改密码；</li><li>代码自动生成：根据数据表以及自定义模板自动生成html、controller、service、serviceImpl、dao、mapper.xml文件；</li></ol>\n<h2 id=\"h2-1-\"><a name=\"1    创建数据库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1    创建数据库</h2><p>本项目采用MySQL5.6数据库，创建基于RBAC模式的权限管理系统设计数据库，数据库模型如图所示：</p>\n<p><img src=\"http://q8rsjstig.bkt.clouddn.com/note/RBAC数据库模型.png\" alt=\"RBAC数据库模型\"></p>\n<p>执行SQL如下：</p>\n<pre><code class=\"lang-mysql\">/*\n Navicat Premium Data Transfer\n\n Source Server         : mysql\n Source Server Type    : MySQL\n Source Server Version : 50640\n Source Host           : localhost:3306\n Source Schema         : friday2\n\n Target Server Type    : MySQL\n Target Server Version : 50640\n File Encoding         : 65001\n\n Date: 27/03/2020 15:38:07\n*/\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for permission\n-- ----------------------------\nDROP TABLE IF EXISTS `permission`;\nCREATE TABLE `permission`  (\n  `permission_id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `parent_id` bigint(11) NOT NULL,\n  `permission_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `css` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `href` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `type` int(4) NOT NULL,\n  `permission` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sort` int(11) NOT NULL,\n  PRIMARY KEY (`permission_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for role\n-- ----------------------------\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role`  (\n  `role_id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `update_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`role_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for role_permisson\n-- ----------------------------\nDROP TABLE IF EXISTS `role_permisson`;\nCREATE TABLE `role_permisson`  (\n  `role_id` bigint(11) NOT NULL,\n  `permission_id` bigint(11) NOT NULL,\n  PRIMARY KEY (`role_id`, `permission_id`) USING BTREE,\n  INDEX `fk_permission_permmissionid`(`permission_id`) USING BTREE,\n  CONSTRAINT `fk_permission_permmissionid` FOREIGN KEY (`permission_id`) REFERENCES `permission` (`permission_id`) ON DELETE CASCADE ON UPDATE RESTRICT,\n  CONSTRAINT `fk_role_roleid2` FOREIGN KEY (`role_id`) REFERENCES `role` (`role_id`) ON DELETE CASCADE ON UPDATE RESTRICT\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for role_user\n-- ----------------------------\nDROP TABLE IF EXISTS `role_user`;\nCREATE TABLE `role_user`  (\n  `role_id` bigint(11) NOT NULL,\n  `user_id` bigint(11) NOT NULL,\n  PRIMARY KEY (`role_id`, `user_id`) USING BTREE,\n  INDEX `fk_user_userid`(`user_id`) USING BTREE,\n  CONSTRAINT `fk_role_roleid` FOREIGN KEY (`role_id`) REFERENCES `role` (`role_id`) ON DELETE CASCADE ON UPDATE RESTRICT,\n  CONSTRAINT `fk_user_userid` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE RESTRICT\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `user_id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `password` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `nickname` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `phone` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sex` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `birthday` date NULL DEFAULT NULL,\n  `status` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `update_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`user_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\nSET FOREIGN_KEY_CHECKS = 1;\n</code></pre>\n<h2 id=\"h2-2-\"><a name=\"2    构建项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2    构建项目</h2><h3 id=\"h3-2-1-spring-initializer-spring-boot-\"><a name=\"2.1使用Spring Initializer创建Spring Boot项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1使用Spring Initializer创建Spring Boot项目</h3><p>打开IDEA，创建新项目，选择Spring Initializer，输入项目信息，如图所示：</p>\n<p><img src=\"http://q8rsjstig.bkt.clouddn.com/note/构建项目.png\" alt=\"构建项目\"></p>\n<p>点击Next后，勾选需要的模块，并且在maven仓库搜索其它模块，并添加至pom文件中，最后pom文件如下所示：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.gdpu&lt;/groupId&gt;\n    &lt;artifactId&gt;myfriday2&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;myfriday2&lt;/name&gt;\n    &lt;description&gt;Authority management system project for Spring Boot&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--spring security启动器--&gt;\n       &lt;!-- &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;--&gt;\n        &lt;!--thymeleaf模板启动器--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--web模块启动器--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--mybatis启动器--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;2.1.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--devtools热部署启动器--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;!--mysql连接驱动--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n            &lt;version&gt;5.1.45&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok插件--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;!--test模块启动器--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n        &lt;!--security test模块--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--手动引入的依赖--&gt;\n        &lt;!--druid数据库连接池--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;1.1.10&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>\n<h3 id=\"h3-2-2-\"><a name=\"2.2    配置数据源\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2    配置数据源</h3><pre><code class=\"lang-yml\">#配置数据源\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/friday2?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false\n    username: root\n    password: 1234\n    platform: mysql\n    # 连接池指定 springboot2.02版本默认使用HikariCP 此处要替换成Druid\n    # 下面为连接池的补充设置，应用到上面所有数据源中\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 初始化大小，最小，最大\n      initial-size: 1\n      min-idle: 3\n      max-active: 20\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\n      time-between-eviction-runs-millis: 30000\n      # 配置一个连接在池中最小生存的时间，单位是毫秒\n      min-evictable-idle-time-millis: 30000\n      validation-query: select &#39;x&#39;\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      max-pool-prepared-statement-per-connection-size: 20\n</code></pre>\n<p>编写测试数据源代码，代码如下：</p>\n<pre><code class=\"lang-java\">@Autowired\nprivate DataSource dataSource;\n\n@Test\nvoid testDataSource(){\n    System.out.println(dataSource.getClass());\n}\n</code></pre>\n<p>测试结果如图，通过Debug方式可以看到数据源的配置信息：</p>\n<p><img src=\"http://q8rsjstig.bkt.clouddn.com/note/测试数据源1.png\" alt=\"测试数据源1\"></p>\n<p><img src=\"http://q8rsjstig.bkt.clouddn.com/note/测试数据源2.png\" alt=\"测试数据源2\"></p>\n<h3 id=\"h3-2-3-mybatis-generator-\"><a name=\"2.3    使用MyBatis Generator生成代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3    使用MyBatis Generator生成代码</h3><p>首先，在pom文件添加MyBatis Generator的依赖，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;!--mybatis generator代码生成--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;\n    &lt;version&gt;1.3.5&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>MyBatis Generator的使用参考官方文档：<a href=\"http://mybatis.org/generator/index.html\">http://mybatis.org/generator/index.html</a></p>\n<p>然后，编写MyBatis Generator的XML配置文件-mgb.xml，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE generatorConfiguration\n        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;\n\n&lt;generatorConfiguration&gt;\n    &lt;!--配置数据源--&gt;\n    &lt;context id=&quot;MySQLTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;\n        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;\n                        connectionURL=&quot;jdbc:mysql://localhost:3306/friday2&quot;\n                        userId=&quot;root&quot;\n                        password=&quot;1234&quot;&gt;\n        &lt;/jdbcConnection&gt;\n        &lt;!--指定JavaBean的生成位置--&gt;\n        &lt;javaModelGenerator targetPackage=&quot;com.gdpu.myfriday2.model&quot; targetProject=&quot;src/main/java&quot;&gt;\n            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;\n        &lt;/javaModelGenerator&gt;\n        &lt;!--指定mapper映射文件的生成位置--&gt;\n        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;\n            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;\n        &lt;/sqlMapGenerator&gt;\n        &lt;!--指定mapper接口的生成位置--&gt;\n        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.gdpu.myfriday2.dao&quot; targetProject=&quot;src/main/java&quot;&gt;\n            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;\n        &lt;/javaClientGenerator&gt;\n        &lt;!--指定表的生成策略--&gt;\n        &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot;/&gt;\n        &lt;table tableName=&quot;role&quot; domainObjectName=&quot;Role&quot;/&gt;\n        &lt;table tableName=&quot;role_user&quot; domainObjectName=&quot;RoleUser&quot;/&gt;\n        &lt;table tableName=&quot;permission&quot; domainObjectName=&quot;Permission&quot;/&gt;\n        &lt;table tableName=&quot;role_permission&quot; domainObjectName=&quot;RolePermission&quot;/&gt;\n    &lt;/context&gt;\n&lt;/generatorConfiguration&gt;\n</code></pre>\n<p>接着编写Java配置文件，代码如下：</p>\n<pre><code class=\"lang-java\">@Test\nvoid testMybatisGenerator() throws Exception {\n    List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();\n    boolean overwrite = true;\n    //以下为MyBatis Generator的XML配置文件的位置\n    File configFile = new File(&quot;src/main/resources/mbg.xml&quot;);\n    ConfigurationParser cp = new ConfigurationParser(warnings);\n    Configuration config = cp.parseConfiguration(configFile);\n    DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n}\n</code></pre>\n<p>执行后，生成代码如图：</p>\n<p><img src=\"http://q8rsjstig.bkt.clouddn.com/note/生成代码1.png\" alt=\"生成代码1\"></p>\n<p><img src=\"C:\\Users\\AlanLiang\\Desktop\\笔记\\项目\\friday\\图片\\生成代码2.png\" alt=\"生成代码2\"></p>\n<p>在application.yml文件中配置mybatis，代码如下：</p>\n<pre><code class=\"lang-yml\">#配置mybatis\nmybatis:\n  #配置model别名\n  type-aliases-package: com.gdpu.friday.model\n  configuration:\n    #开启驼峰命名映射\n    map-underscore-to-camel-case: true\n  #指定mapper映射文件位置\n  mapper-locations: classpath:/mapper/*.xml\n</code></pre>\n<p>在每个mapper接口上添加<a href=\"https://github.com/Repository\" title=\"&#64;Repository\" class=\"at-link\">@Repository</a>注解，以便注入spring容器，以UserMapper为例，代码如下：</p>\n<pre><code class=\"lang-java\">@Repository\npublic interface UserMapper {\n    ...\n}\n</code></pre>\n<p>在springboot启动类中加入<a href=\"https://github.com/MapperScan\" title=\"&#64;MapperScan\" class=\"at-link\">@MapperScan</a>注解，用于扫描mapper接口，代码如下：</p>\n<pre><code class=\"lang-java\">@MapperScan(&quot;com.gdpu.myfriday2.dao&quot;)\n@SpringBootApplication\npublic class Myfriday2Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Myfriday2Application.class, args);\n    }\n\n}\n</code></pre>\n<p>接着测试mapper，代码如下：</p>\n<pre><code class=\"lang-java\">@Autowired\nprivate UserMapper userMapper;\n\n@Test\nvoid testUserMapper() {\n    User user = new User();\n    user.setUsername(&quot;admin&quot;);\n    user.setPassword(&quot;123456&quot;);\n    user.setNickname(&quot;系统管理员&quot;);\n    user.setEmail(&quot;admin@qq.com&quot;);\n    user.setPhone(&quot;13415418399&quot;);\n    user.setSex(&quot;M&quot;);\n    user.setBirthday(new Date(1998, 5, 10));\n    user.setStatus(&quot;启用&quot;);\n    user.setCreateTime(new Date());\n    user.setUpdateTime(new Date());\n    userMapper.insertSelective(user);\n}\n</code></pre>\n<h3 id=\"h3-2-4-xadmin-\"><a name=\"2.4    引入Xadmin前端模板\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4    引入Xadmin前端模板</h3><p>首先下载Xadmin，链接为：<a href=\"http://x.xuebingsi.com/index/down/index.html\">http://x.xuebingsi.com/index/down/index.html</a></p>\n<p>然后，复制资源文件至static目录下，如图所示：</p>\n<p><img src=\"http://q8rsjstig.bkt.clouddn.com/note/引入xadmin资源.png\" alt=\"引入xadmin资源\"></p>\n<p>接着复制index.html页面至templates目录下，引入thymeleaf名称空间，修改资源路径，代码如下：</p>\n<pre><code class=\"lang-html\">&lt;html class=&quot;x-admin-sm&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;后台登录-X-admin2.2&lt;/title&gt;\n    &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n    &lt;meta name=&quot;viewport&quot;\n          content=&quot;width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi&quot;/&gt;\n    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;/&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/xadmin/css/font.css&quot; th:href=&quot;@{/xadmin/css/font.css}&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/xadmin/css/xadmin.css&quot; th:href=&quot;@{/xadmin/css/xadmin.css}&quot;&gt;\n    &lt;script src=&quot;../static/xadmin/lib/layui/layui.js&quot; charset=&quot;utf-8&quot; th:src=&quot;@{/xadmin/lib/layui/layui.js}&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../static/xadmin/js/xadmin.js&quot; th:src=&quot;@{/xadmin/js/xadmin.js}&quot;&gt;&lt;/script&gt;\n    &lt;!-- 让IE8/9支持媒体查询，从而兼容栅格 --&gt;\n    &lt;!--[if lt IE 9]&gt;\n    &lt;script src=&quot;https://cdn.staticfile.org/html5shiv/r29/html5.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://cdn.staticfile.org/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;\n    &lt;![endif]--&gt;\n    &lt;script&gt;\n        // 是否开启刷新记忆tab功能\n        // var is_remember = false;\n    &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>最后，浏览器地址栏输入localhost:8080，成功访问主页，项目搭建完成。</p>\n<h2 id=\"h2-3-\"><a name=\"3    遇到的问题和错误\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3    遇到的问题和错误</h2><h3 id=\"h3-3-1-layui\"><a name=\"3.1    layui\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1    layui</h3><h4 id=\"h4-3-11-layui-\"><a name=\"3.11    layui数据表格显示请求成功，但不显示数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.11    layui数据表格显示请求成功，但不显示数据</h4><p>可能是layui存在bug，在table.render加入如下代码可以解决：</p>\n<pre><code class=\"lang-javascript\">, response: {\n    statusName: &#39;code&#39; //规定数据状态的字段名称，默认：code\n   , statusCode: 200 //规定成功的状态码，默认：0\n   , msgName: &#39;msg&#39; //规定状态信息的字段名称，默认：msg\n   , countName: &#39;count&#39; //规定数据总数的字段名称，默认：count\n   , dataName: &#39;data&#39; //规定数据列表的字段名称，默认：data\n}\n</code></pre>\n<h3 id=\"h3-3-12-layui-\"><a name=\"3.12    layui登录窗口嵌套\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.12    layui登录窗口嵌套</h3><p>在登录页面加上以下代码可解决：</p>\n<pre><code class=\"lang-java\">/***判断是否存在父级页面,存在则刷新,不存在则不刷新**/\nif (selfA.location !== top.location) {\n    top.location = self.location;\n}\n</code></pre>\n<h3 id=\"h3-3-13-layui-\"><a name=\"3.13    layui一行显示两个块元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.13    layui一行显示两个块元素</h3><p>在外层套一个div，class为layui-inline，块元素再套一个div，class为layui-input-inline，代码如下：</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;layui-inline&quot;&gt;\n    &lt;div class=&quot;layui-input-inline&quot;&gt;\n        &lt;input name=&quot;verCode&quot; lay-verify=&quot;required&quot; placeholder=&quot;验证码&quot; type=&quot;text&quot; &gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;layui-input-inline&quot;&gt;\n        &lt;img src=&quot;/captcha&quot; width=&quot;130px&quot; height=&quot;48px&quot; th:src=&quot;@{/captcha}&quot;/&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"h3-3-14-\"><a name=\"3.14    刷新验证码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.14    刷新验证码</h3><pre><code class=\"lang-js\">//刷新验证码\n$(&#39;#verCodeImg&#39;).click(function flushVerCode() {\n    this.src = this.src + &quot;?&quot; + Math.random();\n});\n</code></pre>\n<h2 id=\"h2-3-2-spring-security\"><a name=\"3.2    Spring Security\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2    Spring Security</h2><h3 id=\"h3-3-21-\"><a name=\"3.21    配置类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.21    配置类</h3><pre><code class=\"lang-java\">@EnableWebSecurity\n@Configuration\n@EnableGlobalMethodSecurity(prePostEnabled = true)//启用spring security注解\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Qualifier(&quot;userDetailServiceImpl&quot;)\n    @Autowired\n    private UserDetailsService userDetailsService;\n    @Autowired\n    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;\n    @Autowired\n    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;\n    @Autowired\n    private MyAccessDeniedHandler myAccessDeniedHandler;\n    @Autowired\n    private ValidateCodeFilter validateCodeFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //开启登录配置\n        http.authorizeRequests()\n                //放行访问登录页面、验证码和静态资源的请求\n                .antMatchers(&quot;/login.html&quot;, &quot;/captcha&quot;, &quot;/xadmin/**&quot;, &quot;/tretable-lay/**&quot;, &quot;/ztree/**&quot;, &quot;/js/**&quot;, &quot;/static/**&quot;).permitAll()\n                //其余请求在认证后可访问\n                .anyRequest().authenticated();\n\n        //添加图形验证码\n        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)\n                //允许表单登录\n                .formLogin()\n                //自定义登录页面\n                .loginPage(&quot;/login.html&quot;)\n                //自定义登录表单提交路径\n                .loginProcessingUrl(&quot;/login&quot;)\n                //认证成功处理\n                .successHandler(myAuthenticationSuccessHandler)\n                //认证失败处理\n                .failureHandler(myAuthenticationFailureHandler)\n                .and()\n                //记住我\n                .rememberMe();\n\n        //自定义退出登录\n        http.logout().permitAll()\n                .invalidateHttpSession(true)\n                .deleteCookies(&quot;JSESSIONID&quot;)\n                .logoutSuccessUrl(&quot;/login.html&quot;);\n\n        //处理权限异常\n        http.exceptionHandling().accessDeniedHandler(myAccessDeniedHandler);\n\n        //禁用拦截除GET方式以外的请求\n        http.csrf().disable();\n        //解决X-Frame-Options DENY问题\n        http.headers().frameOptions().sameOrigin();\n    }\n}\n</code></pre>\n<h3 id=\"h3-3-22-\"><a name=\"3.22    自定义无权限处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.22    自定义无权限处理</h3><pre><code class=\"lang-java\">@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)\n            throws IOException, ServletException {\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        response.setCharacterEncoding(&quot;utf-8&quot;);\n        response.sendRedirect(&quot;/403.html&quot;);\n    }\n\n}\n</code></pre>\n<h2 id=\"h2-3-3-spring-mvc\"><a name=\"3.3    Spring MVC\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3    Spring MVC</h2><h3 id=\"h3-3-31-\"><a name=\"3.31    解决日期格式转换问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.31    解决日期格式转换问题</h3><p>错误信息如下：</p>\n<pre><code>Failed to convert value of type &#39;java.lang.String&#39; to required type &#39;java.lang.Long&#39;; nested exception is java.lang.NumberFormatException: For input string: &quot;info&quot;\n</code></pre><p>在Controller中加入以下代码：</p>\n<pre><code class=\"lang-java\">/**\n     * 将日期格式的String类型转为Date类型\n     *\n     * @param binder 数据绑定\n     */\n@InitBinder\npublic void dateBinder(WebDataBinder binder) {\n    String pattern = &quot;yyyy-MM-dd&quot;;\n    CustomDateEditor editor = new CustomDateEditor(new SimpleDateFormat(pattern), true);\n    binder.registerCustomEditor(Date.class, editor);\n}\n</code></pre>\n<h3 id=\"h3-3-32-thymeleaf-\"><a name=\"3.32    不能解析thymeleaf模板\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.32    不能解析thymeleaf模板</h3><p>错误信息如下：</p>\n<pre><code>org.thymeleaf.exceptions.TemplateInputException: Error resolving template [user/info], template might not exist or might not be accessible by any of the configured Template Resolvers\n</code></pre><p>一般是templates目录下没有这个页面，或者添加了但是没有重启服务器，或者是Controller中视图名称写错了，或者是当前方法返回数据但没有加<a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></p>\n<h2 id=\"h2-4-\"><a name=\"4    项目代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4    项目代码</h2><p><a href=\"https://github.com/AlanLiang1998/my_friday\">https://github.com/AlanLiang1998/my_friday</a></p>\n', '#### 介绍\n\n基于Spring Boot2.X的后台权限管理系统，适合于学习Spring Boot开发、项目毕业设计以及研发团队快速搭建项目，提供纯净的权限管理功能，可作为开发项目的脚手架，作为基础项目。\n\n#### 软件技术\n\n1. Spring Boot 2.2.5\n2. Spring Security 5.2.2\n3. Mybatis 3.5.4\n4. Logback 1.2.3\n5. Druid 1.1.10\n6. Swagger 2.9.2\n7. Lombok 1.18.12\n8. X-admin 2.2\n9. Thymeleaf 3.0.11\n10. Layui 2.5.3\n11. MySQL 5.6\n\n#### 内置功能\n\n1. 用户管理：用户查询、添加用户、修改用户、用户角色设置、删除用户；\n2. 角色管理：角色查询、添加角色、修改角色、角色菜单权限配置、删除角色；\n3. 菜单管理：菜单查询、添加菜单、修改菜单、删除菜单；\n4. 登录、登出：基于Spring Security的认证和授权；\n5. Druid数据源监控功能；\n6. Swagger接口文档功能；\n7. 修改密码；\n8. 代码自动生成：根据数据表以及自定义模板自动生成html、controller、service、serviceImpl、dao、mapper.xml文件；\n\n## 1    创建数据库\n\n本项目采用MySQL5.6数据库，创建基于RBAC模式的权限管理系统设计数据库，数据库模型如图所示：\n\n![RBAC数据库模型](http://q8rsjstig.bkt.clouddn.com/note/RBAC数据库模型.png)\n\n执行SQL如下：\n\n```mysql\n/*\n Navicat Premium Data Transfer\n\n Source Server         : mysql\n Source Server Type    : MySQL\n Source Server Version : 50640\n Source Host           : localhost:3306\n Source Schema         : friday2\n\n Target Server Type    : MySQL\n Target Server Version : 50640\n File Encoding         : 65001\n\n Date: 27/03/2020 15:38:07\n*/\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for permission\n-- ----------------------------\nDROP TABLE IF EXISTS `permission`;\nCREATE TABLE `permission`  (\n  `permission_id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `parent_id` bigint(11) NOT NULL,\n  `permission_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `css` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `href` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `type` int(4) NOT NULL,\n  `permission` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sort` int(11) NOT NULL,\n  PRIMARY KEY (`permission_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for role\n-- ----------------------------\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role`  (\n  `role_id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `update_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`role_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for role_permisson\n-- ----------------------------\nDROP TABLE IF EXISTS `role_permisson`;\nCREATE TABLE `role_permisson`  (\n  `role_id` bigint(11) NOT NULL,\n  `permission_id` bigint(11) NOT NULL,\n  PRIMARY KEY (`role_id`, `permission_id`) USING BTREE,\n  INDEX `fk_permission_permmissionid`(`permission_id`) USING BTREE,\n  CONSTRAINT `fk_permission_permmissionid` FOREIGN KEY (`permission_id`) REFERENCES `permission` (`permission_id`) ON DELETE CASCADE ON UPDATE RESTRICT,\n  CONSTRAINT `fk_role_roleid2` FOREIGN KEY (`role_id`) REFERENCES `role` (`role_id`) ON DELETE CASCADE ON UPDATE RESTRICT\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for role_user\n-- ----------------------------\nDROP TABLE IF EXISTS `role_user`;\nCREATE TABLE `role_user`  (\n  `role_id` bigint(11) NOT NULL,\n  `user_id` bigint(11) NOT NULL,\n  PRIMARY KEY (`role_id`, `user_id`) USING BTREE,\n  INDEX `fk_user_userid`(`user_id`) USING BTREE,\n  CONSTRAINT `fk_role_roleid` FOREIGN KEY (`role_id`) REFERENCES `role` (`role_id`) ON DELETE CASCADE ON UPDATE RESTRICT,\n  CONSTRAINT `fk_user_userid` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE CASCADE ON UPDATE RESTRICT\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `user_id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `password` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `nickname` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `phone` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sex` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `birthday` date NULL DEFAULT NULL,\n  `status` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `create_time` datetime(0) NULL DEFAULT NULL,\n  `update_time` datetime(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`user_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n```\n\n##2	构建项目\n\n### 2.1使用Spring Initializer创建Spring Boot项目\n\n打开IDEA，创建新项目，选择Spring Initializer，输入项目信息，如图所示：\n\n![构建项目](http://q8rsjstig.bkt.clouddn.com/note/构建项目.png)\n\n点击Next后，勾选需要的模块，并且在maven仓库搜索其它模块，并添加至pom文件中，最后pom文件如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.5.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.gdpu</groupId>\n    <artifactId>myfriday2</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>myfriday2</name>\n    <description>Authority management system project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <!--spring security启动器-->\n       <!-- <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>-->\n        <!--thymeleaf模板启动器-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <!--web模块启动器-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--mybatis启动器-->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.1.2</version>\n        </dependency>\n        <!--devtools热部署启动器-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <!--mysql连接驱动-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n            <version>5.1.45</version>\n        </dependency>\n        <!--lombok插件-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!--test模块启动器-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <!--security test模块-->\n        <dependency>\n            <groupId>org.springframework.security</groupId>\n            <artifactId>spring-security-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <!--手动引入的依赖-->\n        <!--druid数据库连接池-->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.1.10</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n### 2.2	配置数据源\n\n```yml\n#配置数据源\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/friday2?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false\n    username: root\n    password: 1234\n    platform: mysql\n    # 连接池指定 springboot2.02版本默认使用HikariCP 此处要替换成Druid\n    # 下面为连接池的补充设置，应用到上面所有数据源中\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 初始化大小，最小，最大\n      initial-size: 1\n      min-idle: 3\n      max-active: 20\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\n      time-between-eviction-runs-millis: 30000\n      # 配置一个连接在池中最小生存的时间，单位是毫秒\n      min-evictable-idle-time-millis: 30000\n      validation-query: select \'x\'\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      max-pool-prepared-statement-per-connection-size: 20\n```\n\n编写测试数据源代码，代码如下：\n\n```java\n@Autowired\nprivate DataSource dataSource;\n\n@Test\nvoid testDataSource(){\n    System.out.println(dataSource.getClass());\n}\n```\n\n测试结果如图，通过Debug方式可以看到数据源的配置信息：\n\n![测试数据源1](http://q8rsjstig.bkt.clouddn.com/note/测试数据源1.png)\n\n![测试数据源2](http://q8rsjstig.bkt.clouddn.com/note/测试数据源2.png)\n\n### 2.3	使用MyBatis Generator生成代码\n\n首先，在pom文件添加MyBatis Generator的依赖，代码如下：\n\n```xml\n<!--mybatis generator代码生成-->\n<dependency>\n    <groupId>org.mybatis.generator</groupId>\n    <artifactId>mybatis-generator-core</artifactId>\n    <version>1.3.5</version>\n</dependency>\n```\n\nMyBatis Generator的使用参考官方文档：http://mybatis.org/generator/index.html\n\n然后，编写MyBatis Generator的XML配置文件-mgb.xml，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\n<generatorConfiguration>\n    <!--配置数据源-->\n    <context id=\"MySQLTables\" targetRuntime=\"MyBatis3\">\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\n                        connectionURL=\"jdbc:mysql://localhost:3306/friday2\"\n                        userId=\"root\"\n                        password=\"1234\">\n        </jdbcConnection>\n        <!--指定JavaBean的生成位置-->\n        <javaModelGenerator targetPackage=\"com.gdpu.myfriday2.model\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n        <!--指定mapper映射文件的生成位置-->\n        <sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n        <!--指定mapper接口的生成位置-->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.gdpu.myfriday2.dao\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n        <!--指定表的生成策略-->\n        <table tableName=\"user\" domainObjectName=\"User\"/>\n        <table tableName=\"role\" domainObjectName=\"Role\"/>\n        <table tableName=\"role_user\" domainObjectName=\"RoleUser\"/>\n        <table tableName=\"permission\" domainObjectName=\"Permission\"/>\n        <table tableName=\"role_permission\" domainObjectName=\"RolePermission\"/>\n    </context>\n</generatorConfiguration>\n```\n\n接着编写Java配置文件，代码如下：\n\n```java\n@Test\nvoid testMybatisGenerator() throws Exception {\n    List<String> warnings = new ArrayList<String>();\n    boolean overwrite = true;\n    //以下为MyBatis Generator的XML配置文件的位置\n    File configFile = new File(\"src/main/resources/mbg.xml\");\n    ConfigurationParser cp = new ConfigurationParser(warnings);\n    Configuration config = cp.parseConfiguration(configFile);\n    DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n}\n```\n\n执行后，生成代码如图：\n\n![生成代码1](http://q8rsjstig.bkt.clouddn.com/note/生成代码1.png)\n\n![生成代码2](C:\\Users\\AlanLiang\\Desktop\\笔记\\项目\\friday\\图片\\生成代码2.png)\n\n在application.yml文件中配置mybatis，代码如下：\n\n```yml\n#配置mybatis\nmybatis:\n  #配置model别名\n  type-aliases-package: com.gdpu.friday.model\n  configuration:\n    #开启驼峰命名映射\n    map-underscore-to-camel-case: true\n  #指定mapper映射文件位置\n  mapper-locations: classpath:/mapper/*.xml\n```\n\n在每个mapper接口上添加@Repository注解，以便注入spring容器，以UserMapper为例，代码如下：\n\n```java\n@Repository\npublic interface UserMapper {\n    ...\n}\n```\n\n在springboot启动类中加入@MapperScan注解，用于扫描mapper接口，代码如下：\n\n```java\n@MapperScan(\"com.gdpu.myfriday2.dao\")\n@SpringBootApplication\npublic class Myfriday2Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Myfriday2Application.class, args);\n    }\n\n}\n```\n\n接着测试mapper，代码如下：\n\n```java\n@Autowired\nprivate UserMapper userMapper;\n\n@Test\nvoid testUserMapper() {\n    User user = new User();\n    user.setUsername(\"admin\");\n    user.setPassword(\"123456\");\n    user.setNickname(\"系统管理员\");\n    user.setEmail(\"admin@qq.com\");\n    user.setPhone(\"13415418399\");\n    user.setSex(\"M\");\n    user.setBirthday(new Date(1998, 5, 10));\n    user.setStatus(\"启用\");\n    user.setCreateTime(new Date());\n    user.setUpdateTime(new Date());\n    userMapper.insertSelective(user);\n}\n```\n\n### 2.4	引入Xadmin前端模板\n\n首先下载Xadmin，链接为：http://x.xuebingsi.com/index/down/index.html\n\n然后，复制资源文件至static目录下，如图所示：\n\n![引入xadmin资源](http://q8rsjstig.bkt.clouddn.com/note/引入xadmin资源.png)\n\n接着复制index.html页面至templates目录下，引入thymeleaf名称空间，修改资源路径，代码如下：\n\n```html\n<html class=\"x-admin-sm\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>后台登录-X-admin2.2</title>\n    <meta name=\"renderer\" content=\"webkit|ie-comp|ie-stand\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"viewport\"\n          content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\"/>\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\"/>\n    <link rel=\"stylesheet\" href=\"../static/xadmin/css/font.css\" th:href=\"@{/xadmin/css/font.css}\">\n    <link rel=\"stylesheet\" href=\"../static/xadmin/css/xadmin.css\" th:href=\"@{/xadmin/css/xadmin.css}\">\n    <script src=\"../static/xadmin/lib/layui/layui.js\" charset=\"utf-8\" th:src=\"@{/xadmin/lib/layui/layui.js}\"></script>\n    <script type=\"text/javascript\" src=\"../static/xadmin/js/xadmin.js\" th:src=\"@{/xadmin/js/xadmin.js}\"></script>\n    <!-- 让IE8/9支持媒体查询，从而兼容栅格 -->\n    <!--[if lt IE 9]>\n    <script src=\"https://cdn.staticfile.org/html5shiv/r29/html5.min.js\"></script>\n    <script src=\"https://cdn.staticfile.org/respond.js/1.4.2/respond.min.js\"></script>\n    <![endif]-->\n    <script>\n        // 是否开启刷新记忆tab功能\n        // var is_remember = false;\n    </script>\n</head>\n```\n\n最后，浏览器地址栏输入localhost:8080，成功访问主页，项目搭建完成。\n\n\n\n## 3	遇到的问题和错误\n\n###3.1	layui\n\n#### 3.11	layui数据表格显示请求成功，但不显示数据\n\n可能是layui存在bug，在table.render加入如下代码可以解决：\n\n```javascript\n, response: {\n    statusName: \'code\' //规定数据状态的字段名称，默认：code\n   , statusCode: 200 //规定成功的状态码，默认：0\n   , msgName: \'msg\' //规定状态信息的字段名称，默认：msg\n   , countName: \'count\' //规定数据总数的字段名称，默认：count\n   , dataName: \'data\' //规定数据列表的字段名称，默认：data\n}\n```\n\n### 3.12	layui登录窗口嵌套\n\n在登录页面加上以下代码可解决：\n\n```java\n/***判断是否存在父级页面,存在则刷新,不存在则不刷新**/\nif (selfA.location !== top.location) {\n    top.location = self.location;\n}\n```\n\n### 3.13	layui一行显示两个块元素\n\n在外层套一个div，class为layui-inline，块元素再套一个div，class为layui-input-inline，代码如下：\n\n```html\n<div class=\"layui-inline\">\n    <div class=\"layui-input-inline\">\n        <input name=\"verCode\" lay-verify=\"required\" placeholder=\"验证码\" type=\"text\" >\n    </div>\n    <div class=\"layui-input-inline\">\n        <img src=\"/captcha\" width=\"130px\" height=\"48px\" th:src=\"@{/captcha}\"/>\n    </div>\n</div>\n```\n\n### 3.14	刷新验证码\n\n```js\n//刷新验证码\n$(\'#verCodeImg\').click(function flushVerCode() {\n    this.src = this.src + \"?\" + Math.random();\n});\n```\n\n## 3.2	Spring Security\n\n### 3.21	配置类\n\n```java\n@EnableWebSecurity\n@Configuration\n@EnableGlobalMethodSecurity(prePostEnabled = true)//启用spring security注解\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Qualifier(\"userDetailServiceImpl\")\n    @Autowired\n    private UserDetailsService userDetailsService;\n    @Autowired\n    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;\n    @Autowired\n    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;\n    @Autowired\n    private MyAccessDeniedHandler myAccessDeniedHandler;\n    @Autowired\n    private ValidateCodeFilter validateCodeFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //开启登录配置\n        http.authorizeRequests()\n                //放行访问登录页面、验证码和静态资源的请求\n                .antMatchers(\"/login.html\", \"/captcha\", \"/xadmin/**\", \"/tretable-lay/**\", \"/ztree/**\", \"/js/**\", \"/static/**\").permitAll()\n                //其余请求在认证后可访问\n                .anyRequest().authenticated();\n\n        //添加图形验证码\n        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)\n                //允许表单登录\n                .formLogin()\n                //自定义登录页面\n                .loginPage(\"/login.html\")\n                //自定义登录表单提交路径\n                .loginProcessingUrl(\"/login\")\n                //认证成功处理\n                .successHandler(myAuthenticationSuccessHandler)\n                //认证失败处理\n                .failureHandler(myAuthenticationFailureHandler)\n                .and()\n                //记住我\n                .rememberMe();\n\n        //自定义退出登录\n        http.logout().permitAll()\n                .invalidateHttpSession(true)\n                .deleteCookies(\"JSESSIONID\")\n                .logoutSuccessUrl(\"/login.html\");\n\n        //处理权限异常\n        http.exceptionHandling().accessDeniedHandler(myAccessDeniedHandler);\n\n        //禁用拦截除GET方式以外的请求\n        http.csrf().disable();\n        //解决X-Frame-Options DENY问题\n        http.headers().frameOptions().sameOrigin();\n    }\n}\n\n```\n\n### 3.22	自定义无权限处理\n\n```java\n@Component\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)\n            throws IOException, ServletException {\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        response.setCharacterEncoding(\"utf-8\");\n        response.sendRedirect(\"/403.html\");\n    }\n\n}\n\n```\n\n## 3.3	Spring MVC\n\n### 3.31	解决日期格式转换问题\n\n错误信息如下：\n\n```\nFailed to convert value of type \'java.lang.String\' to required type \'java.lang.Long\'; nested exception is java.lang.NumberFormatException: For input string: \"info\"\n```\n\n在Controller中加入以下代码：\n\n```java\n/**\n     * 将日期格式的String类型转为Date类型\n     *\n     * @param binder 数据绑定\n     */\n@InitBinder\npublic void dateBinder(WebDataBinder binder) {\n    String pattern = \"yyyy-MM-dd\";\n    CustomDateEditor editor = new CustomDateEditor(new SimpleDateFormat(pattern), true);\n    binder.registerCustomEditor(Date.class, editor);\n}\n```\n\n### 3.32	不能解析thymeleaf模板\n\n错误信息如下：\n\n```\norg.thymeleaf.exceptions.TemplateInputException: Error resolving template [user/info], template might not exist or might not be accessible by any of the configured Template Resolvers\n```\n\n一般是templates目录下没有这个页面，或者添加了但是没有重启服务器，或者是Controller中视图名称写错了，或者是当前方法返回数据但没有加@ResponseBody\n\n##	4	项目代码\n\nhttps://github.com/AlanLiang1998/my_friday', 'http://cdn.alanliang.site/note/landscape4.jpg', 1, 0, 0, 0, b'0', b'1', b'0', b'0', b'1', 2, 3, 3, 2, '2020-06-15 11:56:47', '2020-06-15 11:56:47');
INSERT INTO `t_article` VALUES (11, '跟武哥一起学习Spring Boot', '本课程首发于 CSDN GitChat 达人课《跟武哥一起学Spring Boot》，该文档为课程详细笔记。', '<h1 id=\"h1--spring-boot\"><a name=\"跟武哥一起学习Spring Boot\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>跟武哥一起学习Spring Boot</h1><h1 id=\"h1-u4F5Cu8005u4FE1u606F\"><a name=\"作者信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>作者信息</h1><p>本课程首发于 CSDN GitChat 达人课《跟武哥一起学Spring Boot》，该文档为课程详细笔记。<br>作者：倪升武（武哥）<br>微信公众号：武哥聊编程<br><img src=\"https://img-blog.csdnimg.cn/202002150421550.jpg\" alt=\"武哥聊编程\"></p>\n<blockquote>\n<p>版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途和其他不正当用途，否则追究法律责任。</p>\n</blockquote>\n<h1 id=\"h1--\"><a name=\"导读：课程概览\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>导读：课程概览</h1><h2 id=\"h2-1-spring-boot-\"><a name=\"1. Spring Boot是什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Spring Boot是什么</h2><p>我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。<strong>繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低</strong>。  </p>\n<p>2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求<strong>在 Spring 框架中支持无容器 Web 应用程序体系结构</strong>。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：</p>\n<blockquote>\n<p>我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 <code>main()</code>方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。 </p>\n</blockquote>\n<p>这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而<strong>是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具</strong>。</p>\n<p>它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。   </p>\n<h2 id=\"h2-2-spring-boot\"><a name=\"2. 为什么学习Spring Boot\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 为什么学习Spring Boot</h2><h3 id=\"h3-2-1-spring-\"><a name=\"2.1 从Spring官方来看\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 从Spring官方来看</h3><p>我们打开 Spring 的<a href=\"http://spring.io/\">官方网站</a>，可以看到下图：  </p>\n<p><img src=\"https://images.gitbook.cn/98fda7f0-8656-11e8-8675-5537a701ae7d\" alt=\"Spring官网首图\"></p>\n<p>我们可以看到图中官方对 Spring Boot 的定位：<em>Build Anything</em>， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。  同时我们也来看一下官方对后面两个的定位：  </p>\n<p>SpringCloud：<em>Coordinate Anything</em>，协调任何事情；<br>SpringCloud Data Flow：<em>Connect everything</em>，连接任何东西。</p>\n<p>仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。</p>\n<h3 id=\"h3-2-2-spring-boot-\"><a name=\"2.2 从Spring Boot的优点来看\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 从Spring Boot的优点来看</h3><p>Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：</p>\n<p><img src=\"https://images.gitbook.cn/e17b8c40-8656-11e8-8a91-d70bc2d847c5\" alt=\"Spring Boot的优点\"></p>\n<h4 id=\"h4-2-2-1-\"><a name=\"2.2.1 良好的基因\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 良好的基因</h4><p>Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。</p>\n<p><img src=\"https://images.gitbook.cn/00078650-8657-11e8-87de-d910a3ee087e\" alt=\"Spring Boot与Spring\"></p>\n<h4 id=\"h4-2-2-2-\"><a name=\"2.2.2 简化编码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 简化编码</h4><p>举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p>\n<pre><code class=\"lang-xml\">&lt;!-- .....省略其他依赖 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n    &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n    &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p>\n<h4 id=\"h4-2-2-3-\"><a name=\"2.2.3 简化配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.3 简化配置</h4><p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p>\n<p>我新建一个类，但是我不用 <code><a href=\"https://github.com/Service\" title=\"&#64;Service\" class=\"at-link\">@Service</a></code>注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要<code><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a></code> 和<code><a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a></code>两个注解即可，如下：</p>\n<pre><code class=\"lang-java\">public class TestService {\n    public String sayHello () {\n        return &quot;Hello Spring Boot!&quot;;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class JavaConfig {\n    @Bean\n    public TestService getTestService() {\n        return new TestService();\n    }\n}\n</code></pre>\n<p><code><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a></code>表示该类是个配置类，<code><a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a></code>表示该方法返回一个 Bean。这样就把<code>TestService</code>作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用<code><a href=\"https://github.com/Resource\" title=\"&#64;Resource\" class=\"at-link\">@Resource</a></code>注解注入进来即可使用，非常方便。</p>\n<pre><code class=\"lang-java\">@Resource\nprivate TestService testService;\n</code></pre>\n<p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p>\n<h4 id=\"h4-2-2-4-\"><a name=\"2.2.4 简化部署\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.4 简化部署</h4><p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 <code>java -jar xxx.jar</code>一键式启动项目。</p>\n<p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p>\n<h4 id=\"h4-2-2-5-\"><a name=\"2.2.5 简化监控\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.5 简化监控</h4><p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p>\n<h3 id=\"h3-2-3-\"><a name=\"2.3 从未来发展的趋势来看\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 从未来发展的趋势来看</h3><p>微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。</p>\n<h2 id=\"h2-3-\"><a name=\"3. 本课程能学到什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 本课程能学到什么</h2><p>本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。  </p>\n<p>基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。  </p>\n<p>进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。  </p>\n<p>认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。  </p>\n<p>课程所有源码提供免费下载：<a href=\"https://gitee.com/eson15/springboot_study\">下载地址</a>。</p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h2 id=\"h2-4-\"><a name=\"4. 适合阅读的人群\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 适合阅读的人群</h2><p>本课程适合以下人群阅读：</p>\n<ul>\n<li>有一定的Java语言基础，了解Spring、Maven的在校学生或自学者</li><li>有传统项目经验，想往微服务方向发展的工作人员</li><li>热衷于新技术并对 Spring Boot 感兴趣的人员</li><li>希望了解 Spring Boot 2.0.3 的研究人员</li></ul>\n<h2 id=\"h2-5-\"><a name=\"5. 本课程开发环境和插件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 本课程开发环境和插件</h2><p>本课程的开发环境：</p>\n<ul>\n<li>开发工具：IDEA 2017</li><li>JDK版本： JDK 1.8</li><li>Spring Boot版本：2.0.3 RELEASE</li><li>Maven版本：3.5.2</li></ul>\n<p>涉及到的插件：</p>\n<ul>\n<li>FastJson</li><li>Swagger2</li><li>Thymeleaf</li><li>MyBatis</li><li>Redis</li><li>ActiveMQ</li><li>Shiro</li><li>Lucence</li></ul>\n<h2 id=\"h2-6-\"><a name=\"6. 课程目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 课程目录</h2><ul>\n<li>导读：课程概览</li><li>第01课：Spring Boot开发环境搭建和项目启动</li><li>第02课：Spring Boot返回Json数据及数据封装</li><li>第03课：Spring Boot使用slf4j进行日志记录</li><li>第04课：Spring Boot中的项目属性配置</li><li>第05课：Spring Boot中的MVC支持</li><li>第06课：Spring Boot集成Swagger2展现在线接口文档</li><li>第07课：Spring Boot集成Thymeleaf模板引擎</li><li>第08课：Spring Boot中的全局异常处理</li><li>第09课：Spring Boot中的切面AOP处理</li><li>第10课：Spring Boot中集成MyBatis</li><li>第11课：Spring Boot事务配置管理</li><li>第12课：Spring Boot中使用监听器</li><li>第13课：Spring Boot中使用拦截器</li><li>第14课：Spring Boot中集成Redis</li><li>第15课：Spring Boot中集成ActiveMQ</li><li>第16课：Spring Boot中集成Shiro</li><li>第17课：Spring Boot中结成Lucence</li><li>第18课：Spring Boot搭建实际项目开发中的架构</li></ul>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--01-spring-boot-\"><a name=\"第01课：Spring Boot开发环境搭建和项目启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第01课：Spring Boot开发环境搭建和项目启动</h1><p>上一节对 SpringBoot 的特性做了一个介绍，本节主要对 <strong>jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析</strong>。</p>\n<h2 id=\"h2-1-jdk-\"><a name=\"1. jdk 的配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. jdk 的配置</h2><p>本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开<code>File-&gt;Project Structure</code>，如下图所：</p>\n<p><img src=\"https://images.gitbook.cn/9befde80-8659-11e8-9b0d-95de449dc107\" alt=\"IDEA中配置jdk\"></p>\n<ol>\n<li>选择 SDKs</li><li>在 JDK home path 中选择本地 jdk 的安装目录</li><li>在 Name 中为 jdk 自定义名字</li></ol>\n<p>通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：</p>\n<ul>\n<li><code>window-&gt;preference-&gt;java-&gt;Instralled JRES</code>来添加本地 jdk。</li><li><code>window--&gt;preference--&gt;java--&gt;Compiler</code>选择 jre，和 jdk 保持一致。</li></ul>\n<h2 id=\"h2-2-spring-boot-\"><a name=\"2. Spring Boot 工程的构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Spring Boot 工程的构建</h2><h3 id=\"h3-2-1-idea-\"><a name=\"2.1 IDEA 快速构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 IDEA 快速构建</h3><p>IDEA 中可以通过<code>File-&gt;New-&gt;Project</code>来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。</p>\n<ul>\n<li>Group：填企业域名，本课程使用com.itcodai</li><li>Artifact：填项目名称，本课程中每一课的工程名以<code>course+课号</code>命令，这里使用 course01</li><li>Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。</li></ul>\n<h3 id=\"h3-2-2-\"><a name=\"2.2 官方构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 官方构建</h3><p>第二种方式可以通过官方构建，步骤如下：</p>\n<ul>\n<li>访问 <a href=\"http://start.spring.io/。\">http://start.spring.io/。</a></li><li>在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。</li><li><img src=\"https://images.gitbook.cn/014a1ba0-865b-11e8-956e-f528114b28bd\" alt=\"创建Spring Boot工程\"></li><li>解压后，使用 IDEA 导入该 maven 工程：<code>File-&gt;New-&gt;Model from Existing Source</code>，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过<code>Import-&gt;Existing Maven Projects-&gt;Next</code>，然后选择解压后的项目文件夹即可。</li></ul>\n<h3 id=\"h3-2-3-maven-\"><a name=\"2.3 maven配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 maven配置</h3><p>创建了 Spring Boot 项目之后，需要进行 maven 配置。打开<code>File-&gt;settings</code>，搜索 maven，配置一下本地的 maven 信息。如下：</p>\n<p><img src=\"https://images.gitbook.cn/2ff7b930-865b-11e8-8675-5537a701ae7d\" alt=\"maven配置\"></p>\n<p>在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。</p>\n<pre><code class=\"lang-xml\">&lt;mirror&gt;\n    &lt;id&gt;nexus-aliyun&lt;/id&gt;\n    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\n    &lt;name&gt;Nexus aliyun&lt;/name&gt;\n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n&lt;/mirror&gt;\n</code></pre>\n<p>如果是使用 eclipse 的朋友，可以通过<code>window--&gt;preference--&gt;Maven--&gt;User Settings</code>来配置，配置方式和上面一致。</p>\n<h3 id=\"h3-2-4-\"><a name=\"2.4 编码配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 编码配置</h3><p>同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。</p>\n<p>IDEA 中，仍然是打开<code>File-&gt;settings</code>，搜索 encoding，配置一下本地的编码信息。如下：</p>\n<p><img src=\"https://images.gitbook.cn/57564e60-865b-11e8-8a91-d70bc2d847c5\" alt=\"编码配置\"></p>\n<p>如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：</p>\n<ul>\n<li>window—&gt; perferences—&gt;General—&gt;Workspace，将Text file encoding改成utf-8</li><li>window—&gt;perferences—&gt;General—&gt;content types，选中Text，将Default encoding填入utf-8</li></ul>\n<p>OK，编码设置完成即可启动项目工程了。</p>\n<h2 id=\"h2-3-spring-boot-\"><a name=\"3. Spring Boot 项目工程结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Spring Boot 项目工程结构</h2><p>Spring Boot 项目总共有三个模块，如下图所示：</p>\n<p><img src=\"https://images.gitbook.cn/8b32fa80-865b-11e8-9d13-03ea4b4d8504\" alt=\"Spring Boot项目工程结构\"></p>\n<ul>\n<li>src/main/java路径：主要编写业务程序</li><li>src/main/resources路径：存放静态文件和配置文件</li><li>src/test/java路径：主要编写测试程序</li></ul>\n<p>默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个<code><a href=\"https://github.com/SpringBootApplication\" title=\"&#64;SpringBootApplication\" class=\"at-link\">@SpringBootApplication</a></code>注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。</p>\n<p>到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：</p>\n<pre><code class=\"lang-java\">package com.itcodai.course01.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(&quot;/start&quot;)\npublic class StartController {\n\n    @RequestMapping(&quot;/springboot&quot;)\n    public String startSpringBoot() {\n        return &quot;Welcome to the world of Spring Boot!&quot;;\n    }\n}\n</code></pre>\n<p>重新运行 main 方法启动项目，在浏览器中输入 <code>localhost:8080/start/springboot</code>，如果看到 <code>“Welcome to the world of Spring Boot!”</code>，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 <code>server.port</code> 来人为指定端口，如8001端口：</p>\n<pre><code class=\"lang-xml\">server:\n  port: 8001\n</code></pre>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。<br>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--02-spring-boot-json-\"><a name=\"第02课：Spring Boot返回Json数据及数据封装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第02课：Spring Boot返回Json数据及数据封装</h1><p>在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用<code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code>注解即可返回 Json 格式的数据，<code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code>也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。</p>\n<pre><code class=\"lang-java\">@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default &quot;&quot;;\n}\n</code></pre>\n<p>可以看出， <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 注解包含了原来的 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 和 <code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 注解，使用过 Spring 的朋友对 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 注解已经非常了解了，这里不再赘述， <code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 <code>spring-boot-starter-web</code> 依赖，可以看到一个 <code>spring-boot-starter-json</code> 依赖：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;\n    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Spring Boot 中对依赖都做了很好的封装，可以看到很多 <code>spring-boot-starter-xxx</code> 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 <code>spring-boot-starter-json</code> 依赖，可以看到：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.6&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;\n    &lt;version&gt;2.9.6&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;\n    &lt;version&gt;2.9.6&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;\n    &lt;version&gt;2.9.6&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。</p>\n<h2 id=\"h2-1-spring-boot-json-\"><a name=\"1. Spring Boot 默认对Json的处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Spring Boot 默认对Json的处理</h2><p>在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。</p>\n<h3 id=\"h3-1-1-user-\"><a name=\"1.1 创建 User 实体类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 创建 User 实体类</h3><p>为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。</p>\n<pre><code class=\"lang-java\">public class User {\n    private Long id;\n    private String username;\n    private String password;\n    /* 省略get、set和带参构造方法 */\n}\n</code></pre>\n<h3 id=\"h3-1-2-controller-\"><a name=\"1.2 创建Controller类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 创建Controller类</h3><p>然后我们创建一个 Controller，分别返回 <code>User</code>对象、<code>List&lt;User&gt;</code> 和 <code>Map&lt;String, Object&gt;</code>。</p>\n<pre><code class=\"lang-java\">import com.itcodai.course02.entity.User;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(&quot;/json&quot;)\npublic class JsonController {\n\n    @RequestMapping(&quot;/user&quot;)\n    public User getUser() {\n        return new User(1, &quot;倪升武&quot;, &quot;123456&quot;);\n    }\n\n    @RequestMapping(&quot;/list&quot;)\n    public List&lt;User&gt; getUserList() {\n        List&lt;User&gt; userList = new ArrayList&lt;&gt;();\n        User user1 = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);\n        User user2 = new User(2, &quot;达人课&quot;, &quot;123456&quot;);\n        userList.add(user1);\n        userList.add(user2);\n        return userList;\n    }\n\n    @RequestMapping(&quot;/map&quot;)\n    public Map&lt;String, Object&gt; getMap() {\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);\n        User user = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);\n        map.put(&quot;作者信息&quot;, user);\n        map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);\n        map.put(&quot;CSDN地址&quot;, &quot;http://blog.csdn.net/eson_15&quot;);\n        map.put(&quot;粉丝数量&quot;, 4153);\n        return map;\n    }\n}\n</code></pre>\n<h3 id=\"h3-1-3-json\"><a name=\"1.3 测试不同数据类型返回的json\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 测试不同数据类型返回的json</h3><p>OK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。</p>\n<p>在浏览器中输入：<code>localhost:8080/json/user</code> 返回 json 如下：</p>\n<pre><code class=\"lang-json\">{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;123456&quot;}\n</code></pre>\n<p>在浏览器中输入：<code>localhost:8080/json/list</code> 返回 json 如下：</p>\n<pre><code class=\"lang-json\">[{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;123456&quot;},{&quot;id&quot;:2,&quot;username&quot;:&quot;达人课&quot;,&quot;password&quot;:&quot;123456&quot;}]\n</code></pre>\n<p>在浏览器中输入：<code>localhost:8080/json/map</code> 返回 json 如下：</p>\n<pre><code class=\"lang-json\">{&quot;作者信息&quot;:{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;123456&quot;},&quot;CSDN地址&quot;:&quot;http://blog.csdn.net/eson_15&quot;,&quot;粉丝数量&quot;:4153,&quot;博客地址&quot;:&quot;http://blog.itcodai.com&quot;}\n</code></pre>\n<p>可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。</p>\n<h3 id=\"h3-1-4-jackson-null-\"><a name=\"1.4 jackson 中对null的处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.4 jackson 中对null的处理</h3><p>在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 “” 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：</p>\n<pre><code class=\"lang-java\">import com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\n\nimport java.io.IOException;\n\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    @Primary\n    @ConditionalOnMissingBean(ObjectMapper.class)\n    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n        ObjectMapper objectMapper = builder.createXmlMapper(false).build();\n        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(&quot;&quot;);\n            }\n        });\n        return objectMapper;\n    }\n}\n</code></pre>\n<p>然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/map&quot;)\npublic Map&lt;String, Object&gt; getMap() {\n    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);\n    User user = new User(1, &quot;倪升武&quot;, null);\n    map.put(&quot;作者信息&quot;, user);\n    map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);\n    map.put(&quot;CSDN地址&quot;, null);\n    map.put(&quot;粉丝数量&quot;, 4153);\n    return map;\n}\n</code></pre>\n<p>重启项目，再次输入：<code>localhost:8080/json/map</code>，可以看到 jackson 已经将所有 null 字段转成了空字符串了。</p>\n<pre><code class=\"lang-json\">{&quot;作者信息&quot;:{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;&quot;},&quot;CSDN地址&quot;:&quot;&quot;,&quot;粉丝数量&quot;:4153,&quot;博客地址&quot;:&quot;http://blog.itcodai.com&quot;}\n</code></pre>\n<h2 id=\"h2-2-fastjson-\"><a name=\"2. 使用阿里巴巴FastJson的设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用阿里巴巴FastJson的设置</h2><h3 id=\"h3-2-1-jackson-fastjson-\"><a name=\"2.1 jackson 和 fastJson 的对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 jackson 和 fastJson 的对比</h3><p>有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">选项</th>\n<th style=\"text-align:center\">fastJson</th>\n<th style=\"text-align:center\">jackson</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">上手难易程度</td>\n<td style=\"text-align:center\">容易</td>\n<td style=\"text-align:center\">中等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">高级特性支持</td>\n<td style=\"text-align:center\">中等</td>\n<td style=\"text-align:center\">丰富</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">官方文档、Example支持</td>\n<td style=\"text-align:center\">中文</td>\n<td style=\"text-align:center\">英文</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">处理json速度</td>\n<td style=\"text-align:center\">略快</td>\n<td style=\"text-align:center\">快</td>\n</tr>\n</tbody>\n</table>\n<p>关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。</p>\n<h3 id=\"h3-2-2-fastjson-\"><a name=\"2.2 fastJson依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 fastJson依赖导入</h3><p>使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.35&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3-2-2-fastjson-null\"><a name=\"2.2 使用 fastJson 处理 null\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 使用 fastJson 处理 null</h3><p>使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承  <code>WebMvcConfigurationSupport</code> 类，然后覆盖 <code>configureMessageConverters</code> 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：</p>\n<pre><code class=\"lang-java\">import com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.alibaba.fastjson.support.config.FastJsonConfig;\nimport com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Configuration\npublic class fastJsonConfig extends WebMvcConfigurationSupport {\n\n    /**\n     * 使用阿里 FastJson 作为JSON MessageConverter\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {\n        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(\n                // 保留map空的字段\n                SerializerFeature.WriteMapNullValue,\n                // 将String类型的null转成&quot;&quot;\n                SerializerFeature.WriteNullStringAsEmpty,\n                // 将Number类型的null转成0\n                SerializerFeature.WriteNullNumberAsZero,\n                // 将List类型的null转成[]\n                SerializerFeature.WriteNullListAsEmpty,\n                // 将Boolean类型的null转成false\n                SerializerFeature.WriteNullBooleanAsFalse,\n                // 避免循环引用\n                SerializerFeature.DisableCircularReferenceDetect);\n\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));\n        List&lt;MediaType&gt; mediaTypeList = new ArrayList&lt;&gt;();\n        // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = &quot;application/json&quot;\n        mediaTypeList.add(MediaType.APPLICATION_JSON);\n        converter.setSupportedMediaTypes(mediaTypeList);\n        converters.add(converter);\n    }\n}\n</code></pre>\n<h2 id=\"h2-3-\"><a name=\"3. 封装统一返回的数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 封装统一返回的数据结构</h2><p>以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。 </p>\n<h3 id=\"h3-3-1-json-\"><a name=\"3.1 定义统一的 json 结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 定义统一的 json 结构</h3><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p>\n<pre><code class=\"lang-java\">public class JsonResult&lt;T&gt; {\n\n    private T data;\n    private String code;\n    private String msg;\n\n    /**\n     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！\n     */\n    public JsonResult() {\n        this.code = &quot;0&quot;;\n        this.msg = &quot;操作成功！&quot;;\n    }\n\n    /**\n     * 若没有数据返回，可以人为指定状态码和提示信息\n     * @param code\n     * @param msg\n     */\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    /**\n     * 有数据返回时，状态码为0，默认提示信息为：操作成功！\n     * @param data\n     */\n    public JsonResult(T data) {\n        this.data = data;\n        this.code = &quot;0&quot;;\n        this.msg = &quot;操作成功！&quot;;\n    }\n\n    /**\n     * 有数据返回，状态码为0，人为指定提示信息\n     * @param data\n     * @param msg\n     */\n    public JsonResult(T data, String msg) {\n        this.data = data;\n        this.code = &quot;0&quot;;\n        this.msg = msg;\n    }\n    // 省略get和set方法\n}\n</code></pre>\n<h3 id=\"h3-3-2-controller-\"><a name=\"3.2 修改 Controller 中的返回值类型及测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 修改 Controller 中的返回值类型及测试</h3><p>由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/jsonresult&quot;)\npublic class JsonResultController {\n\n    @RequestMapping(&quot;/user&quot;)\n    public JsonResult&lt;User&gt; getUser() {\n        User user = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);\n        return new JsonResult&lt;&gt;(user);\n    }\n\n    @RequestMapping(&quot;/list&quot;)\n    public JsonResult&lt;List&gt; getUserList() {\n        List&lt;User&gt; userList = new ArrayList&lt;&gt;();\n        User user1 = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);\n        User user2 = new User(2, &quot;达人课&quot;, &quot;123456&quot;);\n        userList.add(user1);\n        userList.add(user2);\n        return new JsonResult&lt;&gt;(userList, &quot;获取用户列表成功&quot;);\n    }\n\n    @RequestMapping(&quot;/map&quot;)\n    public JsonResult&lt;Map&gt; getMap() {\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);\n        User user = new User(1, &quot;倪升武&quot;, null);\n        map.put(&quot;作者信息&quot;, user);\n        map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);\n        map.put(&quot;CSDN地址&quot;, null);\n        map.put(&quot;粉丝数量&quot;, 4153);\n        return new JsonResult&lt;&gt;(map);\n    }\n}\n</code></pre>\n<p>我们重新在浏览器中输入：<code>localhost:8080/jsonresult/user</code> 返回 json 如下：</p>\n<pre><code class=\"lang-json\">{&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:{&quot;id&quot;:1,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;倪升武&quot;},&quot;msg&quot;:&quot;操作成功！&quot;}\n</code></pre>\n<p>输入：<code>localhost:8080/jsonresult/list</code>，返回 json 如下：</p>\n<pre><code class=\"lang-json\">{&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:[{&quot;id&quot;:1,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;倪升武&quot;},{&quot;id&quot;:2,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;达人课&quot;}],&quot;msg&quot;:&quot;获取用户列表成功&quot;}\n</code></pre>\n<p>输入：<code>localhost:8080/jsonresult/map</code>，返回 json 如下：</p>\n<pre><code class=\"lang-json\">{&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:{&quot;作者信息&quot;:{&quot;id&quot;:1,&quot;password&quot;:&quot;&quot;,&quot;username&quot;:&quot;倪升武&quot;},&quot;CSDN地址&quot;:null,&quot;粉丝数量&quot;:4153,&quot;博客地址&quot;:&quot;http://blog.itcodai.com&quot;},&quot;msg&quot;:&quot;操作成功！&quot;}\n</code></pre>\n<p>通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。</p>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。<br>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--03-spring-boot-slf4j-\"><a name=\"第03课：Spring Boot使用slf4j进行日志记录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第03课：Spring Boot使用slf4j进行日志记录</h1><p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。</p>\n<h2 id=\"h2-1-slf4j-\"><a name=\"1. slf4j 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. slf4j 介绍</h2><p>引用百度百科里的一段话：</p>\n<blockquote>\n<p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p>\n</blockquote>\n<p>这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。</p>\n<p>正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：</p>\n<blockquote>\n<p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>\n</blockquote>\n<p>“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。</p>\n<pre><code class=\"lang-java\">import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n    private static final Logger logger = LoggerFactory.getLogger(Test.class);\n    // ……\n}\n</code></pre>\n<h2 id=\"h2-2-application-yml-\"><a name=\"2. application.yml 中对日志的配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. application.yml 中对日志的配置</h2><p>Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。<code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。</p>\n<p>我们看一下 application.yml 文件中对日志的配置：</p>\n<pre><code class=\"lang-xml\">logging:\n  config: logback.xml\n  level:\n    com.itcodai.course03.dao: trace\n</code></pre>\n<p><code>logging.config</code> 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 <code>logback.xml</code> 文件，关于日志的相关配置信息，都放在 <code>logback.xml</code> 文件中了。<code>logging.level</code> 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 <code>com.itcodai.course03.dao</code> 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。</p>\n<p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p>\n<h2 id=\"h2-3-logback-xml-\"><a name=\"3. logback.xml 配置文件解析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. logback.xml 配置文件解析</h2><p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p>\n<h3 id=\"h3-3-1-\"><a name=\"3.1 定义日志输出格式和存储路径\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 定义日志输出格式和存储路径</h3><pre><code class=\"lang-xml\">&lt;configuration&gt;\n    &lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot; /&gt;\n    &lt;property name=&quot;FILE_PATH&quot; value=&quot;D:/logs/course03/demo.%d{yyyy-MM-dd}.%i.log&quot; /&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 <code>%date</code> 表示日期，<code>%thread</code> 表示线程名，<code>%-5level</code> 表示级别从左显示5个字符宽度，<code>%logger{36}</code>  表示 logger 名字最长36个字符，<code>%msg</code> 表示日志消息，<code>%n</code> 是换行符。</p>\n<p>然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p>\n<h3 id=\"h3-3-2-\"><a name=\"3.2 定义控制台输出\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 定义控制台输出</h3><pre><code class=\"lang-xml\">&lt;configuration&gt;\n    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;encoder&gt;\n            &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;\n            &lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class=&quot;ch.qos.logback.core.ConsoleAppender&quot;</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p>\n<h3 id=\"h3-3-3-\"><a name=\"3.3 定义日志文件的相关参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 定义日志文件的相关参数</h3><pre><code class=\"lang-xml\">&lt;configuration&gt;\n    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n            &lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt;\n            &lt;fileNamePattern&gt;${FILE_PATH}&lt;/fileNamePattern&gt;\n            &lt;!-- 日志保存15天 --&gt;\n            &lt;maxHistory&gt;15&lt;/maxHistory&gt;\n            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;\n                &lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt;\n                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;\n            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;\n        &lt;/rollingPolicy&gt;\n\n        &lt;encoder&gt;\n            &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;\n            &lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p>\n<h3 id=\"h3-3-4-\"><a name=\"3.4 定义日志输出级别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 定义日志输出级别</h3><pre><code class=\"lang-xml\">&lt;configuration&gt;\n    &lt;logger name=&quot;com.itcodai.course03&quot; level=&quot;INFO&quot; /&gt;\n    &lt;root level=&quot;INFO&quot;&gt;\n        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;\n        &lt;appender-ref ref=&quot;FILE&quot; /&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre>\n<p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p>\n<h2 id=\"h2-4-logger-\"><a name=\"4. 使用Logger在项目中打印日志\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 使用Logger在项目中打印日志</h2><p>在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。</p>\n<pre><code class=\"lang-java\">import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(&quot;/test&quot;)\npublic class TestController {\n\n    private final static Logger logger = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(&quot;/log&quot;)\n    public String testLog() {\n        logger.debug(&quot;=====测试日志debug级别打印====&quot;);\n        logger.info(&quot;======测试日志info级别打印=====&quot;);\n        logger.error(&quot;=====测试日志error级别打印====&quot;);\n        logger.warn(&quot;======测试日志warn级别打印=====&quot;);\n\n        // 可以使用占位符打印出一些参数信息\n        String str1 = &quot;blog.itcodai.com&quot;;\n        String str2 = &quot;blog.csdn.net/eson_15&quot;;\n        logger.info(&quot;======倪升武的个人博客：{}；倪升武的CSDN博客：{}&quot;, str1, str2);\n\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<p>启动该项目，在浏览器中输入 <code>localhost:8080/test/log</code> 后可以看到控制台的日志记录：</p>\n<blockquote>\n<p>======测试日志info级别打印=====<br>=====测试日志error级别打印====<br>======测试日志warn级别打印=====<br>======倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15</p>\n</blockquote>\n<p>因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\\logs\\course03\\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。</p>\n<h2 id=\"h2-5-\"><a name=\"5. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 总结</h2><p>本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 <code>logback.xml</code> 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。<br>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--04-spring-boot-\"><a name=\"第04课：Spring Boot中的项目属性配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第04课：Spring Boot中的项目属性配置</h1><p>我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 <code>application.yml</code> 文件中。   </p>\n<h2 id=\"h2-1-\"><a name=\"1. 少量配置信息的情形\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 少量配置信息的情形</h2><p>举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：</p>\n<pre><code class=\"lang-xml\">server:\n  port: 8001\n\n# 配置微服务的地址\nurl:\n  # 订单微服务的地址\n  orderUrl: http://localhost:8002\n</code></pre>\n<p>然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 <code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code> 注解来解决。在对应的类中加上一个属性，在属性上使用 <code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code> 注解即可获取到配置文件中的配置信息，如下：</p>\n<pre><code class=\"lang-java\">import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(&quot;/test&quot;)\npublic class ConfigController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class);\n\n    @Value(&quot;${url.orderUrl}&quot;)\n    private String orderUrl;\n\n    @RequestMapping(&quot;/config&quot;)\n    public String testConfig() {\n        LOGGER.info(&quot;=====获取的订单服务地址为：{}&quot;, orderUrl);\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<p><code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code> 注解上通过 <code>${key}</code> 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 <code>localhost:8080/test/config</code> 请求服务后，可以看到控制台会打印出订单服务的地址：</p>\n<pre><code>=====获取的订单服务地址为：http://localhost:8002\n</code></pre><p>说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。  </p>\n<h2 id=\"h2-2-\"><a name=\"2. 多个配置信息的情形\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 多个配置信息的情形</h2><p>这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 <code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code> 注解引入相应的微服务地址的话，太过于繁琐，也不科学。</p>\n<p>所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：</p>\n<pre><code class=\"lang-xml\"># 配置多个微服务的地址\nurl:\n  # 订单微服务的地址\n  orderUrl: http://localhost:8002\n  # 用户微服务的地址\n  userUrl: http://localhost:8003\n  # 购物车微服务的地址\n  shoppingUrl: http://localhost:8004\n</code></pre>\n<p>也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 <code>MicroServiceUrl</code> 类来专门保存微服务的 url，如下：</p>\n<pre><code class=\"lang-java\">@Component\n@ConfigurationProperties(prefix = &quot;url&quot;)\npublic class MicroServiceUrl {\n\n    private String orderUrl;\n    private String userUrl;\n    private String shoppingUrl;\n    // 省去get和set方法\n}\n</code></pre>\n<p>细心的朋友应该可以看到，使用 <code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code> 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 <code><a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a></code> 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。</p>\n<p>需要注意的是，使用 <code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code> 注解需要导入它的依赖：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 <code><a href=\"https://github.com/Resource\" title=\"&#64;Resource\" class=\"at-link\">@Resource</a></code> 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/test&quot;)\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @Resource\n    private MicroServiceUrl microServiceUrl;\n\n    @RequestMapping(&quot;/config&quot;)\n    public String testConfig() {\n        LOGGER.info(&quot;=====获取的订单服务地址为：{}&quot;, microServiceUrl.getOrderUrl());\n        LOGGER.info(&quot;=====获取的用户服务地址为：{}&quot;, microServiceUrl.getUserUrl());\n        LOGGER.info(&quot;=====获取的购物车服务地址为：{}&quot;, microServiceUrl.getShoppingUrl());\n\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<p>再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：</p>\n<pre><code>=====获取的订单服务地址为：http://localhost:8002\n=====获取的订单服务地址为：http://localhost:8002\n=====获取的用户服务地址为：http://localhost:8003\n=====获取的购物车服务地址为：http://localhost:8004\n</code></pre><h2 id=\"h2-3-\"><a name=\"3. 指定项目配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 指定项目配置文件</h2><p>我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。</p>\n<p>最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。</p>\n<p>我们新建两个配置文件： <code>application-dev.yml</code> 和 <code>application-pro.yml</code>，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.</p>\n<pre><code class=\"lang-xml\"># 开发环境配置文件\nserver:\n  port: 8001\n</code></pre>\n<pre><code class=\"lang-xml\"># 开发环境配置文件\nserver:\n  port: 8002\n</code></pre>\n<p>然后在 <code>application.yml</code> 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 <code>applicationn-dev.yml</code> 文件，如下：</p>\n<pre><code class=\"lang-xml\">spring:\n  profiles:\n    active:\n    - dev\n</code></pre>\n<p>这样就可以在开发的时候，指定读取  <code>application-dev.yml</code> 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 <code>application.yml</code> 中指定的文件改成 <code>application-pro.yml</code> 即可，然后使用 8002 端口访问，非常方便。</p>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。<br>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--05-spring-boot-mvc-\"><a name=\"第05课：Spring Boot中的MVC支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第05课：Spring Boot中的MVC支持</h1><p>Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code>、 <code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code>、<code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code>、<code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 以及 <code><a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></code>。主要介绍这几个注解常用的使用方式和特点。  </p>\n<h2 id=\"h2-1-restcontroller\"><a name=\"1. @RestController\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. <a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></h2><p><code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。</p>\n<pre><code class=\"lang-java\">@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default &quot;&quot;;\n}\n</code></pre>\n<p>可以看出， <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 注解包含了原来的 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 和 <code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 注解，使用过 Spring 的朋友对 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 注解已经非常了解了，这里不再赘述， <code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 注解是将返回的数据结构转换为 Json 格式。所以 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 可以看作是 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 和 <code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 的结合体，相当于偷个懒，我们使用 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 之后就不用再使用 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用<code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用<code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code>了，比如：</p>\n<pre><code class=\"lang-java\">public String getUser() {\n    return &quot;user&quot;;\n}\n</code></pre>\n<p>其实是需要返回到 user.html 页面的，如果使用 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。</p>\n<h2 id=\"h2-2-requestmapping\"><a name=\"2. @RequestMapping\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. <a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></h2><p><code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code> 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。</p>\n<p>该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。</p>\n<ul>\n<li>value 属性：指定请求的实际地址，value 可以省略不写</li><li>method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET</li><li>produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8”</li></ul>\n<p><code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code> 注解比较简单，举个例子：</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(value = &quot;/test&quot;, produces = &quot;application/json; charset=UTF-8&quot;)\npublic class TestController {\n\n    @RequestMapping(value = &quot;/get&quot;, method = RequestMethod.GET)\n    public String testGet() {\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<p>这个很简单，启动项目在浏览器中输入 <code>localhost:8080/test/get</code> 测试一下即可。</p>\n<p>针对四种不同的请求方式，是有相应注解的，不用每次在 <code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code> 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 <code><a href=\"https://github.com/GetMapping\" title=\"&#64;GetMapping\" class=\"at-link\">@GetMapping</a>(&quot;/get&quot;)</code> 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code><a href=\"https://github.com/PutMapping\" title=\"&#64;PutMapping\" class=\"at-link\">@PutMapping</a></code>、<code><a href=\"https://github.com/PostMapping\" title=\"&#64;PostMapping\" class=\"at-link\">@PostMapping</a></code> 和 <code>DeleteMapping</code>。</p>\n<h2 id=\"h2-3-pathvariable\"><a name=\"3. @PathVariable\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. <a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></h2><p><code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code> 注解。如下：</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/user/{id}&quot;)\npublic String testPathVariable(@PathVariable Integer id) {\n    System.out.println(&quot;获取到的id为：&quot; + id);\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 <code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code> 中的 value 属性来指定对应关系。如下：</p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/user/{idd}&quot;)\npublic String testPathVariable(@PathVariable(value = &quot;idd&quot;) Integer id) {\n    System.out.println(&quot;获取到的id为：&quot; + id);\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：<code>/xxx/{id}/user</code>。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/user/{idd}/{name}&quot;)\n    public String testPathVariable(@PathVariable(value = &quot;idd&quot;) Integer id, @PathVariable String name) {\n        System.out.println(&quot;获取到的id为：&quot; + id);\n        System.out.println(&quot;获取到的name为：&quot; + name);\n        return &quot;success&quot;;\n    }\n</code></pre>\n<p>运行项目，在浏览器中请求 <code>localhost:8080/test/user/2/zhangsan</code> 可以看到控制台输出如下信息：</p>\n<pre><code>获取到的id为：2\n获取到的name为：zhangsan\n</code></pre><p>所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。</p>\n<h2 id=\"h2-4-requestparam\"><a name=\"4. @RequestParam\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. <a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></h2><p><code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 注解顾名思义，也是获取请求参数的，上面我们介绍了 <code><a href=\"https://github.com/PathValiable\" title=\"&#64;PathValiable\" class=\"at-link\">@PathValiable</a></code> 注解也是获取请求参数的，那么 <code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 和 <code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code> 有什么不同呢？主要区别在于： <code><a href=\"https://github.com/PathValiable\" title=\"&#64;PathValiable\" class=\"at-link\">@PathValiable</a></code> 是从 url 模板中获取参数值， 即这种风格的 url：<code>http://localhost:8080/user/{id}</code> ；而 <code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 是从 request 里面获取参数值，即这种风格的 url：<code>http://localhost:8080/user?id=1</code>  。我们使用该 url 带上参数 id 来测试一下如下代码：</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/user&quot;)\npublic String testRequestParam(@RequestParam Integer id) {\n    System.out.println(&quot;获取到的id为：&quot; + id);\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：<code>http://localhost:8080/user?idd=1</code></p>\n<pre><code class=\"lang-java\">@RequestMapping(&quot;/user&quot;)\npublic String testRequestParam(@RequestParam(value = &quot;idd&quot;, required = false) Integer id) {\n    System.out.println(&quot;获取到的id为：&quot; + id);\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>除了 value 属性外，还有个两个属性比较常用：</p>\n<ul>\n<li>required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li><li>defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。</li></ul>\n<p>从 url 中可以看出，<code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 <code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 来接收，用法和上面一样。</p>\n<pre><code class=\"lang-java\">@PostMapping(&quot;/form1&quot;)\n    public String testForm(@RequestParam String username, @RequestParam String password) {\n        System.out.println(&quot;获取到的username为：&quot; + username);\n        System.out.println(&quot;获取到的password为：&quot; + password);\n        return &quot;success&quot;;\n    }\n</code></pre>\n<p>我们使用 postman 来模拟一下表单提交，测试一下接口：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215043749282.png\" alt=\"使用postman测试表单提交\"></p>\n<p>那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 <code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。</p>\n<pre><code class=\"lang-java\">public class User {\n    private String username;\n    private String password;\n    // set get\n}\n</code></pre>\n<p>使用实体接收的话，我们不能在前面加 <code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 注解了，直接使用即可。</p>\n<pre><code class=\"lang-java\">@PostMapping(&quot;/form2&quot;)\n    public String testForm(User user) {\n        System.out.println(&quot;获取到的username为：&quot; + user.getUsername());\n        System.out.println(&quot;获取到的password为：&quot; + user.getPassword());\n        return &quot;success&quot;;\n    }\n</code></pre>\n<p>使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。</p>\n<h2 id=\"h2-5-requestbody\"><a name=\"5. @RequestBody\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. <a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></h2><p><code><a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></code> 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 <code><a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></code> 接收会非常方便。例如：</p>\n<pre><code class=\"lang-java\">public class User {\n    private String username;\n    private String password;\n    // set get\n}\n</code></pre>\n<pre><code class=\"lang-java\">@PostMapping(&quot;/user&quot;)\npublic String testRequestBody(@RequestBody User user) {\n    System.out.println(&quot;获取到的username为：&quot; + user.getUsername());\n    System.out.println(&quot;获取到的password为：&quot; + user.getPassword());\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215043853532.png\" alt=\"使用Postman测试requestBody\"></p>\n<p>同时看一下后台控制台输出的日志：</p>\n<pre><code>获取到的username为：倪升武\n获取到的password为：123456\n</code></pre><p>可以看出，<code><a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></code> 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。</p>\n<h2 id=\"h2-6-\"><a name=\"6. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 总结</h2><p>本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code>、 <code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code>、<code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code>、 <code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code> 和 <code><a href=\"https://github.com/RequestBody\" title=\"&#64;RequestBody\" class=\"at-link\">@RequestBody</a></code> 四个注解的使用方式，由于 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 中集成了 <code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--06-spring-boot-swagger2-\"><a name=\"第06课：Spring Boot集成 Swagger2 展现在线接口文档\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第06课：Spring Boot集成 Swagger2 展现在线接口文档</h1><h2 id=\"h2-1-swagger-\"><a name=\"1. Swagger 简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Swagger 简介</h2><h3 id=\"h3-1-1-\"><a name=\"1.1 解决的问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 解决的问题</h3><p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。</p>\n<p>那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。</p>\n<h3 id=\"h3-1-2-swagger-\"><a name=\"1.2 Swagger 官方\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 Swagger 官方</h3><p>我们打开 <a href=\"https://swagger.io/\">Swagger 官网</a>，官方对 Swagger 的定义为：</p>\n<blockquote>\n<p>The Best APIs are Built with Swagger Tools </p>\n</blockquote>\n<p>翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215043936444.png\" alt=\"官方对swagger的定位\"></p>\n<p>本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。</p>\n<h2 id=\"h2-2-swagger2-maven-\"><a name=\"2. Swagger2 的 maven 依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Swagger2 的 maven 依赖</h2><p>使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"h2-3-swagger2-\"><a name=\"3. Swagger2 的配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Swagger2 的配置</h2><p>使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 <code><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a></code> 注解外，还需要添加 <code><a href=\"https://github.com/EnableSwagger2\" title=\"&#64;EnableSwagger2\" class=\"at-link\">@EnableSwagger2</a></code> 注解。</p>\n<pre><code class=\"lang-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n * @author shengwu ni\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                // 指定构建api文档的详细信息的方法：apiInfo()\n                .apiInfo(apiInfo())\n                .select()\n                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口\n                .apis(RequestHandlerSelectors.basePackage(&quot;com.itcodai.course06.controller&quot;))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 构建api文档的详细信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                // 设置页面标题\n                .title(&quot;Spring Boot集成Swagger2接口总览&quot;)\n                // 设置接口描述\n                .description(&quot;跟武哥一起学Spring Boot第06课&quot;)\n                // 设置联系方式\n                .contact(&quot;倪升武，&quot; + &quot;CSDN：http://blog.csdn.net/eson_15&quot;)\n                // 设置版本\n                .version(&quot;1.0&quot;)\n                // 构建\n                .build();\n    }\n}\n</code></pre>\n<p>在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code>，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215044013383.png\" alt=\"swagger2页面\"></p>\n<p>结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。</p>\n<p>【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。</p>\n<p><img src=\"http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png\" alt=\"错误页面-倪升武的博客-图2\"></p>\n<h2 id=\"h2-4-swagger2-\"><a name=\"4. Swagger2 的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Swagger2 的使用</h2><p>上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。</p>\n<h3 id=\"h3-4-1-\"><a name=\"4.1 实体类注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 实体类注解</h3><p>本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 <code><a href=\"https://github.com/ApiModel\" title=\"&#64;ApiModel\" class=\"at-link\">@ApiModel</a></code> 和 <code><a href=\"https://github.com/ApiModelProperty\" title=\"&#64;ApiModelProperty\" class=\"at-link\">@ApiModelProperty</a></code> 注解，同时为后面的测试做准备。</p>\n<pre><code class=\"lang-java\">import io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\n\n@ApiModel(value = &quot;用户实体类&quot;)\npublic class User {\n\n    @ApiModelProperty(value = &quot;用户唯一标识&quot;)\n    private Long id;\n\n    @ApiModelProperty(value = &quot;用户姓名&quot;)\n    private String username;\n\n    @ApiModelProperty(value = &quot;用户密码&quot;)\n    private String password;\n\n    // 省略set和get方法\n}\n</code></pre>\n<p>解释下 <code><a href=\"https://github.com/ApiModel\" title=\"&#64;ApiModel\" class=\"at-link\">@ApiModel</a></code> 和 <code><a href=\"https://github.com/ApiModelProperty\" title=\"&#64;ApiModelProperty\" class=\"at-link\">@ApiModelProperty</a></code> 注解：</p>\n<blockquote>\n<p><code><a href=\"https://github.com/ApiModel\" title=\"&#64;ApiModel\" class=\"at-link\">@ApiModel</a></code> 注解用于实体类，表示对类进行说明，用于参数用实体类接收。<br><code><a href=\"https://github.com/ApiModelProperty\" title=\"&#64;ApiModelProperty\" class=\"at-link\">@ApiModelProperty</a></code> 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。</p>\n</blockquote>\n<p>该注解在在线 API 文档中的具体效果在下文说明。</p>\n<h3 id=\"h3-4-2-controller-\"><a name=\"4.2 Controller 类中相关注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 Controller 类中相关注解</h3><p>我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。</p>\n<pre><code class=\"lang-java\">import com.itcodai.course06.entiy.JsonResult;\nimport com.itcodai.course06.entiy.User;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(&quot;/swagger&quot;)\n@Api(value = &quot;Swagger2 在线接口文档&quot;)\npublic class TestController {\n\n    @GetMapping(&quot;/get/{id}&quot;)\n    @ApiOperation(value = &quot;根据用户唯一标识获取用户信息&quot;)\n    public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = &quot;用户唯一标识&quot;) Long id) {\n        // 模拟数据库中根据id获取User信息\n        User user = new User(id, &quot;倪升武&quot;, &quot;123456&quot;);\n        return new JsonResult(user);\n    }\n}\n</code></pre>\n<p>我们来学习一下 <code><a href=\"https://github.com/Api\" title=\"&#64;Api\" class=\"at-link\">@Api</a></code> 、 <code><a href=\"https://github.com/ApiOperation\" title=\"&#64;ApiOperation\" class=\"at-link\">@ApiOperation</a></code> 和 <code><a href=\"https://github.com/ApiParam\" title=\"&#64;ApiParam\" class=\"at-link\">@ApiParam</a></code> 注解。</p>\n<blockquote>\n<p><code><a href=\"https://github.com/Api\" title=\"&#64;Api\" class=\"at-link\">@Api</a></code> 注解用于类上，表示标识这个类是 swagger 的资源。<br><code><a href=\"https://github.com/ApiOperation\" title=\"&#64;ApiOperation\" class=\"at-link\">@ApiOperation</a></code> 注解用于方法，表示一个 http 请求的操作。<br><code><a href=\"https://github.com/ApiParam\" title=\"&#64;ApiParam\" class=\"at-link\">@ApiParam</a></code> 注解用于参数上，用来标明参数信息。</p>\n</blockquote>\n<p>这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下 Swagger 页面的接口状态。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215044156305.png\" alt=\"swagger接口展示\"></p>\n<p>可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215044226292.png\" alt=\"返回数据测试\"></p>\n<p>可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。</p>\n<pre><code class=\"lang-java\">@PostMapping(&quot;/insert&quot;)\n    @ApiOperation(value = &quot;添加用户信息&quot;)\n    public JsonResult&lt;Void&gt; insertUser(@RequestBody @ApiParam(value = &quot;用户信息&quot;) User user) {\n        // 处理添加逻辑\n        return new JsonResult&lt;&gt;();\n    }\n</code></pre>\n<p>重启项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下效果：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215044256579.png\" alt=\"swagger接口展示\"></p>\n<h2 id=\"h2-5-\"><a name=\"5. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 总结</h2><p>OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--07-spring-boot-thymeleaf-\"><a name=\"第07课：Spring Boot集成Thymeleaf模板引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第07课：Spring Boot集成Thymeleaf模板引擎</h1><h2 id=\"h2-1-thymeleaf-\"><a name=\"1. Thymeleaf 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Thymeleaf 介绍</h2><blockquote>\n<p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。<br>Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。  </p>\n</blockquote>\n<p>以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。   </p>\n<p>什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：</p>\n<pre><code class=\"lang-html\">&lt;div class=&quot;ui right aligned basic segment&quot;&gt;\n      &lt;div class=&quot;ui orange basic label&quot; th:text=&quot;${blog.flag}&quot;&gt;静态原创信息&lt;/div&gt;\n&lt;/div&gt;\n&lt;h2 class=&quot;ui center aligned header&quot; th:text=&quot;${blog.title}&quot;&gt;这是静态标题&lt;/h2&gt;\n</code></pre>\n<p>类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，<code>th:text</code> 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 <code>th:text</code>），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。 </p>\n<h2 id=\"h2-2-\"><a name=\"2. 依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 依赖导入</h2><p>在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：</p>\n<pre><code class=\"lang-html\">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n</code></pre>\n<h2 id=\"h2-3-thymeleaf-\"><a name=\"3. Thymeleaf相关配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Thymeleaf相关配置</h2><p>因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。</p>\n<pre><code class=\"lang-yml\">spring:\n  thymeleaf:\n    cache: false #关闭缓存\n</code></pre>\n<p>否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。</p>\n<h2 id=\"h2-4-thymeleaf-\"><a name=\"4. Thymeleaf 的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Thymeleaf 的使用</h2><h3 id=\"h3-4-1-\"><a name=\"4.1 访问静态页面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 访问静态页面</h3><p>这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：</p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    这是404页面\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>我们再写一个 controller 来测试一下 404 和 500 页面：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/thymeleaf&quot;)\npublic class ThymeleafController {\n\n    @RequestMapping(&quot;/test404&quot;)\n    public String test404() {\n        return &quot;index&quot;;\n    }\n\n    @RequestMapping(&quot;/test500&quot;)\n    public String test500() {\n        int i = 1 / 0;\n        return &quot;index&quot;;\n    }\n}\n</code></pre>\n<blockquote>\n<p>当我们在浏览器中输入 <code>localhost:8080/thymeleaf/test400</code> 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。<br>当我们在浏览器中输入 <code>localhost:8088/thymeleaf/test505</code> 时，会抛出异常，然后会自动跳转到 500.html 显示。</p>\n</blockquote>\n<p>【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 <code><a href=\"https://github.com/RestController\" title=\"&#64;RestController\" class=\"at-link\">@RestController</a></code> 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 <code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code> 注解。</p>\n<h3 id=\"h3-4-2-thymeleaf-\"><a name=\"4.2 Thymeleaf 中处理对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 Thymeleaf 中处理对象</h3><p>我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：</p>\n<pre><code class=\"lang-java\">public class Blogger {\n    private Long id;\n    private String name;\n    private String pass;\n    // 省去set和get\n}\n</code></pre>\n<p>然后在controller层中初始化一下：</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/getBlogger&quot;)\npublic String getBlogger(Model model) {\n    Blogger blogger = new Blogger(1L, &quot;倪升武&quot;, &quot;123456&quot;);\n    model.addAttribute(&quot;blogger&quot;, blogger);\n    return &quot;blogger&quot;;\n}\n</code></pre>\n<p>我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：</p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;博主信息&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;&quot; th:object=&quot;${blogger}&quot; &gt;\n    用户编号：&lt;input name=&quot;id&quot; th:value=&quot;${blogger.id}&quot;/&gt;&lt;br&gt;\n    用户姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${blogger.getName()}&quot; /&gt;&lt;br&gt;\n    登陆密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; th:value=&quot;*{pass}&quot; /&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>可以看出，在 thymeleaf 模板中，使用 <code>th:object=&quot;${}&quot;</code> 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：</p>\n<blockquote>\n<p>使用 <code>th:value=&quot;*{属性名}&quot;</code><br>使用 <code>th:value=&quot;${对象.属性名}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象<br>使用 <code>th:value=&quot;${对象.get方法}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象</p>\n</blockquote>\n<p>可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 <code>localhost:8080/thymeleaf/getBlogger</code> 来测试一下数据：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200215044353803.jpg\" alt=\"thymeleaf中处理对象\"></p>\n<h3 id=\"h3-4-3-thymeleaf-list\"><a name=\"4.3 Thymeleaf 中处理 List\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 Thymeleaf 中处理 List</h3><p>处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/getList&quot;)\npublic String getList(Model model) {\n    Blogger blogger1 = new Blogger(1L, &quot;倪升武&quot;, &quot;123456&quot;);\n    Blogger blogger2 = new Blogger(2L, &quot;达人课&quot;, &quot;123456&quot;);\n    List&lt;Blogger&gt; list = new ArrayList&lt;&gt;();\n    list.add(blogger1);\n    list.add(blogger2);\n    model.addAttribute(&quot;list&quot;, list);\n    return &quot;list&quot;;\n}\n</code></pre>\n<p>接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：</p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;博主信息&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;&quot; th:each=&quot;blogger : ${list}&quot; &gt;\n    用户编号：&lt;input name=&quot;id&quot; th:value=&quot;${blogger.id}&quot;/&gt;&lt;br&gt;\n    用户姓名：&lt;input type=&quot;text&quot; name=&quot;password&quot; th:value=&quot;${blogger.name}&quot;/&gt;&lt;br&gt;\n    登录密码：&lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${blogger.getPass()}&quot;/&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 <code>th:each</code> 进行遍历，<code>${}</code> 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 <code>${对象.属性名}</code> 来获取 list 中对象的属性值，也可以使用 <code>${对象.get方法}</code> 来获取，这点和上面处理对象信息是一样的，但是不能使用 <code>*{属性名}</code> 来获取对象中的属性，thymeleaf 模板获取不到。    </p>\n<h3 id=\"h3-4-4-thymeleaf-\"><a name=\"4.4 其他常用 thymeleaf 操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 其他常用 thymeleaf 操作</h3><p>我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：</p>\n<table>\n<thead>\n<tr>\n<th>标签</th>\n<th>功能</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>th:value</code></td>\n<td>给属性赋值</td>\n<td><code>&lt;input th:value=&quot;${blog.name}&quot; /&gt;</code></td>\n</tr>\n<tr>\n<td><code>th:style</code></td>\n<td>设置样式</td>\n<td><code>th:style=&quot;&#39;display:&#39;+@{(${sitrue}?&#39;none&#39;:&#39;inline-block&#39;)} + &#39;&#39;&quot;</code></td>\n</tr>\n<tr>\n<td><code>th:onclick</code></td>\n<td>点击事件</td>\n<td><code>th:onclick=&quot;&#39;getInfo()&#39;&quot;</code></td>\n</tr>\n<tr>\n<td><code>th:if</code></td>\n<td>条件判断</td>\n<td><code>&lt;a th:if=&quot;${userId == collect.userId}&quot; &gt;</code></td>\n</tr>\n<tr>\n<td><code>th:href</code></td>\n<td>超链接</td>\n<td><code>&lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt;</code></td>\n</tr>\n<tr>\n<td><code>th:unless</code></td>\n<td>条件判断和<code>th:if</code>相反</td>\n<td><code>&lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td>\n</tr>\n<tr>\n<td><code>th:switch</code></td>\n<td>配合<code>th:case</code></td>\n<td><code>&lt;div th:switch=&quot;${user.role}&quot;&gt;</code></td>\n</tr>\n<tr>\n<td><code>th:case</code></td>\n<td>配合<code>th:switch</code></td>\n<td><code>&lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;administator&lt;/p&gt;</code></td>\n</tr>\n<tr>\n<td><code>th:src</code></td>\n<td>地址引入</td>\n<td><code>&lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt;</code></td>\n</tr>\n<tr>\n<td><code>th:action</code></td>\n<td>表单提交的地址</td>\n<td><code>&lt;form th:action=&quot;@{/blogger/update}&quot;&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<p>Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的<a href=\"https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html\">官方文档（v3.0）</a>。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。</p>\n<h2 id=\"h2-5-\"><a name=\"5. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 总结</h2><p>Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--08-spring-boot-\"><a name=\"第08课：Spring Boot中的全局异常处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第08课：Spring Boot中的全局异常处理</h1><p>在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。<br>针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。</p>\n<h2 id=\"h2-1-json-\"><a name=\"1. 定义返回的统一 json 结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 定义返回的统一 json 结构</h2><p>前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。<br>这个统一的 json 结构这可以参考<a href=\"https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a\">第02课：Spring Boot 返回 JSON 数据及数据封装</a>中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：</p>\n<pre><code class=\"lang-java\">public class JsonResult {\n    /**\n     * 异常码\n     */\n    protected String code;\n\n    /**\n     * 异常信息\n     */\n    protected String msg;\n\n    public JsonResult() {\n        this.code = &quot;200&quot;;\n        this.msg = &quot;操作成功&quot;;\n    }\n\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n    // get set\n}\n</code></pre>\n<h2 id=\"h2-2-\"><a name=\"2. 处理系统异常\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 处理系统异常</h2><p>新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 <code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code> 注解即可拦截项目中抛出的异常，如下：</p>\n<pre><code class=\"lang-java\">@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n    // 打印log\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    // ……\n}\n</code></pre>\n<p>我们点开 <code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code> 注解可以看到，<code><a href=\"https://github.com/ControllerAdvice\" title=\"&#64;ControllerAdvice\" class=\"at-link\">@ControllerAdvice</a></code> 注解包含了 <code><a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a></code> 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 <code>basePackages</code> 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。<code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code> 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。<br>在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 <code><a href=\"https://github.com/ExceptionHandler\" title=\"&#64;ExceptionHandler\" class=\"at-link\">@ExceptionHandler</a></code> 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。</p>\n<h3 id=\"h3-2-1-\"><a name=\"2.1 处理参数缺失异常\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 处理参数缺失异常</h3><p>在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。  </p>\n<p>参数缺失的时候，会抛出 <code>HttpMessageNotReadableException</code>，我们可以拦截该异常，做一个友好处理，如下：</p>\n<pre><code class=\"lang-java\">/**\n* 缺少请求参数异常\n* @param ex HttpMessageNotReadableException\n* @return\n*/\n@ExceptionHandler(MissingServletRequestParameterException.class)\n@ResponseStatus(value = HttpStatus.BAD_REQUEST)\npublic JsonResult handleHttpMessageNotReadableException(\n    MissingServletRequestParameterException ex) {\n    logger.error(&quot;缺少请求参数，{}&quot;, ex.getMessage());\n    return new JsonResult(&quot;400&quot;, &quot;缺少必要的请求参数&quot;);\n}\n</code></pre>\n<p>我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/exception&quot;)\npublic class ExceptionController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);\n\n    @PostMapping(&quot;/test&quot;)\n    public JsonResult test(@RequestParam(&quot;name&quot;) String name,\n                           @RequestParam(&quot;pass&quot;) String pass) {\n        logger.info(&quot;name：{}&quot;, name);\n        logger.info(&quot;pass：{}&quot;, pass);\n        return new JsonResult();\n    }\n}\n</code></pre>\n<p>然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020021504443480.png\" alt=\"缺失参数异常\"></p>\n<h3 id=\"h3-2-2-\"><a name=\"2.2 处理空指针异常\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 处理空指针异常</h3><p>空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？<br>先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。<br>还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。<br>对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：</p>\n<pre><code class=\"lang-java\">@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(&quot;空指针异常，{}&quot;, ex.getMessage());\n        return new JsonResult(&quot;500&quot;, &quot;空指针异常了&quot;);\n    }\n}\n</code></pre>\n<p>这个我就不测试了，代码中 ExceptionController 有个 <code>testNullPointException</code> 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：</p>\n<pre><code class=\"lang-json\">{&quot;code&quot;:&quot;500&quot;,&quot;msg&quot;:&quot;空指针异常了&quot;}\n</code></pre>\n<h3 id=\"h3-2-3-\"><a name=\"2.3 一劳永逸？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 一劳永逸？</h3><p>当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：</p>\n<pre><code class=\"lang-java\">@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(&quot;系统异常：&quot;, ex);\n        return new JsonResult(&quot;500&quot;, &quot;系统发生异常，请联系管理员&quot;);\n    }\n}\n</code></pre>\n<p>但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。</p>\n<h2 id=\"h2-3-\"><a name=\"3. 拦截自定义异常\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 拦截自定义异常</h2><p>在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。</p>\n<h3 id=\"h3-3-1-\"><a name=\"3.1 定义异常信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 定义异常信息</h3><p>由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：</p>\n<pre><code class=\"lang-java\">/**\n * 业务异常提示信息枚举类\n * @author shengwu ni\n */\npublic enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(&quot;102&quot;, &quot;参数异常!&quot;),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(&quot;103&quot;, &quot;服务调用超时！&quot;),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(&quot;102&quot;, &quot;输入的图片数量不能超过50张!&quot;),\n    /** 500 : 一劳永逸的提示也可以在这定义 */\n    UNEXPECTED_EXCEPTION(&quot;500&quot;, &quot;系统发生异常，请联系管理员！&quot;);\n    // 还可以定义更多的业务异常\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n    // set get方法\n}\n</code></pre>\n<h3 id=\"h3-3-2-\"><a name=\"3.2 拦截自定义异常\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 拦截自定义异常</h3><p>然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：</p>\n<pre><code class=\"lang-java\">/**\n * 自定义业务异常\n * @author shengwu ni\n */\npublic class BusinessErrorException extends RuntimeException {\n\n    private static final long serialVersionUID = -7480022450501760611L;\n\n    /**\n     * 异常码\n     */\n    private String code;\n    /**\n     * 异常提示信息\n     */\n    private String message;\n\n    public BusinessErrorException(BusinessMsgEnum businessMsgEnum) {\n        this.code = businessMsgEnum.code();\n        this.message = businessMsgEnum.msg();\n    }\n    // get set方法\n}\n</code></pre>\n<p>在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。</p>\n<pre><code class=\"lang-java\">@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n}\n</code></pre>\n<p>在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/exception&quot;)\npublic class ExceptionController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);\n\n    @GetMapping(&quot;/business&quot;)\n    public JsonResult testException() {\n        try {\n            int i = 1 / 0;\n        } catch (Exception e) {\n            throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n        }\n        return new JsonResult();\n    }\n}\n</code></pre>\n<p>运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：</p>\n<pre><code class=\"lang-json\">{&quot;code&quot;:&quot;500&quot;,&quot;msg&quot;:&quot;系统发生异常，请联系管理员！&quot;}\n</code></pre>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--09-spring-boot-aop-\"><a name=\"第09课：Spring Boot中的切面AOP处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第09课：Spring Boot中的切面AOP处理</h1><h2 id=\"h2-1-aop\"><a name=\"1. 什么是AOP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是AOP</h2><p>AOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？  </p>\n<p>对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！  </p>\n<p>这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。</p>\n<h2 id=\"h2-2-spring-boot-aop-\"><a name=\"2. Spring Boot 中的 AOP 处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Spring Boot 中的 AOP 处理</h2><h3 id=\"h3-2-1-aop-\"><a name=\"2.1 AOP 依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 AOP 依赖</h3><p>使用AOP，首先需要引入AOP的依赖。</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3-2-2-aop-\"><a name=\"2.2 实现 AOP 切面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 实现 AOP 切面</h3><p>Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个<code><a href=\"https://github.com/Aspect\" title=\"&#64;Aspect\" class=\"at-link\">@Aspect</a></code>注解即可。<code><a href=\"https://github.com/Aspect\" title=\"&#64;Aspect\" class=\"at-link\">@Aspect</a></code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。<code><a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a></code> 注解让该类交给 Spring 来管理。</p>\n<pre><code class=\"lang-java\">@Aspect\n@Component\npublic class LogAspectHandler {\n\n}\n</code></pre>\n<p>这里主要介绍几个常用的注解及使用：</p>\n<blockquote>\n<p>1.<a href=\"https://github.com/Pointcut\" title=\"&#64;Pointcut\" class=\"at-link\">@Pointcut</a>：定义一个切面，即上面所描述的关注的某件事入口。<br>2.<a href=\"https://github.com/Before\" title=\"&#64;Before\" class=\"at-link\">@Before</a>：在做某件事之前做的事。<br>3.<a href=\"https://github.com/After\" title=\"&#64;After\" class=\"at-link\">@After</a>：在做某件事之后做的事。<br>4.<a href=\"https://github.com/AfterReturning\" title=\"&#64;AfterReturning\" class=\"at-link\">@AfterReturning</a>：在做某件事之后，对其返回值做增强处理。<br>5.<a href=\"https://github.com/AfterThrowing\" title=\"&#64;AfterThrowing\" class=\"at-link\">@AfterThrowing</a>：在做某件事抛出异常时，处理。</p>\n</blockquote>\n<h4 id=\"h4-2-2-1-pointcut-\"><a name=\"2.2.1 @Pointcut 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 <a href=\"https://github.com/Pointcut\" title=\"&#64;Pointcut\" class=\"at-link\">@Pointcut</a> 注解</h4><p><code><a href=\"https://github.com/Pointcut\" title=\"&#64;Pointcut\" class=\"at-link\">@Pointcut</a></code> 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。</p>\n<pre><code class=\"lang-java\">@Aspect\n@Component\npublic class LogAspectHandler {\n\n    /**\n     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法\n     */\n    @Pointcut(&quot;execution(* com.itcodai.course09.controller..*.*(..))&quot;)\n    public void pointCut() {}\n}\n</code></pre>\n<p><code><a href=\"https://github.com/Pointcut\" title=\"&#64;Pointcut\" class=\"at-link\">@Pointcut</a></code> 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 <code>execution()</code>，另一个是使用 <code>annotation()</code>。<br>以 <code>execution(* com.itcodai.course09.controller..*.*(..)))</code> 表达式为例，语法如下：</p>\n<blockquote>\n<p><code>execution()</code> 为表达式主体<br>第一个 <code>*</code> 号的位置：表示返回值类型，<code>*</code> 表示所有类型<br>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，<code>com.itcodai.course09.controller</code> 包、子包下所有类的方法<br>第二个 <code>*</code> 号的位置：表示类名，<code>*</code> 表示所有类<br><code>*(..)</code> ：这个星号表示方法名，<code>*</code> 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p>\n</blockquote>\n<p><code>annotation()</code> 方式是针对某个注解来定义切面，比如我们对具有<code><a href=\"https://github.com/GetMapping\" title=\"&#64;GetMapping\" class=\"at-link\">@GetMapping</a></code>注解的方法做切面，可以如下定义切面：</p>\n<pre><code class=\"lang-java\">@Pointcut(&quot;@annotation(org.springframework.web.bind.annotation.GetMapping)&quot;)\npublic void annotationCut() {}\n</code></pre>\n<p>然后使用该切面的话，就会切入注解是 <code><a href=\"https://github.com/GetMapping\" title=\"&#64;GetMapping\" class=\"at-link\">@GetMapping</a></code> 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 <code><a href=\"https://github.com/GetMapping\" title=\"&#64;GetMapping\" class=\"at-link\">@GetMapping</a></code>、<code><a href=\"https://github.com/PostMapping\" title=\"&#64;PostMapping\" class=\"at-link\">@PostMapping</a></code>、<code><a href=\"https://github.com/DeleteMapping\" title=\"&#64;DeleteMapping\" class=\"at-link\">@DeleteMapping</a></code> 等。所以这种按照注解的切入方式在实际项目中也很常用。</p>\n<h4 id=\"h4-2-2-2-before-\"><a name=\"2.2.2 @Before 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 <a href=\"https://github.com/Before\" title=\"&#64;Before\" class=\"at-link\">@Before</a> 注解</h4><p><code><a href=\"https://github.com/Before\" title=\"&#64;Before\" class=\"at-link\">@Before</a></code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：</p>\n<pre><code class=\"lang-java\">@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法之前执行该方法\n     * @param joinPoint jointPoint\n     */\n    @Before(&quot;pointCut()&quot;)\n    public void doBefore(JoinPoint joinPoint) {\n        logger.info(&quot;====doBefore方法进入了====&quot;);\n\n        // 获取签名\n        Signature signature = joinPoint.getSignature();\n        // 获取切入的包名\n        String declaringTypeName = signature.getDeclaringTypeName();\n        // 获取即将执行的方法名\n        String funcName = signature.getName();\n        logger.info(&quot;即将执行方法为: {}，属于{}包&quot;, funcName, declaringTypeName);\n\n        // 也可以用来记录一些信息，比如获取请求的url和ip\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n        // 获取请求url\n        String url = request.getRequestURL().toString();\n        // 获取请求ip\n        String ip = request.getRemoteAddr();\n        logger.info(&quot;用户请求的url为：{}，ip地址为：{}&quot;, url, ip);\n    }\n}\n</code></pre>\n<p>JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 <code>joinPoint.getArgs()</code> 获取）等等。</p>\n<h4 id=\"h4-2-2-3-after-\"><a name=\"2.2.3 @After 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.3 <a href=\"https://github.com/After\" title=\"&#64;After\" class=\"at-link\">@After</a> 注解</h4><p><code><a href=\"https://github.com/After\" title=\"&#64;After\" class=\"at-link\">@After</a></code> 注解和 <code><a href=\"https://github.com/Before\" title=\"&#64;Before\" class=\"at-link\">@Before</a></code>  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。</p>\n<pre><code class=\"lang-java\">@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法\n     */\n    @Pointcut(&quot;execution(* com.itcodai.course09.controller..*.*(..))&quot;)\n    public void pointCut() {}\n\n    /**\n     * 在上面定义的切面方法之后执行该方法\n     * @param joinPoint jointPoint\n     */\n    @After(&quot;pointCut()&quot;)\n    public void doAfter(JoinPoint joinPoint) {\n\n        logger.info(&quot;====doAfter方法进入了====&quot;);\n        Signature signature = joinPoint.getSignature();\n        String method = signature.getName();\n        logger.info(&quot;方法{}已经执行完&quot;, method);\n    }\n}\n</code></pre>\n<p>到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/aop&quot;)\npublic class AopController {\n\n    @GetMapping(&quot;/{name}&quot;)\n    public String testAop(@PathVariable String name) {\n        return &quot;Hello &quot; + name;\n    }\n}\n</code></pre>\n<p>启动项目，在浏览器中输入 <code>localhost:8080/aop/CSDN</code>，观察一下控制台的输出信息：</p>\n<pre><code>====doBefore方法进入了====  \n即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  \n用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1  \n====doAfter方法进入了====  \n方法testAop已经执行完\n</code></pre><p>从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 <code><a href=\"https://github.com/Before\" title=\"&#64;Before\" class=\"at-link\">@Before</a></code> 和 <code><a href=\"https://github.com/After\" title=\"&#64;After\" class=\"at-link\">@After</a></code> 两个注解的实际作用。</p>\n<h4 id=\"h4-2-2-4-afterreturning-\"><a name=\"2.2.4 @AfterReturning 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.4 <a href=\"https://github.com/AfterReturning\" title=\"&#64;AfterReturning\" class=\"at-link\">@AfterReturning</a> 注解</h4><p><code><a href=\"https://github.com/AfterReturning\" title=\"&#64;AfterReturning\" class=\"at-link\">@AfterReturning</a></code> 注解和 <code><a href=\"https://github.com/After\" title=\"&#64;After\" class=\"at-link\">@After</a></code> 有些类似，区别在于 <code><a href=\"https://github.com/AfterReturning\" title=\"&#64;AfterReturning\" class=\"at-link\">@AfterReturning</a></code> 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：</p>\n<pre><code class=\"lang-java\">@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强\n     * @param joinPoint joinPoint\n     * @param result result\n     */\n    @AfterReturning(pointcut = &quot;pointCut()&quot;, returning = &quot;result&quot;)\n    public void doAfterReturning(JoinPoint joinPoint, Object result) {\n\n        Signature signature = joinPoint.getSignature();\n        String classMethod = signature.getName();\n        logger.info(&quot;方法{}执行完毕，返回参数为：{}&quot;, classMethod, result);\n        // 实际项目中可以根据业务做具体的返回值增强\n        logger.info(&quot;对返回参数进行业务上的增强：{}&quot;, result + &quot;增强版&quot;);\n    }\n}\n</code></pre>\n<p>需要注意的是：在 <code><a href=\"https://github.com/AfterReturning\" title=\"&#64;AfterReturning\" class=\"at-link\">@AfterReturning</a></code>注解 中，属性 <code>returning</code> 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 <code>doAfterReturning</code> 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：</p>\n<pre><code>方法testAop执行完毕，返回参数为：Hello CSDN  \n对返回参数进行业务上的增强：Hello CSDN增强版\n</code></pre><h4 id=\"h4-2-2-5-afterthrowing-\"><a name=\"2.2.5 @AfterThrowing 注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.5 <a href=\"https://github.com/AfterThrowing\" title=\"&#64;AfterThrowing\" class=\"at-link\">@AfterThrowing</a> 注解</h4><p>顾名思义，<code><a href=\"https://github.com/AfterThrowing\" title=\"&#64;AfterThrowing\" class=\"at-link\">@AfterThrowing</a></code> 注解是当被切方法执行时抛出异常时，会进入 <code><a href=\"https://github.com/AfterThrowing\" title=\"&#64;AfterThrowing\" class=\"at-link\">@AfterThrowing</a></code> 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 <code>throwing</code> 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。</p>\n<pre><code class=\"lang-java\">/**\n * 使用AOP处理log\n * @author shengwu ni\n * @date 2018/05/04 20:24\n */\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法执行抛异常时，执行该方法\n     * @param joinPoint jointPoint\n     * @param ex ex\n     */\n    @AfterThrowing(pointcut = &quot;pointCut()&quot;, throwing = &quot;ex&quot;)\n    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {\n        Signature signature = joinPoint.getSignature();\n        String method = signature.getName();\n        // 处理异常的逻辑\n        logger.info(&quot;执行方法{}出错，异常为：{}&quot;, method, ex);\n    }\n}\n</code></pre>\n<p>该方法我就不测试了，大家可以自行测试一下。</p>\n<h2 id=\"h2-3-\"><a name=\"3. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 总结</h2><p>本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--10-spring-boot-mybatis\"><a name=\"第10课：Spring Boot集成MyBatis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第10课：Spring Boot集成MyBatis</h1><h2 id=\"h2-1-mybatis-\"><a name=\"1. MyBatis 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. MyBatis 介绍</h2><p>大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。</p>\n<h2 id=\"h2-2-mybatis-\"><a name=\"2. MyBatis 的配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. MyBatis 的配置</h2><h2 id=\"h2-2-1-\"><a name=\"2.1 依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 依赖导入</h2><p>Spring Boot 集成 MyBatis，需要导入 <code>mybatis-spring-boot-starter</code> 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>我们点开 <code>mybatis-spring-boot-starter</code> 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。</p>\n<pre><code class=\"lang-xml\">&lt;!-- 省去其他 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h2 id=\"h2-2-2-properties-yml-\"><a name=\"2.2 properties.yml配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 properties.yml配置</h2><p>我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？</p>\n<pre><code class=\"lang-xml\"># 服务端口号\nserver:\n  port: 8080\n\n# 数据库地址\ndatasource:\n  url: localhost:3306/blog_test\n\nspring:\n  datasource: # 数据库配置\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 10 # 最大连接池数\n      max-lifetime: 1770000\n\nmybatis:\n  # 指定别名设置的包为所有entity\n  type-aliases-package: com.itcodai.course10.entity\n  configuration:\n    map-underscore-to-camel-case: true # 驼峰命名规范\n  mapper-locations: # mapper映射文件位置\n    - classpath:mapper/*.xml\n</code></pre>\n<p>我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。  </p>\n<p>这里说明一下 <code>map-underscore-to-camel-case: true</code>， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：<code>user_name</code>， 那么在实体类中可以定义属性为 <code>userName</code> （甚至可以写成 <code>username</code>，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。</p>\n<h2 id=\"h2-3-xml-\"><a name=\"3. 基于 xml 的整合\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 基于 xml 的整合</h2><p>使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：<code>classpath:mapper/*.xml</code>，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.itcodai.course10.dao.UserMapper&quot;&gt;\n  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.itcodai.course10.entity.User&quot;&gt;\n\n    &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;\n    &lt;result column=&quot;user_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;\n    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;\n  &lt;/resultMap&gt;\n\n   &lt;select id=&quot;getUserByName&quot; resultType=&quot;User&quot; parameterType=&quot;String&quot;&gt;\n       select * from user where user_name = #{username}\n  &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， <code>&lt;resultMap&gt;</code> 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。  </p>\n<p>实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：</p>\n<pre><code class=\"lang-java\">User getUserByName(String username);\n</code></pre>\n<p>中间省略 service 的代码，我们写一个 Controller 来测试一下：</p>\n<pre><code class=\"lang-java\">@RestController\npublic class TestController {\n\n    @Resource\n    private UserService userService;\n\n    @RequestMapping(&quot;/getUserByName/{name}&quot;)\n    public User getUserByName(@PathVariable String name) {\n        return userService.getUserByName(name);\n    }\n}\n</code></pre>\n<p>启动项目，在浏览器中输入：<code>http://localhost:8080/getUserByName/CSDN</code> 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：</p>\n<pre><code class=\"lang-json\">{&quot;id&quot;:2,&quot;username&quot;:&quot;CSDN&quot;,&quot;password&quot;:&quot;123456&quot;}\n</code></pre>\n<p>这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 <code><a href=\"https://github.com/Mapper\" title=\"&#64;Mapper\" class=\"at-link\">@Mapper</a></code> 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 <code><a href=\"https://github.com/Mapper\" title=\"&#64;Mapper\" class=\"at-link\">@Mapper</a></code> 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加<code><a href=\"https://github.com/MaperScan\" title=\"&#64;MaperScan\" class=\"at-link\">@MaperScan</a></code> 注解，来扫描一个包下的所有 mapper。如下：</p>\n<pre><code class=\"lang-java\">@SpringBootApplication\n@MapperScan(&quot;com.itcodai.course10.dao&quot;)\npublic class Course10Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Course10Application.class, args);\n    }\n}\n</code></pre>\n<p>这样的话，<code>com.itcodai.course10.dao</code> 包下的所有 mapper 都会被扫描到了。</p>\n<h2 id=\"h2-4-\"><a name=\"4. 基于注解的整合\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 基于注解的整合</h2><p>基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 <code><a href=\"https://github.com/Select\" title=\"&#64;Select\" class=\"at-link\">@Select</a></code>， <code><a href=\"https://github.com/Insert\" title=\"&#64;Insert\" class=\"at-link\">@Insert</a></code>， <code><a href=\"https://github.com/Update\" title=\"&#64;Update\" class=\"at-link\">@Update</a></code>， <code>Delete</code> 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：</p>\n<pre><code class=\"lang-java\">@Select(&quot;select * from user where id = #{id}&quot;)\nUser getUser(Long id);\n</code></pre>\n<p>这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 <code><a href=\"https://github.com/Param\" title=\"&#64;Param\" class=\"at-link\">@Param</a></code> 注解来指定每一个参数的对应关系，如下：</p>\n<pre><code class=\"lang-java\">@Select(&quot;select * from user where id = #{id} and user_name=#{name}&quot;)\nUser getUserByIdAndName(@Param(&quot;id&quot;) Long id, @Param(&quot;name&quot;) String username);\n</code></pre>\n<p>可以看出，<code><a href=\"https://github.com/Param\" title=\"&#64;Param\" class=\"at-link\">@Param</a></code> 指定的参数应该要和 sql 中 <code>#{}</code> 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。  </p>\n<p>有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 <code><a href=\"https://github.com/Results\" title=\"&#64;Results\" class=\"at-link\">@Results</a></code> 注解来解决。</p>\n<pre><code class=\"lang-java\">@Select(&quot;select * from user where id = #{id}&quot;)\n@Results({\n        @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),\n        @Result(property = &quot;password&quot;, column = &quot;password&quot;)\n})\nUser getUser(Long id);\n</code></pre>\n<p><code><a href=\"https://github.com/Results\" title=\"&#64;Results\" class=\"at-link\">@Results</a></code> 中的 <code><a href=\"https://github.com/Result\" title=\"&#64;Result\" class=\"at-link\">@Result</a></code> 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。  </p>\n<p>当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 <code><a href=\"https://github.com/ResultMap\" title=\"&#64;ResultMap\" class=\"at-link\">@ResultMap</a></code> 注解来替代 <code><a href=\"https://github.com/Results\" title=\"&#64;Results\" class=\"at-link\">@Results</a></code> 注解，如下：</p>\n<pre><code class=\"lang-java\">@Select(&quot;select * from user where id = #{id}&quot;)\n@ResultMap(&quot;BaseResultMap&quot;)\nUser getUser(Long id);\n</code></pre>\n<p><code><a href=\"https://github.com/ResultMap\" title=\"&#64;ResultMap\" class=\"at-link\">@ResultMap</a></code> 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 <code>&lt;resultMap&gt;</code> 时对应的 id 值：</p>\n<pre><code class=\"lang-xml\">&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.itcodai.course10.entity.User&quot;&gt;\n</code></pre>\n<p>这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。</p>\n<h2 id=\"h2-5-\"><a name=\"5. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 总结</h2><p>本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--11-spring-boot-\"><a name=\"第11课：Spring Boot事务配置管理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第11课：Spring Boot事务配置管理</h1><h2 id=\"h2-1-\"><a name=\"1. 事务相关\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 事务相关</h2><p>场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。  </p>\n<p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。</p>\n<p>事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。</p>\n<h2 id=\"h2-2-spring-boot-\"><a name=\"2. Spring Boot 事务配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Spring Boot 事务配置</h2><h3 id=\"h3-2-1-\"><a name=\"2.1 依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 依赖导入</h3><p>在 Spring Boot 中使用事务，需要导入 mysql 依赖：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 <code><a href=\"https://github.com/Transactional\" title=\"&#64;Transactional\" class=\"at-link\">@Transactional</a></code> 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。  </p>\n<h3 id=\"h3-2-2-\"><a name=\"2.2 事务的测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 事务的测试</h3><p>我们首先在数据库表中插入一条数据：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">id</th>\n<th style=\"text-align:center\">user_name</th>\n<th style=\"text-align:center\">password</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">倪升武</td>\n<td style=\"text-align:center\">123456</td>\n</tr>\n</tbody>\n</table>\n<p>然后我们写一个插入的 mapper：</p>\n<pre><code class=\"lang-java\">public interface UserMapper {\n\n    @Insert(&quot;insert into user (user_name, password) values (#{username}, #{password})&quot;)\n    Integer insertUser(User user);\n}\n</code></pre>\n<p>OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。</p>\n<pre><code class=\"lang-java\">@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional\n    public void isertUser(User user) {\n        // 插入用户信息\n        userMapper.insertUser(user);\n        // 手动抛出异常\n        throw new RuntimeException();\n    }\n}\n</code></pre>\n<p>我们来测试一下：</p>\n<pre><code class=\"lang-java\">@RestController\npublic class TestController {\n\n    @Resource\n    private UserService userService;\n\n    @PostMapping(&quot;/adduser&quot;)\n    public String addUser(@RequestBody User user) throws Exception {\n        if (null != user) {\n            userService.isertUser(user);\n            return &quot;success&quot;;\n        } else {\n            return &quot;false&quot;;\n        }\n    }\n}\n</code></pre>\n<p>我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……</p>\n<h2 id=\"h2-3-\"><a name=\"3. 常见问题总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 常见问题总结</h2><p>从上面的内容中可以看出，Spring Boot 中使用事务非常简单，<code><a href=\"https://github.com/Transactional\" title=\"&#64;Transactional\" class=\"at-link\">@Transactional</a></code> 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。  </p>\n<p>这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。</p>\n<h3 id=\"h3-3-1-\"><a name=\"3.1 异常并没有被 ”捕获“ 到\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 异常并没有被 ”捕获“ 到</h3><p>首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：</p>\n<pre><code class=\"lang-java\">@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional\n    public void isertUser2(User user) throws Exception {\n        // 插入用户信息\n        userMapper.insertUser(user);\n        // 手动抛出异常\n        throw new SQLException(&quot;数据库异常&quot;);\n    }\n}\n</code></pre>\n<p>我们看上面这个代码，其实并没有什么问题，手动抛出一个 <code>SQLException</code> 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。  </p>\n<p>那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 <code><a href=\"https://github.com/Transactional\" title=\"&#64;Transactional\" class=\"at-link\">@Transactional</a></code> 注解中使用 <code>rollbackFor</code> 属性来指定异常，比如 <code><a href=\"https://github.com/Transactional\" title=\"&#64;Transactional\" class=\"at-link\">@Transactional</a>(rollbackFor = Exception.class)</code>，这样就没有问题了，所以在实际项目中，一定要指定异常。</p>\n<h3 id=\"h3-3-2-\"><a name=\"3.2 异常被 ”吃“ 掉\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 异常被 ”吃“ 掉</h3><p>这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try…catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：</p>\n<pre><code class=\"lang-java\">@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void isertUser3(User user) {\n        try {\n            // 插入用户信息\n            userMapper.insertUser(user);\n            // 手动抛出异常\n            throw new SQLException(&quot;数据库异常&quot;);\n        } catch (Exception e) {\n            // 异常处理逻辑\n        }\n    }\n}\n</code></pre>\n<p>读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try…catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。  </p>\n<p>那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。</p>\n<h3 id=\"h3-3-3-\"><a name=\"3.3 事务的范围\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 事务的范围</h3><p>事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。  </p>\n<p>我来写个 demo：</p>\n<pre><code class=\"lang-java\">@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public synchronized void isertUser4(User user) {\n        // 实际中的具体业务……\n        userMapper.insertUser(user);\n    }\n}\n</code></pre>\n<p>可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。  </p>\n<p>但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。  </p>\n<p>从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。  </p>\n<p>这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。</p>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本章主要总结了 Spring Boot 中如何使用事务，只要使用 <code><a href=\"https://github.com/Transactional\" title=\"&#64;Transactional\" class=\"at-link\">@Transactional</a></code> 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--12-spring-boot-\"><a name=\"第12课：Spring Boot中使用监听器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第12课：Spring Boot中使用监听器</h1><h2 id=\"h2-1-\"><a name=\"1. 监听器介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 监听器介绍</h2><p>什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p>\n<h2 id=\"h2-2-spring-boot-\"><a name=\"2. Spring Boot中监听器的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Spring Boot中监听器的使用</h2><p>web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。</p>\n<h3 id=\"h3-2-1-servlet-\"><a name=\"2.1 监听Servlet上下文对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 监听Servlet上下文对象</h3><p>监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。  </p>\n<p>针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。</p>\n<p>下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：</p>\n<pre><code class=\"lang-java\">@Service\npublic class UserService {\n\n    /**\n     * 获取用户信息\n     * @return\n     */\n    public User getUser() {\n        // 实际中会根据具体的业务场景，从数据库中查询对应的信息\n        return new User(1L, &quot;倪升武&quot;, &quot;123456&quot;);\n    }\n}\n</code></pre>\n<p>然后写一个监听器，实现 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：</p>\n<pre><code class=\"lang-java\">/**\n * 使用ApplicationListener来初始化一些数据到application域中的监听器\n * @author shengni ni\n * @date 2018/07/05\n */\n@Component\npublic class MyServletContextListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {\n        // 先获取到application上下文\n        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();\n        // 获取对应的service\n        UserService userService = applicationContext.getBean(UserService.class);\n        User user = userService.getUser();\n        // 获取application域对象，将查到的信息放到application域中\n        ServletContext application = applicationContext.getBean(ServletContext.class);\n        application.setAttribute(&quot;user&quot;, user);\n    }\n}\n</code></pre>\n<p>正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/listener&quot;)\npublic class TestController {\n\n    @GetMapping(&quot;/user&quot;)\n    public User getUser(HttpServletRequest request) {\n        ServletContext application = request.getServletContext();\n        return (User) application.getAttribute(&quot;user&quot;);\n    }\n}\n</code></pre>\n<p>启动项目，在浏览器中输入 <code>http://localhost:8080/listener/user</code> 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。</p>\n<h3 id=\"h3-2-2-http-session-\"><a name=\"2.2 监听HTTP会话 Session对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 监听HTTP会话 Session对象</h3><p>监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。</p>\n<pre><code class=\"lang-java\">/**\n * 使用HttpSessionListener统计在线用户数的监听器\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyHttpSessionListener implements HttpSessionListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class);\n\n    /**\n     * 记录在线的用户数量\n     */\n    public Integer count = 0;\n\n    @Override\n    public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) {\n        logger.info(&quot;新用户上线了&quot;);\n        count++;\n        httpSessionEvent.getSession().getServletContext().setAttribute(&quot;count&quot;, count);\n    }\n\n    @Override\n    public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) {\n        logger.info(&quot;用户下线了&quot;);\n        count--;\n        httpSessionEvent.getSession().getServletContext().setAttribute(&quot;count&quot;, count);\n    }\n}\n</code></pre>\n<p>可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 <code>sessionCreated</code> 和 <code>sessionDestroyed</code> 方法，在 <code>sessionCreated</code> 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，<code>sessionDestroyed</code> 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/listener&quot;)\npublic class TestController {\n\n    /**\n     * 获取当前在线人数，该方法有bug\n     * @param request\n     * @return\n     */\n    @GetMapping(&quot;/total&quot;)\n    public String getTotalUser(HttpServletRequest request) {\n        Integer count = (Integer) request.getSession().getServletContext().getAttribute(&quot;count&quot;);\n        return &quot;当前在线人数：&quot; + count;\n    }\n}\n</code></pre>\n<p>该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 <code>localhost:8080/listener/total</code> 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/total2&quot;)\npublic String getTotalUser(HttpServletRequest request, HttpServletResponse response) {\n    Cookie cookie;\n    try {\n        // 把sessionId记录在浏览器中\n        cookie = new Cookie(&quot;JSESSIONID&quot;, URLEncoder.encode(request.getSession().getId(), &quot;utf-8&quot;));\n        cookie.setPath(&quot;/&quot;);\n        //设置cookie有效期为2天，设置长一点\n        cookie.setMaxAge( 48*60 * 60);\n        response.addCookie(cookie);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n    Integer count = (Integer) request.getSession().getServletContext().getAttribute(&quot;count&quot;);\n    return &quot;当前在线人数：&quot; + count;\n}\n</code></pre>\n<p>可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。</p>\n<h3 id=\"h3-2-3-servlet-request-\"><a name=\"2.3 监听客户端请求Servlet Request对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 监听客户端请求Servlet Request对象</h3><p>使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：</p>\n<pre><code class=\"lang-java\">/**\n * 使用ServletRequestListener获取访问信息\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyServletRequestListener implements ServletRequestListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class);\n\n    @Override\n    public void requestInitialized(ServletRequestEvent servletRequestEvent) {\n        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();\n        logger.info(&quot;session id为：{}&quot;, request.getRequestedSessionId());\n        logger.info(&quot;request url为：{}&quot;, request.getRequestURL());\n\n        request.setAttribute(&quot;name&quot;, &quot;倪升武&quot;);\n    }\n\n    @Override\n    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {\n\n        logger.info(&quot;request end&quot;);\n        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();\n        logger.info(&quot;request域中保存的name值为：{}&quot;, request.getAttribute(&quot;name&quot;));\n\n    }\n\n}\n</code></pre>\n<p>这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/request&quot;)\npublic String getRequestInfo(HttpServletRequest request) {\n    System.out.println(&quot;requestListener中的初始化的name数据：&quot; + request.getAttribute(&quot;name&quot;));\n    return &quot;success&quot;;\n}\n</code></pre>\n<h2 id=\"h2-3-spring-boot-\"><a name=\"3. Spring Boot中自定义事件监听\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Spring Boot中自定义事件监听</h2><p>在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。</p>\n<h3 id=\"h3-3-1-\"><a name=\"3.1 自定义事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 自定义事件</h3><p>自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：</p>\n<pre><code class=\"lang-java\">/**\n * 自定义事件\n * @author shengwu ni\n * @date 2018/07/05\n */\npublic class MyEvent extends ApplicationEvent {\n\n    private User user;\n\n    public MyEvent(Object source, User user) {\n        super(source);\n        this.user = user;\n    }\n\n    // 省去get、set方法\n}\n</code></pre>\n<h3 id=\"h3-3-2-\"><a name=\"3.2 自定义监听器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 自定义监听器</h3><p>接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 <code>ApplicationListener</code> 接口即可。如下：</p>\n<pre><code class=\"lang-java\">/**\n * 自定义监听器，监听MyEvent事件\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyEventListener implements ApplicationListener&lt;MyEvent&gt; {\n    @Override\n    public void onApplicationEvent(MyEvent myEvent) {\n        // 把事件中的信息获取到\n        User user = myEvent.getUser();\n        // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等\n        System.out.println(&quot;用户名：&quot; + user.getUsername());\n        System.out.println(&quot;密码：&quot; + user.getPassword());\n\n    }\n}\n</code></pre>\n<p>然后重写 <code>onApplicationEvent</code> 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。</p>\n<p>OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：</p>\n<pre><code class=\"lang-java\">/**\n * UserService\n * @author shengwu ni\n */\n@Service\npublic class UserService {\n\n    @Resource\n    private ApplicationContext applicationContext;\n\n    /**\n     * 发布事件\n     * @return\n     */\n    public User getUser2() {\n        User user = new User(1L, &quot;倪升武&quot;, &quot;123456&quot;);\n        // 发布事件\n        MyEvent event = new MyEvent(this, user);\n        applicationContext.publishEvent(event);\n        return user;\n    }\n}\n</code></pre>\n<p>在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。</p>\n<p>最后，在 Controller 中写一个接口来测试一下：</p>\n<pre><code class=\"lang-java\">@GetMapping(&quot;/request&quot;)\npublic String getRequestInfo(HttpServletRequest request) {\n    System.out.println(&quot;requestListener中的初始化的name数据：&quot; + request.getAttribute(&quot;name&quot;));\n    return &quot;success&quot;;\n}\n</code></pre>\n<p>在浏览器中输入 <code>http://localhost:8080/listener/publish</code>，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。</p>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--13-spring-boot-\"><a name=\"第13课：Spring Boot中使用拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第13课：Spring Boot中使用拦截器</h1><p>拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。</p>\n<h2 id=\"h2-1-\"><a name=\"1. 拦截器的快速使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 拦截器的快速使用</h2><p>使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。</p>\n<h3 id=\"h3-1-1-\"><a name=\"1.1 定义拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 定义拦截器</h3><p>定义拦截器，只需要实现 <code>HandlerInterceptor</code> 接口，<code>HandlerInterceptor</code> 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： <code>preHandle(……)</code>、<code>postHandle(……)</code> 和 <code>afterCompletion(……)</code> 。</p>\n<blockquote>\n<p><code>preHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 <code>preHandle(……)</code> 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。<br><code>postHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。<br><code>afterCompletion(……)</code> 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 <code>preHandle(……)</code> 被成功执行后并且返回 true 才会被执行。  </p>\n</blockquote>\n<p>了解了该接口，接下来自定义一个拦截器。</p>\n<pre><code class=\"lang-java\">/**\n * 自定义拦截器\n * @author shengwu ni\n * @date 2018/08/03\n */\npublic class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\n        Method method = handlerMethod.getMethod();\n        String methodName = method.getName();\n        logger.info(&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;, methodName);\n        // 返回true才会继续执行，返回false则取消当前请求\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;);\n    }\n}\n</code></pre>\n<p>OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。</p>\n<h3 id=\"h3-1-2-\"><a name=\"1.2 配置拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 配置拦截器</h3><p>在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 <code>addInterceptors</code> 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class MyInterceptorConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);\n        super.addInterceptors(registry);\n    }\n}\n</code></pre>\n<p>在该配置中重写 <code>addInterceptors</code> 方法，将我们上面自定义的拦截器添加进去，<code>addPathPatterns</code> 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/interceptor&quot;)\npublic class InterceptorController {\n\n    @RequestMapping(&quot;/test&quot;)\n    public String test() {\n        return &quot;hello&quot;;\n    }\n}\n</code></pre>\n<p>让其跳转到 hello.html 页面，直接在 hello.html 中输出 <code>hello interceptor</code> 即可。启动项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 看一下控制台的日志：</p>\n<pre><code>====拦截到了方法：test，在该方法执行之前执行====  \n执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  \n整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\n</code></pre><p>可以看出拦截器已经生效，并能看出其执行顺序。</p>\n<h3 id=\"h3-1-3-\"><a name=\"1.3 解决静态资源被拦截问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 解决静态资源被拦截问题</h3><p>上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。</p>\n<p>也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。</p>\n<p>如何放开呢？除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开：</p>\n<pre><code class=\"lang-java\">/**\n * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问\n * @param registry\n */\n@Override\nprotected void addResourceHandlers(ResourceHandlerRegistry registry) {\n    registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);\n    super.addResourceHandlers(registry);\n}\n</code></pre>\n<p>这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。</p>\n<p>我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可，如下：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);\n    }\n}\n</code></pre>\n<p>这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。</p>\n<p>这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。</p>\n<h2 id=\"h2-2-\"><a name=\"2. 拦截器使用实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 拦截器使用实例</h2><h3 id=\"h3-2-1-\"><a name=\"2.1 判断用户有没有登录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 判断用户有没有登录</h3><p>一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法，如下：</p>\n<pre><code class=\"lang-java\">@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n    HandlerMethod handlerMethod = (HandlerMethod) handler;\n    Method method = handlerMethod.getMethod();\n    String methodName = method.getName();\n    logger.info(&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;, methodName);\n\n    // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token\n    String token = request.getParameter(&quot;token&quot;);\n    if (null == token || &quot;&quot;.equals(token)) {\n        logger.info(&quot;用户未登录，没有权限执行……请登录&quot;);\n        return false;\n    }\n\n    // 返回true才会继续执行，返回false则取消当前请求\n    return true;\n}\n</code></pre>\n<p>重启项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 后查看控制台日志，发现被拦截，如果在浏览器中输入 <code>localhost:8080/interceptor/test?token=123</code> 即可正常往下走。</p>\n<h3 id=\"h3-2-2-\"><a name=\"2.2 取消拦截操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 取消拦截操作</h3><p>根据上文，如果我要拦截所有 <code>/admin</code> 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 <code>/admin</code> 开头的，但是不能拦截，比如 <code>/admin/login</code> 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？</p>\n<p>是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：</p>\n<pre><code class=\"lang-java\">/**\n * 该注解用来指定某个方法不用拦截\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UnInterception {\n}\n</code></pre>\n<p>然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：</p>\n<pre><code class=\"lang-java\">@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n    HandlerMethod handlerMethod = (HandlerMethod) handler;\n    Method method = handlerMethod.getMethod();\n    String methodName = method.getName();\n    logger.info(&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;, methodName);\n\n    // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截\n    // @UnInterception 是我们自定义的注解\n    UnInterception unInterception = method.getAnnotation(UnInterception.class);\n    if (null != unInterception) {\n        return true;\n    }\n    // 返回true才会继续执行，返回false则取消当前请求\n    return true;\n}\n</code></pre>\n<p>Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 <code>http://localhost:8080/interceptor/test2?token=123</code> 测试一下，可以看出，加了该注解的方法不会被拦截。</p>\n<h2 id=\"h2-3-\"><a name=\"3. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 总结</h2><p>本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--14-spring-boot-redis\"><a name=\"第14课：Spring Boot 中集成Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第14课：Spring Boot 中集成Redis</h1><h2 id=\"h2-1-redis-\"><a name=\"1. Redis 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Redis 介绍</h2><p>Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。<br>NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。<br>Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： </p>\n<p><img src=\"https://images.gitbook.cn/4258b9c0-9f93-11e8-a34f-d93da92347ea\" alt=\"Redis使用场景\"></p>\n<p>Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。</p>\n<h2 id=\"h2-2-redis-\"><a name=\"2. Redis 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Redis 安装</h2><p>本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：</p>\n<ul>\n<li>安装 gcc 编译</li></ul>\n<p>因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：</p>\n<pre><code>yum install gcc-c++\n</code></pre><ul>\n<li>下载 redis</li></ul>\n<p>有两种方式下载安装包，一种是去官网上下载（<a href=\"https://redis.io），然后将安装包考到\">https://redis.io），然后将安装包考到</a> centos 中，另种方法是直接使用 wget 来下载：</p>\n<pre><code>wget http://download.redis.io/releases/redis-3.2.8.tar.gz\n</code></pre><p>如果没有安装过 wget，可以通过如下命令安装：</p>\n<pre><code>yum install wget\n</code></pre><ul>\n<li>解压安装</li></ul>\n<p>解压安装包：</p>\n<pre><code>tar –vzxf redis-3.2.8.tar.gz\n</code></pre><p>然后将解压的文件夹 redis-3.2.8 放到 <code>/usr/local/</code> 下，一般安装软件都放在 <code>/usr/local</code> 下。然后进入 <code>/usr/local/redis-3.2.8/</code> 文件夹下，执行 <code>make</code> 命令即可完成安装。<br>【注】如果 make 失败，可以尝试如下命令：</p>\n<pre><code>make MALLOC=libc\nmake install\n</code></pre><ul>\n<li>修改配置文件</li></ul>\n<p>安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。<br>打开 redis 配置文件：<code>vi redis.conf</code><br>在命令模式下输入 <code>/bind</code> 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：</p>\n<pre><code>bind 0.0.0.0\n</code></pre><p>使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。<br>将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。</p>\n<ul>\n<li>启动 redis</li></ul>\n<p>在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：</p>\n<pre><code>redis-server ./redis.conf\n</code></pre><p>再启动 redis 客户端：</p>\n<pre><code>redis-cli\n</code></pre><p>由于我们设置了密码，在启动客户端之后，输入 <code>auth 123456</code> 即可登录进入客户端。<br>然后我们来测试一下，往 redis 中插入一个数据：</p>\n<pre><code>set name CSDN\n</code></pre><p>然后来获取 name</p>\n<pre><code>get name\n</code></pre><p>如果正常获取到 CSDN，则说明没有问题。</p>\n<h2 id=\"h2-3-spring-boot-redis\"><a name=\"3. Spring Boot 集成 Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Spring Boot 集成 Redis</h2><h3 id=\"h3-3-1-\"><a name=\"3.1 依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 依赖导入</h3><p>Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--阿里巴巴fastjson --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.35&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。</p>\n<h3 id=\"h3-3-2-redis-\"><a name=\"3.2 Redis 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 Redis 配置</h3><p>导入了依赖之后，我们在 application.yml 文件里配置 redis：</p>\n<pre><code class=\"lang-yml\">server:\n  port: 8080\nspring:\n  #redis相关配置\n  redis:\n    database: 5\n    # 配置redis的主机地址，需要修改成自己的\n    host: 192.168.48.190\n    port: 6379\n    password: 123456\n    timeout: 5000\n    jedis:\n      pool:\n        # 连接池中的最大空闲连接，默认值也是8。\n        max-idle: 500\n        # 连接池中的最小空闲连接，默认值也是0。\n        min-idle: 50\n        # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)\n        max-active: 1000\n        # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException\n        max-wait: 2000\n</code></pre>\n<h3 id=\"h3-3-3-api-\"><a name=\"3.3 常用 api 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 常用 api 介绍</h3><p>Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。</p>\n<p>有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。</p>\n<h4 id=\"h4-3-3-1-redis-string-\"><a name=\"3.3.1 redis:string 类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.1 redis:string 类型</h4><p>新建一个 RedisService，注入 StringRedisTemplate，使用 <code>stringRedisTemplate.opsForValue()</code> 可以获取 <code>ValueOperations&lt;String, String&gt;</code> 对象，通过该对象即可读写 redis 数据库了。如下：</p>\n<pre><code class=\"lang-java\">public class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis: string类型\n     * @param key key\n     * @param value value\n     */\n    public void setString(String key, String value){\n        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(key, value);\n    }\n\n    /**\n     * get redis: string类型\n     * @param key key\n     * @return\n     */\n    public String getString(String key){\n        return stringRedisTemplate.opsForValue().get(key);\n    }\n</code></pre>\n<p>该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：</p>\n<pre><code class=\"lang-java\">@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n    @Resource\n    private RedisService redisService;\n\n    @Test\n    public void contextLoads() {\n        //测试redis的string类型\n        redisService.setString(&quot;weichat&quot;,&quot;程序员私房菜&quot;);\n        logger.info(&quot;我的微信公众号为：{}&quot;, redisService.getString(&quot;weichat&quot;));\n\n        // 如果是个实体，我们可以使用json工具转成json字符串，\n        User user = new User(&quot;CSDN&quot;, &quot;123456&quot;);\n        redisService.setString(&quot;userInfo&quot;, JSON.toJSONString(user));\n        logger.info(&quot;用户信息：{}&quot;, redisService.getString(&quot;userInfo&quot;));\n    }\n}\n</code></pre>\n<p>先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：</p>\n<pre><code>我的微信公众号为：程序员私房菜\n用户信息：{&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;CSDN&quot;}\n</code></pre><h4 id=\"h4-3-3-2-redis-hash-\"><a name=\"3.3.2 redis:hash 类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.2 redis:hash 类型</h4><p>hash 类型其实原理和 string 一样的，但是有两个 key，使用 <code>stringRedisTemplate.opsForHash()</code> 可以获取 <code>HashOperations&lt;String, Object, Object&gt;</code> 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。</p>\n<pre><code class=\"lang-java\">@Service\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis: hash类型\n     * @param key key\n     * @param filedKey filedkey\n     * @param value value\n     */\n    public void setHash(String key, String filedKey, String value){\n        HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(key,filedKey, value);\n    }\n\n    /**\n     * get redis: hash类型\n     * @param key key\n     * @param filedkey filedkey\n     * @return\n     */\n    public String getHash(String key, String filedkey){\n        return (String) stringRedisTemplate.opsForHash().get(key, filedkey);\n    }\n}\n</code></pre>\n<p>可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：</p>\n<pre><code class=\"lang-java\">@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n    @Resource\n    private RedisService redisService;\n\n    @Test\n    public void contextLoads() {\n        //测试redis的hash类型\n        redisService.setHash(&quot;user&quot;, &quot;name&quot;, JSON.toJSONString(user));\n        logger.info(&quot;用户姓名：{}&quot;, redisService.getHash(&quot;user&quot;,&quot;name&quot;));\n    }\n}\n</code></pre>\n<h4 id=\"h4-3-3-3-redis-list-\"><a name=\"3.3.3 redis:list 类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.3 redis:list 类型</h4><p>使用 <code>stringRedisTemplate.opsForList()</code> 可以获取 <code>ListOperations&lt;String, String&gt; listOperations</code>  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。</p>\n<pre><code class=\"lang-java\">@Service\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis:list类型\n     * @param key key\n     * @param value value\n     * @return\n     */\n    public long setList(String key, String value){\n        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();\n        return listOperations.leftPush(key, value);\n    }\n\n    /**\n     * get redis:list类型\n     * @param key key\n     * @param start start\n     * @param end end\n     * @return\n     */\n    public List&lt;String&gt; getList(String key, long start, long end){\n        return stringRedisTemplate.opsForList().range(key, start, end);\n    }\n}\n</code></pre>\n<p>可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：</p>\n<pre><code class=\"lang-java\">@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n    @Resource\n    private RedisService redisService;\n\n    @Test\n    public void contextLoads() {\n        //测试redis的list类型\n        redisService.setList(&quot;list&quot;, &quot;football&quot;);\n        redisService.setList(&quot;list&quot;, &quot;basketball&quot;);\n        List&lt;String&gt; valList = redisService.getList(&quot;list&quot;,0,-1);\n        for(String value :valList){\n            logger.info(&quot;list中有：{}&quot;, value);\n        }\n    }\n}\n</code></pre>\n<h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--15-spring-boot-activemq\"><a name=\"第15课： Spring Boot中集成ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第15课： Spring Boot中集成ActiveMQ</h1><h2 id=\"h2-1-jms-activemq-\"><a name=\"1. JMS 和 ActiveMQ 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. JMS 和 ActiveMQ 介绍</h2><h3 id=\"h3-1-1-jms-\"><a name=\"1.1 JMS 是啥\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 JMS 是啥</h3><p>百度百科的解释：</p>\n<blockquote>\n<p>JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p>\n</blockquote>\n<p>JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：</p>\n<blockquote>\n<p>连接工厂：ConnectionFactory<br>JMS连接：Connection<br>JMS会话：Session<br>JMS目的：Destination<br>JMS生产者：Producer<br>JMS消费者：Consumer<br>JMS消息两种类型：点对点和发布/订阅。  </p>\n</blockquote>\n<p>可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。</p>\n<h3 id=\"h3-1-2-activemq\"><a name=\"1.2 ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 ActiveMQ</h3><p>ActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。   </p>\n<p>异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。</p>\n<h2 id=\"h2-2-activemq-\"><a name=\"2. ActiveMQ安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. ActiveMQ安装</h2><p>使用 ActiveMQ 首先需要去官网下载，官网地址为：<a href=\"http://activemq.apache.org/\">http://activemq.apache.org/</a><br>本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 <code>activemq-all-5.15.3.jar</code>，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。</p>\n<p>在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。<br>消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费<br>启动完成后，在浏览器中输入 <code>http://127.0.0.1:8161/admin/</code> 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：</p>\n<p><img src=\"https://images.gitbook.cn/cfb9c460-aa94-11e8-888f-df33be8ed191\" alt=\"activemq\"></p>\n<p>我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？</p>\n<p>点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>\n<p>发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。</p>\n<h2 id=\"h2-3-activemq-\"><a name=\"3. ActiveMQ集成\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. ActiveMQ集成</h2><h3 id=\"h3-3-1-\"><a name=\"3.1 依赖导入和配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 依赖导入和配置</h3><p>在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>然后在 application.yml 配置文件中，对 activemq 做一下配置：</p>\n<pre><code class=\"lang-yml\">spring:\n  activemq:\n      # activemq url\n    broker-url: tcp://localhost:61616\n    in-memory: true\n    pool:\n      # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate\n      enabled: false\n</code></pre>\n<h3 id=\"h3-3-2-queue-topic-\"><a name=\"3.2 Queue 和 Topic 的创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 Queue 和 Topic 的创建</h3><p>首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：</p>\n<pre><code class=\"lang-java\">/**\n * activemq的配置\n * @author  shengwu ni\n */\n@Configuration\npublic class ActiveMqConfig {\n    /**\n     * 发布/订阅模式队列名称\n     */\n    public static final String TOPIC_NAME = &quot;activemq.topic&quot;;\n    /**\n     * 点对点模式队列名称\n     */\n    public static final String QUEUE_NAME = &quot;activemq.queue&quot;;\n\n    @Bean\n    public Destination topic() {\n        return new ActiveMQTopic(TOPIC_NAME);\n    }\n\n    @Bean\n    public Destination queue() {\n        return new ActiveMQQueue(QUEUE_NAME);\n    }\n}\n</code></pre>\n<p>可以看出创建 Queue 和 Topic 两种消息，分别使用 <code>new ActiveMQQueue</code> 和 <code>new ActiveMQTopic</code> 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。</p>\n<h3 id=\"h3-3-3-\"><a name=\"3.3 消息的发送接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 消息的发送接口</h3><p>在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：</p>\n<pre><code class=\"lang-java\">/**\n * 消息发送者\n * @author shengwu ni\n */\n@Service\npublic class MsgProducer {\n\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void sendMessage(Destination destination, String msg) {\n        jmsMessagingTemplate.convertAndSend(destination, msg);\n    }\n}\n</code></pre>\n<p><code>convertAndSend</code> 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。</p>\n<h3 id=\"h3-3-4-\"><a name=\"3.4 点对点消息生产与消费\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 点对点消息生产与消费</h3><h4 id=\"h4-3-4-1-\"><a name=\"3.4.1 点对点消息的生产\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4.1 点对点消息的生产</h4><p>消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 <code>sendMessage</code> 即可成功生产一条消息。</p>\n<pre><code class=\"lang-java\">/**\n * ActiveMQ controller\n * @author shengwu ni\n */\n@RestController\n@RequestMapping(&quot;/activemq&quot;)\npublic class ActiveMqController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);\n\n    @Resource\n    private MsgProducer producer;\n    @Resource\n    private Destination queue;\n\n    @GetMapping(&quot;/send/queue&quot;)\n    public String sendQueueMessage() {\n\n        logger.info(&quot;===开始发送点对点消息===&quot;);\n        producer.sendMessage(queue, &quot;Queue: hello activemq!&quot;);\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<h4 id=\"h4-3-4-2-\"><a name=\"3.4.2 点对点消息的消费\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4.2 点对点消息的消费</h4><p>点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。</p>\n<pre><code class=\"lang-java\">/**\n * 消息消费者\n * @author shengwu ni\n */\n@Service\npublic class QueueConsumer {\n\n    /**\n     * 接收点对点消息\n     * @param msg\n     */\n    @JmsListener(destination = ActiveMqConfig.QUEUE_NAME)\n    public void receiveQueueMsg(String msg) {\n        System.out.println(&quot;收到的消息为：&quot; + msg);\n    }\n}\n</code></pre>\n<p>可以看出，使用 <code><a href=\"https://github.com/JmsListener\" title=\"&#64;JmsListener\" class=\"at-link\">@JmsListener</a></code> 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。</p>\n<h4 id=\"h4-3-4-3-\"><a name=\"3.4.3 测试一下\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/queue</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p>\n<pre><code>收到的消息为：Queue: hello activemq!\n</code></pre><h3 id=\"h3-3-5-\"><a name=\"3.5 发布/订阅消息的生产和消费\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 发布/订阅消息的生产和消费</h3><h4 id=\"h4-3-5-1-\"><a name=\"3.5.1 发布/订阅消息的生产\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5.1 发布/订阅消息的生产</h4><p>和点对点消息一样，我们注入 topic 并调用 producer 的 <code>sendMessage</code> 方法即可发送订阅消息，如下，不再赘述：</p>\n<pre><code class=\"lang-java\">@RestController\n@RequestMapping(&quot;/activemq&quot;)\npublic class ActiveMqController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);\n\n    @Resource\n    private MsgProducer producer;\n    @Resource\n    private Destination topic;\n\n    @GetMapping(&quot;/send/topic&quot;)\n    public String sendTopicMessage() {\n\n        logger.info(&quot;===开始发送订阅消息===&quot;);\n        producer.sendMessage(topic, &quot;Topic: hello activemq!&quot;);\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<h4 id=\"h4-3-5-2-\"><a name=\"3.5.2 发布/订阅消息的消费\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5.2 发布/订阅消息的消费</h4><p>发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：</p>\n<pre><code class=\"lang-yml\">spring:\n  jms:\n    pub-sub-domain: true\n</code></pre>\n<p>该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。</p>\n<p>比较好的解决办法是，我们定义一个工厂，<code><a href=\"https://github.com/JmsListener\" title=\"&#64;JmsListener\" class=\"at-link\">@JmsListener</a></code> 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：</p>\n<pre><code class=\"lang-java\">/**\n * activemq的配置\n *\n * @author shengwu ni\n */\n@Configuration\npublic class ActiveMqConfig {\n    // 省略其他内容\n\n    /**\n     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory\n     */\n    @Bean\n    public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) {\n        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true\n        factory.setPubSubDomain(true);\n        return factory;\n    }\n}\n</code></pre>\n<p>经过这样的配置之后，我们在消费的时候，在 <code><a href=\"https://github.com/JmsListener\" title=\"&#64;JmsListener\" class=\"at-link\">@JmsListener</a></code> 注解中指定这个容器工厂即可消费 topic 消息。如下：</p>\n<pre><code class=\"lang-java\">/**\n * Topic消息消费者\n * @author shengwu ni\n */\n@Service\npublic class TopicConsumer1 {\n\n    /**\n     * 接收订阅消息\n     * @param msg\n     */\n    @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = &quot;topicListenerContainer&quot;)\n    public void receiveTopicMsg(String msg) {\n        System.out.println(&quot;收到的消息为：&quot; + msg);\n    }\n\n}\n</code></pre>\n<p>指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。</p>\n<h4 id=\"h4-3-5-3-\"><a name=\"3.5.3 测试一下\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/topic</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p>\n<pre><code>收到的消息为：Topic: hello activemq!\n收到的消息为：Topic: hello activemq!\n</code></pre><h2 id=\"h2-4-\"><a name=\"4. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 总结</h2><p>本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--16-spring-boot-shiro\"><a name=\"第16课：Spring Boot中集成 Shiro\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第16课：Spring Boot中集成 Shiro</h1><p>Shiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。</p>\n<h2 id=\"h2-1-shiro-\"><a name=\"1. Shiro 三大核心组件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Shiro 三大核心组件</h2><p>Shiro 有三大核心的组件：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code>。先来看一下它们之间的关系。</p>\n<p><img src=\"https://images.gitbook.cn/2dd0f5f0-af4a-11e8-a51c-93c39f2785b1\" alt=\"三大核心组件的关系\"></p>\n<ol>\n<li>Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。</li></ol>\n<blockquote>\n<p>Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；<br>Credentials：凭证。常见有密码，数字证书等等。</p>\n</blockquote>\n<p>说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。</p>\n<ol>\n<li><p>SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。</p>\n</li><li><p>Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。</p>\n</li></ol>\n<h2 id=\"h2-1-shiro-\"><a name=\"1. Shiro 身份和权限认证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Shiro 身份和权限认证</h2><h3 id=\"h3-1-2-shiro-\"><a name=\"1.2 Shiro 身份认证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 Shiro 身份认证</h3><p>我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：</p>\n<p><img src=\"https://images.gitbook.cn/f21c53a0-af4f-11e8-a51c-93c39f2785b1\" alt=\"认证过程\"></p>\n<p>Step1：应用程序代码在调用 <code>Subject.login(token)</code> 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。 </p>\n<p>Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。 </p>\n<p>Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。</p>\n<h3 id=\"h3-1-3-shiro-\"><a name=\"1.3 Shiro 权限认证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 Shiro 权限认证</h3><p>权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。</p>\n<blockquote>\n<p>权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；<br>角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；<br>用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。</p>\n</blockquote>\n<p>它们之间的的关系可以用下图来表示： </p>\n<p><img src=\"https://images.gitbook.cn/44a68bc0-af75-11e8-85ef-dd986da3511e\" alt=\"用户、角色和权限的关系\"></p>\n<p>一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。</p>\n<h2 id=\"h2-2-spring-boot-shiro-\"><a name=\"2. Spring Boot 集成 Shiro 过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Spring Boot 集成 Shiro 过程</h2><h3 id=\"h3-2-1-\"><a name=\"2.1 依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 依赖导入</h3><p>Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3-2-2-\"><a name=\"2.2 数据库表数据初始化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 数据库表数据初始化</h3><p>这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。</p>\n<pre><code class=\"lang-sql\">CREATE TABLE `t_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `rolename` varchar(20) DEFAULT NULL COMMENT &#39;角色名称&#39;,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8\n\nCREATE TABLE `t_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;用户主键&#39;,\n  `username` varchar(20) NOT NULL COMMENT &#39;用户名&#39;,\n  `password` varchar(20) NOT NULL COMMENT &#39;密码&#39;,\n  `role_id` int(11) DEFAULT NULL COMMENT &#39;外键关联role表&#39;,\n  PRIMARY KEY (`id`),\n  KEY `role_id` (`role_id`),\n  CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8\n\nCREATE TABLE `t_permission` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `permissionname` varchar(50) NOT NULL COMMENT &#39;权限名&#39;,\n  `role_id` int(11) DEFAULT NULL COMMENT &#39;外键关联role&#39;,\n  PRIMARY KEY (`id`),\n  KEY `role_id` (`role_id`),\n  CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8\n</code></pre>\n<p>其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。<br>t_user 表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">id</th>\n<th style=\"text-align:center\">username</th>\n<th style=\"text-align:center\">password</th>\n<th style=\"text-align:center\">role_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">csdn1</td>\n<td style=\"text-align:center\">123456</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">csdn2</td>\n<td style=\"text-align:center\">123456</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">csdn3</td>\n<td style=\"text-align:center\">123456</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n<p>t_role 表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">id</th>\n<th style=\"text-align:center\">rolename</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">admin</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">teacher</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">student</td>\n</tr>\n</tbody>\n</table>\n<p>t_permission 表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">id</th>\n<th style=\"text-align:center\">permissionname</th>\n<th style=\"text-align:center\">role_id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\"><code>user:*</code></td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"><code>student:*</code></td>\n<td style=\"text-align:center\">2</td>\n</tr>\n</tbody>\n</table>\n<p>解释一下这里的权限：<code>user:*</code>表示权限可以是 <code>user:create</code> 或者其他，<code>*</code> 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。</p>\n<h3 id=\"h3-2-2-realm\"><a name=\"2.2 自定义 Realm\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 自定义 Realm</h3><p>有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：</p>\n<blockquote>\n<p><code>doGetAuthenticationInfo()</code> 方法：用来验证当前登录的用户，获取认证信息<br><code>doGetAuthorizationInfo()</code> 方法：用来为当前登陆成功的用户授予权限和角色</p>\n</blockquote>\n<p>具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：</p>\n<pre><code class=\"lang-java\">/**\n * 自定义realm\n * @author shengwu ni\n */\npublic class MyRealm extends AuthorizingRealm {\n\n    @Resource\n    private UserService userService;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        // 获取用户名\n        String username = (String) principalCollection.getPrimaryPrincipal();\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        // 给该用户设置角色，角色信息存在t_role表中取\n        authorizationInfo.setRoles(userService.getRoles(username));\n        // 给该用户设置权限，权限信息存在t_permission表中取\n        authorizationInfo.setStringPermissions(userService.getPermissions(username));\n        return authorizationInfo;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释\n        String username = (String) authenticationToken.getPrincipal();\n        // 根据用户名从数据库中查询该用户\n        User user = userService.getByUsername(username);\n        if(user != null) {\n            // 把当前用户存到session中\n            SecurityUtils.getSubject().getSession().setAttribute(&quot;user&quot;, user);\n            // 传入用户名和密码进行身份认证，并返回认证信息\n            AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), &quot;myRealm&quot;);\n            return authcInfo;\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre>\n<p>从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。</p>\n<h3 id=\"h3-2-3-shiro-\"><a name=\"2.3 Shiro 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 Shiro 配置</h3><p>自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：</p>\n<p>配置自定义 realm：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入自定义的realm\n     * @return MyRealm\n     */\n    @Bean\n    public MyRealm myAuthRealm() {\n        MyRealm myRealm = new MyRealm();\n        logger.info(&quot;====myRealm注册完成=====&quot;);\n        return myRealm;\n    }\n}\n</code></pre>\n<p>配置安全管理器 SecurityManager：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入安全管理器\n     * @return SecurityManager\n     */\n    @Bean\n    public SecurityManager securityManager() {\n        // 将自定义realm加进来\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm());\n        logger.info(&quot;====securityManager注册完成====&quot;);\n        return securityManager;\n    }\n}\n</code></pre>\n<p>配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。</p>\n<p>配置 Shiro 过滤器：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入Shiro过滤器\n     * @param securityManager 安全管理器\n     * @return ShiroFilterFactoryBean\n     */\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {\n        // 定义shiroFactoryBean\n        ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean();\n\n        // 设置自定义的securityManager\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n\n        // 设置默认登录的url，身份认证失败会访问该url\n        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);\n        // 设置成功之后要跳转的链接\n        shiroFilterFactoryBean.setSuccessUrl(&quot;/success&quot;);\n        // 设置未授权界面，权限认证失败会访问该url\n        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;);\n\n        // LinkedHashMap是有序的，进行顺序拦截器配置\n        Map&lt;String,String&gt; filterChainMap = new LinkedHashMap&lt;&gt;();\n\n        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行\n        filterChainMap.put(&quot;/css/**&quot;, &quot;anon&quot;);\n        filterChainMap.put(&quot;/imgs/**&quot;, &quot;anon&quot;);\n        filterChainMap.put(&quot;/js/**&quot;, &quot;anon&quot;);\n        filterChainMap.put(&quot;/swagger-*/**&quot;, &quot;anon&quot;);\n        filterChainMap.put(&quot;/swagger-ui.html/**&quot;, &quot;anon&quot;);\n        // 登录url 放行\n        filterChainMap.put(&quot;/login&quot;, &quot;anon&quot;);\n\n        // “/user/admin” 开头的需要身份认证，authc表示要身份认证\n        filterChainMap.put(&quot;/user/admin*&quot;, &quot;authc&quot;);\n        // “/user/student” 开头的需要角色认证，是“admin”才允许\n        filterChainMap.put(&quot;/user/student*/**&quot;, &quot;roles[admin]&quot;);\n        // “/user/teacher” 开头的需要权限认证，是“user:create”才允许\n        filterChainMap.put(&quot;/user/teacher*/**&quot;, &quot;perms[\\&quot;user:create\\&quot;]&quot;);\n\n        // 配置logout过滤器\n        filterChainMap.put(&quot;/logout&quot;, &quot;logout&quot;);\n\n        // 设置shiroFilterFactoryBean的FilterChainDefinitionMap\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);\n        logger.info(&quot;====shiroFilterFactoryBean注册完成====&quot;);\n        return shiroFilterFactoryBean;\n    }\n}\n</code></pre>\n<p>配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：</p>\n<blockquote>\n<p>默认登录的 url：身份认证失败会访问该 url<br>认证成功之后要跳转的 url<br>权限认证失败会访问该 url<br>需要拦截或者放行的 url：这些都放在一个 map 中</p>\n</blockquote>\n<p>从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Filter</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">anon</td>\n<td style=\"text-align:center\">开放权限，可以理解为匿名用户或游客，可以直接访问的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">authc</td>\n<td style=\"text-align:center\">需要身份认证的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">logout</td>\n<td style=\"text-align:center\">注销，执行后会直接跳转到 <code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的 url，即登录页面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">roles[admin]</td>\n<td style=\"text-align:center\">参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]，当有多个参数时必须每个参数都通过才算通过</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">perms[user]</td>\n<td style=\"text-align:center\">参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3-2-4-shiro-\"><a name=\"2.4 使用 Shiro 进行认证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 使用 Shiro 进行认证</h3><p>到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：</p>\n<blockquote>\n<p>接口一： 使用 <code>http://localhost:8080/user/admin</code> 来验证身份认证<br>接口二： 使用 <code>http://localhost:8080/user/student</code> 来验证角色认证<br>接口三： 使用 <code>http://localhost:8080/user/teacher</code> 来验证权限认证<br>接口四： 使用 <code>http://localhost:8080/user/login</code> 来实现用户登录</p>\n</blockquote>\n<p>然后来一下认证的流程：</p>\n<blockquote>\n<p>流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。<br>流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。<br>流程三： 访问接口二，测试角色认证是否成功。<br>流程四： 访问接口三，测试权限认证是否成功。</p>\n</blockquote>\n<h4 id=\"h4-2-4-1-\"><a name=\"2.4.1 身份、角色、权限认证接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.1 身份、角色、权限认证接口</h4><pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/user&quot;)\npublic class UserController {\n\n    /**\n     * 身份认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(&quot;/admin&quot;)\n    public String admin(HttpServletRequest request) {\n        Object user = request.getSession().getAttribute(&quot;user&quot;);\n        return &quot;success&quot;;\n    }\n\n    /**\n     * 角色认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(&quot;/student&quot;)\n    public String student(HttpServletRequest request) {\n        return &quot;success&quot;;\n    }\n\n    /**\n     * 权限认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(&quot;/teacher&quot;)\n    public String teacher(HttpServletRequest request) {\n        return &quot;success&quot;;\n    }\n}\n</code></pre>\n<p>这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。</p>\n<h4 id=\"h4-2-4-2-\"><a name=\"2.4.2 用户登录接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.2 用户登录接口</h4><pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/user&quot;)\npublic class UserController {\n\n    /**\n     * 用户登录接口\n     * @param user user\n     * @param request request\n     * @return string\n     */\n    @PostMapping(&quot;/login&quot;)\n    public String login(User user, HttpServletRequest request) {\n\n        // 根据用户名和密码创建token\n        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());\n        // 获取subject认证主体\n        Subject subject = SecurityUtils.getSubject();\n        try{\n            // 开始认证，这一步会跳到我们自定义的realm中\n            subject.login(token);\n            request.getSession().setAttribute(&quot;user&quot;, user);\n            return &quot;success&quot;;\n        }catch(Exception e){\n            e.printStackTrace();\n            request.getSession().setAttribute(&quot;user&quot;, user);\n            request.setAttribute(&quot;error&quot;, &quot;用户名或密码错误！&quot;);\n            return &quot;login&quot;;\n        }\n    }\n}\n</code></pre>\n<p>我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 <code>subject.login(token)</code> 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 <code>doGetAuthenticationInfo</code> 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。</p>\n<h4 id=\"h4-2-4-3-\"><a name=\"2.4.3 测试一下\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.3 测试一下</h4><p>最后，启动项目，测试一下：<br>浏览器请求 <code>http://localhost:8080/user/admin</code> 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 <code>/login</code> 接口，然后跳转到 <code>login.html</code> 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 <code>http://localhost:8080/user/student</code> 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 <code>http://localhost:8080/user/teacher</code> 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 <code>user:*</code>，满足配置中的 <code>user:create</code>，所以认证通过。</p>\n<p>接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。</p>\n<h2 id=\"h2-3-\"><a name=\"3. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 总结</h2><p>本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--17-spring-boot-lucence\"><a name=\"第17课：Spring Boot中集成Lucence\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第17课：Spring Boot中集成Lucence</h1><h2 id=\"h2-1-lucence-\"><a name=\"1. Lucence 和全文检索\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Lucence 和全文检索</h2><p>Lucene 是什么？看一下百度百科：</p>\n<blockquote>\n<p>Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》</p>\n</blockquote>\n<h3 id=\"h3-1-1-\"><a name=\"1.1 全文检索\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 全文检索</h3><p>这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。  </p>\n<p>何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。   </p>\n<p>文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。 </p>\n<h3 id=\"h3-1-2-lucene-\"><a name=\"1.2 Lucene 建立索引的方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 Lucene 建立索引的方式</h3><p>那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：</p>\n<blockquote>\n<p>文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.<br>文章2的内容为：He once lived in Shanghai.</p>\n</blockquote>\n<p>首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：</p>\n<blockquote>\n<p>文章1经过分词后的结果：<code>[Tom]</code> <code>[lives]</code> <code>[Guangzhou]</code> <code>[I]</code> <code>[live]</code> <code>[Guangzhou]</code><br>文章2经过分词后的结果：<code>[He]</code> <code>[lives]</code> <code>[Shanghai]</code></p>\n</blockquote>\n<p>然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：</p>\n<blockquote>\n<p>文章1经过处理后的结果：<code>[tom]</code> <code>[live]</code> <code>[guangzhou]</code> <code>[i]</code> <code>[live]</code> <code>[guangzhou]</code><br>文章2经过处理后的结果：<code>[he]</code> <code>[live]</code> <code>[shanghai]</code></p>\n</blockquote>\n<p>最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">关键词</th>\n<th style=\"text-align:center\">文章号[出现频率]</th>\n<th style=\"text-align:center\">出现位置</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">guangzhou</td>\n<td style=\"text-align:center\">1[2]</td>\n<td style=\"text-align:center\">3,6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">he</td>\n<td style=\"text-align:center\">2[1]</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">i</td>\n<td style=\"text-align:center\">1[1]</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">live</td>\n<td style=\"text-align:center\">1[2],2[1]</td>\n<td style=\"text-align:center\">2,5,2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">shanghai</td>\n<td style=\"text-align:center\">2[1]</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tom</td>\n<td style=\"text-align:center\">1[1]</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n<p>以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。<br>搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。</p>\n<p>理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。</p>\n<h2 id=\"h2-2-spring-boot-lucence\"><a name=\"2. Spring Boot 中集成 Lucence\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Spring Boot 中集成 Lucence</h2><h3 id=\"h3-2-1-\"><a name=\"2.1 依赖导入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 依赖导入</h3><p>首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：</p>\n<pre><code class=\"lang-xml\">&lt;!-- Lucence核心包 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;\n    &lt;artifactId&gt;lucene-core&lt;/artifactId&gt;\n    &lt;version&gt;5.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Lucene查询解析包 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;\n    &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;\n    &lt;version&gt;5.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- 常规的分词（英文） --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;\n    &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt;\n    &lt;version&gt;5.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!--支持分词高亮  --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;\n    &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt;\n    &lt;version&gt;5.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!--支持中文分词  --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;\n    &lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt;\n    &lt;version&gt;5.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。</p>\n<h3 id=\"h3-2-2-\"><a name=\"2.2 快速入门\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 快速入门</h3><p>根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。</p>\n<h4 id=\"h4-2-2-1-\"><a name=\"2.2.1 建立索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 建立索引</h4><p>我们自己弄几个文件，放到 <code>D:\\lucene\\data</code> 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。</p>\n<pre><code class=\"lang-java\">public class Indexer {\n\n    /**\n     * 写索引实例\n     */\n    private IndexWriter writer;\n\n    /**\n     * 构造方法，实例化IndexWriter\n     * @param indexDir\n     * @throws Exception\n     */\n    public Indexer(String indexDir) throws Exception {\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        //标准分词器，会自动去掉空格啊，is a the等单词\n        Analyzer analyzer = new StandardAnalyzer();\n        //将标准分词器配到写索引的配置中\n        IndexWriterConfig config = new IndexWriterConfig(analyzer);\n        //实例化写索引对象\n        writer = new IndexWriter(dir, config);\n    }\n}\n</code></pre>\n<p>在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。</p>\n<pre><code class=\"lang-java\">/**\n * 索引指定目录下的所有文件\n * @param dataDir\n * @return\n * @throws Exception\n */\npublic int indexAll(String dataDir) throws Exception {\n    // 获取该路径下的所有文件\n    File[] files = new File(dataDir).listFiles();\n    if (null != files) {\n        for (File file : files) {\n            //调用下面的indexFile方法，对每个文件进行索引\n            indexFile(file);\n        }\n    }\n    //返回索引的文件数\n    return writer.numDocs();\n}\n\n/**\n * 索引指定的文件\n * @param file\n * @throws Exception\n */\nprivate void indexFile(File file) throws Exception {\n    System.out.println(&quot;索引文件的路径：&quot; + file.getCanonicalPath());\n    //调用下面的getDocument方法，获取该文件的document\n    Document doc = getDocument(file);\n    //将doc添加到索引中\n    writer.addDocument(doc);\n}\n\n/**\n * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录\n * @param file\n * @return\n * @throws Exception\n */\nprivate Document getDocument(File file) throws Exception {\n    Document doc = new Document();\n    //开始添加字段\n    //添加内容\n    doc.add(new TextField(&quot;contents&quot;, new FileReader(file)));\n    //添加文件名，并把这个字段存到索引文件里\n    doc.add(new TextField(&quot;fileName&quot;, file.getName(), Field.Store.YES));\n    //添加文件路径\n    doc.add(new TextField(&quot;fullPath&quot;, file.getCanonicalPath(), Field.Store.YES));\n    return doc;\n}\n</code></pre>\n<p>这样就建立好索引了，我们在该类中写一个 main 方法测试一下：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n        //索引保存到的路径\n        String indexDir = &quot;D:\\\\lucene&quot;;\n        //需要索引的文件数据存放的目录\n        String dataDir = &quot;D:\\\\lucene\\\\data&quot;;\n        Indexer indexer = null;\n        int indexedNum = 0;\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        try {\n            // 开始构建索引\n            indexer = new Indexer(indexDir);\n            indexedNum = indexer.indexAll(dataDir);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (null != indexer) {\n                    indexer.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;索引耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);\n        System.out.println(&quot;共索引了&quot; + indexedNum + &quot;个文件&quot;);\n    }\n</code></pre>\n<p>我搞了两个 tomcat 相关的文件放到 <code>D:\\lucene\\data</code> 下了，执行完之后，看到控制台输出：</p>\n<pre><code>索引文件的路径：D:\\lucene\\data\\catalina.properties\n索引文件的路径：D:\\lucene\\data\\logging.properties\n索引耗时882毫秒\n共索引了2个文件\n</code></pre><p>然后我们去 <code>D:\\lucene\\</code> 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。</p>\n<h4 id=\"h4-2-2-2-\"><a name=\"2.2.2 检索内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 检索内容</h4><p>上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。</p>\n<pre><code class=\"lang-java\">public class Searcher {\n\n    public static void search(String indexDir, String q) throws Exception {\n\n        //获取要查询的路径，也就是索引所在的位置\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        IndexReader reader = DirectoryReader.open(dir);\n        //构建IndexSearcher\n        IndexSearcher searcher = new IndexSearcher(reader);\n        //标准分词器，会自动去掉空格啊，is a the等单词\n        Analyzer analyzer = new StandardAnalyzer();\n        //查询解析器\n        QueryParser parser = new QueryParser(&quot;contents&quot;, analyzer);\n        //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串\n        Query query = parser.parse(q);\n\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        //开始查询，查询前10条数据，将记录保存在docs中\n        TopDocs docs = searcher.search(query, 10);\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(&quot;匹配&quot; + q + &quot;共耗时&quot; + (endTime-startTime) + &quot;毫秒&quot;);\n        System.out.println(&quot;查询到&quot; + docs.totalHits + &quot;条记录&quot;);\n\n        //取出每条查询结果\n        for(ScoreDoc scoreDoc : docs.scoreDocs) {\n            //scoreDoc.doc相当于docID,根据这个docID来获取文档\n            Document doc = searcher.doc(scoreDoc.doc);\n            //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。\n            System.out.println(doc.get(&quot;fullPath&quot;));\n        }\n        reader.close();\n    }\n}\n</code></pre>\n<p>ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：</p>\n<pre><code class=\"lang-java\">public static void main(String[] args) {\n    String indexDir = &quot;D:\\\\lucene&quot;;\n    //查询这个字符串\n    String q = &quot;security&quot;;\n    try {\n        search(indexDir, q);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>\n<p>查一下 <code>security</code> 这个字符串，执行一下看控制台打印的结果：</p>\n<pre><code>匹配security共耗时23毫秒\n查询到1条记录\nD:\\lucene\\data\\catalina.properties\n</code></pre><p>可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。</p>\n<h3 id=\"h3-2-3-\"><a name=\"2.3 中文分词检索高亮实战\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 中文分词检索高亮实战</h3><p>上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。</p>\n<h4 id=\"h4-2-3-1-\"><a name=\"2.3.1 中文分词\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.1 中文分词</h4><p>我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：</p>\n<pre><code class=\"lang-java\">public class ChineseIndexer {\n\n    /**\n     * 存放索引的位置\n     */\n    private Directory dir;\n\n    //准备一下用来测试的数据\n    //用来标识文档\n    private Integer ids[] = {1, 2, 3};\n    private String citys[] = {&quot;上海&quot;, &quot;南京&quot;, &quot;青岛&quot;};\n    private String descs[] = {\n            &quot;上海是个繁华的城市。&quot;,\n            &quot;南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。&quot;,\n            &quot;青岛是一个美丽的城市。&quot;\n    };\n\n    /**\n     * 生成索引\n     * @param indexDir\n     * @throws Exception\n     */\n    public void index(String indexDir) throws Exception {\n        dir = FSDirectory.open(Paths.get(indexDir));\n        // 先调用 getWriter 获取IndexWriter对象\n        IndexWriter writer = getWriter();\n        for(int i = 0; i &lt; ids.length; i++) {\n            Document doc = new Document();\n            // 把上面的数据都生成索引，分别用id、city和desc来标识\n            doc.add(new IntField(&quot;id&quot;, ids[i], Field.Store.YES));\n            doc.add(new StringField(&quot;city&quot;, citys[i], Field.Store.YES));\n            doc.add(new TextField(&quot;desc&quot;, descs[i], Field.Store.YES));\n            //添加文档\n            writer.addDocument(doc);\n        }\n        //close了才真正写到文档中\n        writer.close();\n    }\n\n    /**\n     * 获取IndexWriter实例\n     * @return\n     * @throws Exception\n     */\n    private IndexWriter getWriter() throws Exception {\n        //使用中文分词器\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\n        //将中文分词器配到写索引的配置中\n        IndexWriterConfig config = new IndexWriterConfig(analyzer);\n        //实例化写索引对象\n        IndexWriter writer = new IndexWriter(dir, config);\n        return writer;\n    }\n\n    public static void main(String[] args) throws Exception {\n        new ChineseIndexer().index(&quot;D:\\\\lucene2&quot;);\n    }\n}\n</code></pre>\n<p>这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。<br>然后执行一下 main 方法，将索引保存到 <code>D:\\lucene2\\</code> 中。 </p>\n<h4 id=\"h4-2-3-2-\"><a name=\"2.3.2 中文分词查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.2 中文分词查询</h4><p>中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：</p>\n<pre><code class=\"lang-java\">public class ChineseSearch {\n\n    private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class);\n\n    public static List&lt;String&gt; search(String indexDir, String q) throws Exception {\n\n        //获取要查询的路径，也就是索引所在的位置\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        //使用中文分词器\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\n        //由中文分词器初始化查询解析器\n        QueryParser parser = new QueryParser(&quot;desc&quot;, analyzer);\n        //通过解析要查询的String，获取查询对象\n        Query query = parser.parse(q);\n\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        //开始查询，查询前10条数据，将记录保存在docs中\n        TopDocs docs = searcher.search(query, 10);\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        logger.info(&quot;匹配{}共耗时{}毫秒&quot;, q, (endTime - startTime));\n        logger.info(&quot;查询到{}条记录&quot;, docs.totalHits);\n\n        //如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt;\n        SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(&quot;&lt;b&gt;&lt;font color=red&gt;&quot;,&quot;&lt;/font&gt;&lt;/b&gt;&quot;);\n        //根据查询对象计算得分，会初始化一个查询结果最高的得分\n        QueryScorer scorer = new QueryScorer(query);\n        //根据这个得分计算出一个片段\n        Fragmenter fragmenter = new SimpleSpanFragmenter(scorer);\n        //将这个片段中的关键字用上面初始化好的高亮格式高亮\n        Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer);\n        //设置一下要显示的片段\n        highlighter.setTextFragmenter(fragmenter);\n\n        //取出每条查询结果\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for(ScoreDoc scoreDoc : docs.scoreDocs) {\n            //scoreDoc.doc相当于docID,根据这个docID来获取文档\n            Document doc = searcher.doc(scoreDoc.doc);\n            logger.info(&quot;city:{}&quot;, doc.get(&quot;city&quot;));\n            logger.info(&quot;desc:{}&quot;, doc.get(&quot;desc&quot;));\n            String desc = doc.get(&quot;desc&quot;);\n\n            //显示高亮\n            if(desc != null) {\n                TokenStream tokenStream = analyzer.tokenStream(&quot;desc&quot;, new StringReader(desc));\n                String summary = highlighter.getBestFragment(tokenStream, desc);\n                logger.info(&quot;高亮后的desc:{}&quot;, summary);\n                list.add(summary);\n            }\n        }\n        reader.close();\n        return list;\n    }\n}\n</code></pre>\n<p>每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。</p>\n<h4 id=\"h4-2-3-3-\"><a name=\"2.3.3 测试一下\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.3 测试一下</h4><p>这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：</p>\n<pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/lucene&quot;)\npublic class IndexController {\n\n    @GetMapping(&quot;/test&quot;)\n    public String test(Model model) {\n        // 索引所在的目录\n        String indexDir = &quot;D:\\\\lucene2&quot;;\n        // 要查询的字符\n//        String q = &quot;南京文明&quot;;\n        String q = &quot;南京文化&quot;;\n        try {\n            List&lt;String&gt; list = ChineseSearch.search(indexDir, q);\n            model.addAttribute(&quot;list&quot;, list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return &quot;result&quot;;\n    }\n}\n</code></pre>\n<p>直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。</p>\n<pre><code class=\"lang-xml\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div th:each=&quot;desc : ${list}&quot;&gt;\n    &lt;div th:utext=&quot;${desc}&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这里注意一下，不能使用 <code>th:test</code>，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 <code>http://localhost:8080/lucene/test</code>，测试一下效果，我们搜索的是 “南京文化”。</p>\n<p><img src=\"https://images.gitbook.cn/83b3f810-b377-11e8-88bf-23cb78d1fb4f\" alt=\"南京文化\"></p>\n<p>再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。</p>\n<p><img src=\"https://images.gitbook.cn/8ef8a4a0-b377-11e8-911d-27cc5f059829\" alt=\"南京文明\"></p>\n<p>可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。</p>\n<h2 id=\"h2-3-\"><a name=\"3. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 总结</h2><p>本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--18-spring-boot-\"><a name=\"第18课：Spring Boot搭建实际项目开发中的架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第18课：Spring Boot搭建实际项目开发中的架构</h1><p>前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。</p>\n<p>不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。</p>\n<p>从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p>\n<p>结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。</p>\n<p><img src=\"https://images.gitbook.cn/6f23c980-b89e-11e8-87f1-559c9b456754\" alt=\"工程架构\"></p>\n<h2 id=\"h2-1-\"><a name=\"1. 统一的数据封装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 统一的数据封装</h2><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p>\n<pre><code class=\"lang-java\">/**\n * 统一返回对象\n * @author shengwu ni\n * @param &lt;T&gt;\n */\npublic class JsonResult&lt;T&gt; {\n\n    private T data;\n    private String code;\n    private String msg;\n\n    /**\n     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！\n     */\n    public JsonResult() {\n        this.code = &quot;0&quot;;\n        this.msg = &quot;操作成功！&quot;;\n    }\n\n    /**\n     * 若没有数据返回，可以人为指定状态码和提示信息\n     * @param code\n     * @param msg\n     */\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    /**\n     * 有数据返回时，状态码为0，默认提示信息为：操作成功！\n     * @param data\n     */\n    public JsonResult(T data) {\n        this.data = data;\n        this.code = &quot;0&quot;;\n        this.msg = &quot;操作成功！&quot;;\n    }\n\n    /**\n     * 有数据返回，状态码为0，人为指定提示信息\n     * @param data\n     * @param msg\n     */\n    public JsonResult(T data, String msg) {\n        this.data = data;\n        this.code = &quot;0&quot;;\n        this.msg = msg;\n    }\n\n    /**\n     * 使用自定义异常作为参数传递状态码和提示信息\n     * @param msgEnum\n     */\n    public JsonResult(BusinessMsgEnum msgEnum) {\n        this.code = msgEnum.code();\n        this.msg = msgEnum.msg();\n    }\n\n    // 省去get和set方法\n}\n</code></pre>\n<p>大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。</p>\n<h2 id=\"h2-2-json-\"><a name=\"2. json的处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. json的处理</h2><p>Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。</p>\n<pre><code class=\"lang-java\">/**\n * jacksonConfig\n * @author shengwu ni\n */\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    @Primary\n    @ConditionalOnMissingBean(ObjectMapper.class)\n    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n        ObjectMapper objectMapper = builder.createXmlMapper(false).build();\n        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(&quot;&quot;);\n            }\n        });\n        return objectMapper;\n    }\n}\n</code></pre>\n<p>这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。</p>\n<h2 id=\"h2-3-swagger2-\"><a name=\"3. swagger2在线可调式接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. swagger2在线可调式接口</h2><p>有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：</p>\n<pre><code class=\"lang-java\">/**\n * swagger配置\n * @author shengwu ni\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                // 指定构建api文档的详细信息的方法：apiInfo()\n                .apiInfo(apiInfo())\n                .select()\n                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口\n                .apis(RequestHandlerSelectors.basePackage(&quot;com.itcodai.course18.controller&quot;))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 构建api文档的详细信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                // 设置页面标题\n                .title(&quot;Spring Boot搭建实际项目中开发的架构&quot;)\n                // 设置接口描述\n                .description(&quot;跟武哥一起学Spring Boot第18课&quot;)\n                // 设置联系方式\n                .contact(&quot;倪升武，&quot; + &quot;微信公众号：程序员私房菜&quot;)\n                // 设置版本\n                .version(&quot;1.0&quot;)\n                // 构建\n                .build();\n    }\n}\n</code></pre>\n<p>到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。</p>\n<pre><code class=\"lang-java\">@RestController\n@Api(value = &quot;用户信息接口&quot;)\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    @GetMapping(&quot;/getUser/{id}&quot;)\n    @ApiOperation(value = &quot;根据用户唯一标识获取用户信息&quot;)\n    public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = &quot;用户唯一标识&quot;) Long id) {\n        User user = new User(id, &quot;倪升武&quot;, &quot;123456&quot;);\n        return new JsonResult&lt;&gt;(user);\n    }\n}\n</code></pre>\n<p>然后启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。</p>\n<h2 id=\"h2-4-\"><a name=\"4. 持久层集成\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 持久层集成</h2><p>每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。</p>\n<pre><code class=\"lang-yml\"># 服务端口号\nserver:\n  port: 8080\n\n# 数据库地址\ndatasource:\n  url: localhost:3306/blog_test\n\nspring:\n  datasource: # 数据库配置\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 10 # 最大连接池数\n      max-lifetime: 1770000\n\nmybatis:\n  # 指定别名设置的包为所有entity\n  type-aliases-package: com.itcodai.course18.entity\n  configuration:\n    map-underscore-to-camel-case: true # 驼峰命名规范\n  mapper-locations: # mapper映射文件位置\n    - classpath:mapper/*.xml\n</code></pre>\n<p>配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。</p>\n<pre><code class=\"lang-java\">public interface UserMapper {\n\n    @Select(&quot;select * from user where id = #{id}&quot;)\n    @Results({\n            @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),\n            @Result(property = &quot;password&quot;, column = &quot;password&quot;)\n    })\n    User getUser(Long id);\n\n    @Select(&quot;select * from user where id = #{id} and user_name=#{name}&quot;)\n    User getUserByIdAndName(@Param(&quot;id&quot;) Long id, @Param(&quot;name&quot;) String username);\n\n    @Select(&quot;select * from user&quot;)\n    List&lt;User&gt; getAll();\n}\n</code></pre>\n<p>关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 <code><a href=\"https://github.com/MapperScan\" title=\"&#64;MapperScan\" class=\"at-link\">@MapperScan</a>(&quot;com.itcodai.course18.dao&quot;)</code></p>\n<h2 id=\"h2-5-\"><a name=\"5. 拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 拦截器</h2><p>拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</p>\n<pre><code class=\"lang-java\">public class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        logger.info(&quot;执行方法之前执行(Controller方法调用之前)&quot;);\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;);\n    }\n}\n</code></pre>\n<p>然后将自定义的拦截器加入到拦截器配置中。</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor())\n                // 拦截所有url\n                .addPathPatterns(&quot;/**&quot;)\n                // 放行swagger\n                .excludePathPatterns(&quot;/swagger-resources/**&quot;);\n    }\n}\n</code></pre>\n<p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p>\n<blockquote>\n<p>classpath:/static<br>classpath:/public<br>classpath:/resources<br>classpath:/META-INF/resources  </p>\n</blockquote>\n<p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p>\n<p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p>\n<h2 id=\"h2-6-\"><a name=\"6. 全局异常处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 全局异常处理</h2><p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p>\n<pre><code class=\"lang-java\">public enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(&quot;102&quot;, &quot;参数异常!&quot;),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(&quot;103&quot;, &quot;服务调用超时！&quot;),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(&quot;102&quot;, &quot;输入的图片数量不能超过50张!&quot;),\n    /** 500 : 发生异常 */\n    UNEXPECTED_EXCEPTION(&quot;500&quot;, &quot;系统发生异常，请联系管理员！&quot;);\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public String code() {\n        return code;\n    }\n\n    public String msg() {\n        return msg;\n    }\n\n}\n</code></pre>\n<p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p>\n<pre><code class=\"lang-java\">@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(&quot;空指针异常，{}&quot;, ex.getMessage());\n        return new JsonResult(&quot;500&quot;, &quot;空指针异常了&quot;);\n    }\n\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(&quot;系统异常：&quot;, ex);\n        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n    }\n\n}\n</code></pre>\n<p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p>\n<h2 id=\"h2-7-\"><a name=\"7. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 总结</h2><p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p>\n<p>课程源代码下载地址：<a href=\"https://gitee.com/eson15/springboot_study\">戳我下载</a></p>\n<blockquote>\n<p>欢迎关注我的为微信公众号：武哥聊编程</p>\n</blockquote>\n<h1 id=\"h1--\"><a name=\"附：作者信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>附：作者信息</h1><p>本课程首发于 CSDN GitChat 达人课，该文档为课程详细笔记<br>作者：倪升武（武哥）<br>微信公众号：武哥聊编程<br>二维码：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/202002150421550.jpg\" alt=\"武哥聊编程\"></p>\n<blockquote>\n<p>版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途，否则追究法律责任。</p>\n</blockquote>\n', '# 跟武哥一起学习Spring Boot\n\n# 作者信息\n\n本课程首发于 CSDN GitChat 达人课《跟武哥一起学Spring Boot》，该文档为课程详细笔记。\n作者：倪升武（武哥）\n微信公众号：武哥聊编程\n![武哥聊编程](https://img-blog.csdnimg.cn/202002150421550.jpg)\n\n>版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途和其他不正当用途，否则追究法律责任。\n\n\n\n# 导读：课程概览\n\n## 1. Spring Boot是什么\n\n我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。**繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低**。  \n\n2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求**在 Spring 框架中支持无容器 Web 应用程序体系结构**。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：\n\n> 我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 `main()`方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。 \n\n这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而**是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具**。\n\n它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。   \n\n## 2. 为什么学习Spring Boot\n\n### 2.1 从Spring官方来看\n\n我们打开 Spring 的[官方网站](http://spring.io/)，可以看到下图：  \n\n![Spring官网首图](https://images.gitbook.cn/98fda7f0-8656-11e8-8675-5537a701ae7d)\n\n我们可以看到图中官方对 Spring Boot 的定位：*Build Anything*， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。  同时我们也来看一下官方对后面两个的定位：  \n\nSpringCloud：*Coordinate Anything*，协调任何事情；\nSpringCloud Data Flow：*Connect everything*，连接任何东西。\n\n仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。\n\n### 2.2 从Spring Boot的优点来看\n\nSpring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：\n\n![Spring Boot的优点](https://images.gitbook.cn/e17b8c40-8656-11e8-8a91-d70bc2d847c5)\n\n#### 2.2.1 良好的基因\n\nSpring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。\n\n![Spring Boot与Spring](https://images.gitbook.cn/00078650-8657-11e8-87de-d910a3ee087e)\n\n#### 2.2.2 简化编码\n\n举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：\n\n```xml\n<!-- .....省略其他依赖 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>5.0.7.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.0.7.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。\n\n#### 2.2.3 简化配置\n\nSpring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：\n\n我新建一个类，但是我不用 `@Service`注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要`@Configuration` 和`@Bean`两个注解即可，如下：\n\n```java\npublic class TestService {\n    public String sayHello () {\n        return \"Hello Spring Boot!\";\n    }\n}\n```\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class JavaConfig {\n    @Bean\n    public TestService getTestService() {\n        return new TestService();\n    }\n}\n```\n\n`@Configuration`表示该类是个配置类，`@Bean`表示该方法返回一个 Bean。这样就把`TestService`作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用`@Resource`注解注入进来即可使用，非常方便。\n\n```java\n@Resource\nprivate TestService testService;\n```\n\n另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。\n\n#### 2.2.4 简化部署\n\n在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 `java -jar xxx.jar`一键式启动项目。\n\n另外，也降低对运行环境的基本要求，环境变量中有JDK即可。\n\n#### 2.2.5 简化监控\n\n我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。\n\n### 2.3 从未来发展的趋势来看\n\n微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。\n\n## 3. 本课程能学到什么\n\n本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。  \n\n基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。  \n\n进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。  \n\n认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。  \n\n课程所有源码提供免费下载：[下载地址](https://gitee.com/eson15/springboot_study)。\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n## 4. 适合阅读的人群\n\n本课程适合以下人群阅读：\n\n* 有一定的Java语言基础，了解Spring、Maven的在校学生或自学者\n* 有传统项目经验，想往微服务方向发展的工作人员\n* 热衷于新技术并对 Spring Boot 感兴趣的人员\n* 希望了解 Spring Boot 2.0.3 的研究人员\n\n## 5. 本课程开发环境和插件\n\n本课程的开发环境：\n\n* 开发工具：IDEA 2017\n* JDK版本： JDK 1.8\n* Spring Boot版本：2.0.3 RELEASE\n* Maven版本：3.5.2\n\n涉及到的插件：\n\n* FastJson\n* Swagger2\n* Thymeleaf\n* MyBatis\n* Redis\n* ActiveMQ\n* Shiro\n* Lucence\n\n\n## 6. 课程目录\n\n* 导读：课程概览\n* 第01课：Spring Boot开发环境搭建和项目启动\n* 第02课：Spring Boot返回Json数据及数据封装\n* 第03课：Spring Boot使用slf4j进行日志记录\n* 第04课：Spring Boot中的项目属性配置\n* 第05课：Spring Boot中的MVC支持\n* 第06课：Spring Boot集成Swagger2展现在线接口文档\n* 第07课：Spring Boot集成Thymeleaf模板引擎\n* 第08课：Spring Boot中的全局异常处理\n* 第09课：Spring Boot中的切面AOP处理\n* 第10课：Spring Boot中集成MyBatis\n* 第11课：Spring Boot事务配置管理\n* 第12课：Spring Boot中使用监听器\n* 第13课：Spring Boot中使用拦截器\n* 第14课：Spring Boot中集成Redis\n* 第15课：Spring Boot中集成ActiveMQ\n* 第16课：Spring Boot中集成Shiro\n* 第17课：Spring Boot中结成Lucence\n* 第18课：Spring Boot搭建实际项目开发中的架构\n\n>欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第01课：Spring Boot开发环境搭建和项目启动\n\n上一节对 SpringBoot 的特性做了一个介绍，本节主要对 **jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析**。\n\n## 1. jdk 的配置\n\n本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开`File->Project Structure`，如下图所：\n\n![IDEA中配置jdk](https://images.gitbook.cn/9befde80-8659-11e8-9b0d-95de449dc107)\n\n1. 选择 SDKs\n2. 在 JDK home path 中选择本地 jdk 的安装目录\n3. 在 Name 中为 jdk 自定义名字\n\n通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：\n\n* `window->preference->java->Instralled JRES`来添加本地 jdk。\n* `window-->preference-->java-->Compiler`选择 jre，和 jdk 保持一致。\n\n## 2. Spring Boot 工程的构建\n\n### 2.1 IDEA 快速构建\n\nIDEA 中可以通过`File->New->Project`来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。\n\n* Group：填企业域名，本课程使用com.itcodai\n* Artifact：填项目名称，本课程中每一课的工程名以`course+课号`命令，这里使用 course01\n* Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。\n\n### 2.2 官方构建\n\n第二种方式可以通过官方构建，步骤如下：\n\n* 访问 http://start.spring.io/。\n* 在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。\n* ![创建Spring Boot工程](https://images.gitbook.cn/014a1ba0-865b-11e8-956e-f528114b28bd)\n* 解压后，使用 IDEA 导入该 maven 工程：`File->New->Model from Existing Source`，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过`Import->Existing Maven Projects->Next`，然后选择解压后的项目文件夹即可。\n\n### 2.3 maven配置\n\n创建了 Spring Boot 项目之后，需要进行 maven 配置。打开`File->settings`，搜索 maven，配置一下本地的 maven 信息。如下：\n\n![maven配置](https://images.gitbook.cn/2ff7b930-865b-11e8-8675-5537a701ae7d)\n\n在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。\n\n```xml\n<mirror>\n	<id>nexus-aliyun</id>\n	<mirrorOf>*</mirrorOf>\n	<name>Nexus aliyun</name>\n	<url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n```\n\n如果是使用 eclipse 的朋友，可以通过`window-->preference-->Maven-->User Settings`来配置，配置方式和上面一致。\n\n### 2.4 编码配置\n\n同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。\n\nIDEA 中，仍然是打开`File->settings`，搜索 encoding，配置一下本地的编码信息。如下：\n\n![编码配置](https://images.gitbook.cn/57564e60-865b-11e8-8a91-d70bc2d847c5)\n\n如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：\n\n* window--> perferences-->General-->Workspace，将Text file encoding改成utf-8\n* window-->perferences-->General-->content types，选中Text，将Default encoding填入utf-8\n\nOK，编码设置完成即可启动项目工程了。\n\n## 3. Spring Boot 项目工程结构\n\nSpring Boot 项目总共有三个模块，如下图所示：\n\n![Spring Boot项目工程结构](https://images.gitbook.cn/8b32fa80-865b-11e8-9d13-03ea4b4d8504)\n\n* src/main/java路径：主要编写业务程序\n* src/main/resources路径：存放静态文件和配置文件\n* src/test/java路径：主要编写测试程序\n\n默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个`@SpringBootApplication`注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。\n\n到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：\n\n```java\npackage com.itcodai.course01.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/start\")\npublic class StartController {\n\n    @RequestMapping(\"/springboot\")\n    public String startSpringBoot() {\n        return \"Welcome to the world of Spring Boot!\";\n    }\n}\n```\n\n重新运行 main 方法启动项目，在浏览器中输入 `localhost:8080/start/springboot`，如果看到 `“Welcome to the world of Spring Boot!”`，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 `server.port` 来人为指定端口，如8001端口：\n\n```xml\nserver:\n  port: 8001\n```\n\n## 4. 总结\n\n本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第02课：Spring Boot返回Json数据及数据封装\n\n在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用`@RestController`注解即可返回 Json 格式的数据，`@RestController`也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n\n可以看出， `@RestController` 注解包含了原来的 `@Controller` 和 `@ResponseBody` 注解，使用过 Spring 的朋友对 `@Controller` 注解已经非常了解了，这里不再赘述， `@ResponseBody` 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 `@RestController` 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 `spring-boot-starter-web` 依赖，可以看到一个 `spring-boot-starter-json` 依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-json</artifactId>\n    <version>2.0.3.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n```\n\nSpring Boot 中对依赖都做了很好的封装，可以看到很多 `spring-boot-starter-xxx` 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 `spring-boot-starter-json` 依赖，可以看到：\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jdk8</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jsr310</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.module</groupId>\n    <artifactId>jackson-module-parameter-names</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。\n\n## 1. Spring Boot 默认对Json的处理\n\n在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。\n\n### 1.1 创建 User 实体类\n\n为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。\n\n```java\npublic class User {\n    private Long id;\n    private String username;\n    private String password;\n	/* 省略get、set和带参构造方法 */\n}\n```\n\n### 1.2 创建Controller类\n\n然后我们创建一个 Controller，分别返回 `User`对象、`List<User>` 和 `Map<String, Object>`。\n\n```java\nimport com.itcodai.course02.entity.User;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/json\")\npublic class JsonController {\n\n    @RequestMapping(\"/user\")\n    public User getUser() {\n        return new User(1, \"倪升武\", \"123456\");\n    }\n\n    @RequestMapping(\"/list\")\n    public List<User> getUserList() {\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(1, \"倪升武\", \"123456\");\n        User user2 = new User(2, \"达人课\", \"123456\");\n        userList.add(user1);\n        userList.add(user2);\n        return userList;\n    }\n\n    @RequestMapping(\"/map\")\n    public Map<String, Object> getMap() {\n        Map<String, Object> map = new HashMap<>(3);\n        User user = new User(1, \"倪升武\", \"123456\");\n        map.put(\"作者信息\", user);\n        map.put(\"博客地址\", \"http://blog.itcodai.com\");\n        map.put(\"CSDN地址\", \"http://blog.csdn.net/eson_15\");\n        map.put(\"粉丝数量\", 4153);\n        return map;\n    }\n}\n```\n\n### 1.3 测试不同数据类型返回的json\n\nOK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。\n\n在浏览器中输入：`localhost:8080/json/user` 返回 json 如下：\n\n```json\n{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"}\n```\n\n在浏览器中输入：`localhost:8080/json/list` 返回 json 如下：\n\n```json\n[{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"},{\"id\":2,\"username\":\"达人课\",\"password\":\"123456\"}]\n```\n\n在浏览器中输入：`localhost:8080/json/map` 返回 json 如下：\n\n```json\n{\"作者信息\":{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"},\"CSDN地址\":\"http://blog.csdn.net/eson_15\",\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"}\n```\n\n可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。\n\n### 1.4 jackson 中对null的处理\n\n在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 \"\" 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：\n\n```java\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\n\nimport java.io.IOException;\n\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    @Primary\n    @ConditionalOnMissingBean(ObjectMapper.class)\n    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n        ObjectMapper objectMapper = builder.createXmlMapper(false).build();\n        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer<Object>() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(\"\");\n            }\n        });\n        return objectMapper;\n    }\n}\n```\n\n然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：\n\n```java\n@RequestMapping(\"/map\")\npublic Map<String, Object> getMap() {\n    Map<String, Object> map = new HashMap<>(3);\n    User user = new User(1, \"倪升武\", null);\n    map.put(\"作者信息\", user);\n    map.put(\"博客地址\", \"http://blog.itcodai.com\");\n    map.put(\"CSDN地址\", null);\n    map.put(\"粉丝数量\", 4153);\n    return map;\n}\n```\n\n重启项目，再次输入：`localhost:8080/json/map`，可以看到 jackson 已经将所有 null 字段转成了空字符串了。\n\n```json\n{\"作者信息\":{\"id\":1,\"username\":\"倪升武\",\"password\":\"\"},\"CSDN地址\":\"\",\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"}\n```\n\n\n## 2. 使用阿里巴巴FastJson的设置\n\n### 2.1 jackson 和 fastJson 的对比\n\n有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。\n\n|         选项          | fastJson | jackson |\n| :-------------------: | :------: | :-----: |\n|     上手难易程度      |   容易   |  中等   |\n|     高级特性支持      |   中等   |  丰富   |\n| 官方文档、Example支持 |   中文   |  英文   |\n|     处理json速度      |   略快   |   快    |\n\n关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。\n\n### 2.2 fastJson依赖导入\n\n使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：\n\n```xml\n<dependency>\n	<groupId>com.alibaba</groupId>\n	<artifactId>fastjson</artifactId>\n	<version>1.2.35</version>\n</dependency>\n```\n\n### 2.2 使用 fastJson 处理 null\n\n使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承  `WebMvcConfigurationSupport` 类，然后覆盖 `configureMessageConverters` 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：\n\n\n```java\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.alibaba.fastjson.support.config.FastJsonConfig;\nimport com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Configuration\npublic class fastJsonConfig extends WebMvcConfigurationSupport {\n\n    /**\n     * 使用阿里 FastJson 作为JSON MessageConverter\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(\n                // 保留map空的字段\n                SerializerFeature.WriteMapNullValue,\n                // 将String类型的null转成\"\"\n                SerializerFeature.WriteNullStringAsEmpty,\n                // 将Number类型的null转成0\n                SerializerFeature.WriteNullNumberAsZero,\n                // 将List类型的null转成[]\n                SerializerFeature.WriteNullListAsEmpty,\n                // 将Boolean类型的null转成false\n                SerializerFeature.WriteNullBooleanAsFalse,\n                // 避免循环引用\n                SerializerFeature.DisableCircularReferenceDetect);\n\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        List<MediaType> mediaTypeList = new ArrayList<>();\n        // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = \"application/json\"\n        mediaTypeList.add(MediaType.APPLICATION_JSON);\n        converter.setSupportedMediaTypes(mediaTypeList);\n        converters.add(converter);\n    }\n}\n```\n\n## 3. 封装统一返回的数据结构\n\n以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。 \n\n### 3.1 定义统一的 json 结构\n\n由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：\n\n```java\npublic class JsonResult<T> {\n\n    private T data;\n    private String code;\n    private String msg;\n\n    /**\n     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！\n     */\n    public JsonResult() {\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 若没有数据返回，可以人为指定状态码和提示信息\n     * @param code\n     * @param msg\n     */\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    /**\n     * 有数据返回时，状态码为0，默认提示信息为：操作成功！\n     * @param data\n     */\n    public JsonResult(T data) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 有数据返回，状态码为0，人为指定提示信息\n     * @param data\n     * @param msg\n     */\n    public JsonResult(T data, String msg) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = msg;\n    }\n    // 省略get和set方法\n}\n```\n\n### 3.2 修改 Controller 中的返回值类型及测试\n\n由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：\n\n```java\n@RestController\n@RequestMapping(\"/jsonresult\")\npublic class JsonResultController {\n\n    @RequestMapping(\"/user\")\n    public JsonResult<User> getUser() {\n        User user = new User(1, \"倪升武\", \"123456\");\n        return new JsonResult<>(user);\n    }\n\n    @RequestMapping(\"/list\")\n    public JsonResult<List> getUserList() {\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(1, \"倪升武\", \"123456\");\n        User user2 = new User(2, \"达人课\", \"123456\");\n        userList.add(user1);\n        userList.add(user2);\n        return new JsonResult<>(userList, \"获取用户列表成功\");\n    }\n\n    @RequestMapping(\"/map\")\n    public JsonResult<Map> getMap() {\n        Map<String, Object> map = new HashMap<>(3);\n        User user = new User(1, \"倪升武\", null);\n        map.put(\"作者信息\", user);\n        map.put(\"博客地址\", \"http://blog.itcodai.com\");\n        map.put(\"CSDN地址\", null);\n        map.put(\"粉丝数量\", 4153);\n        return new JsonResult<>(map);\n    }\n}\n```\n\n我们重新在浏览器中输入：`localhost:8080/jsonresult/user` 返回 json 如下：\n\n```json\n{\"code\":\"0\",\"data\":{\"id\":1,\"password\":\"123456\",\"username\":\"倪升武\"},\"msg\":\"操作成功！\"}\n```\n\n输入：`localhost:8080/jsonresult/list`，返回 json 如下：\n\n```json\n{\"code\":\"0\",\"data\":[{\"id\":1,\"password\":\"123456\",\"username\":\"倪升武\"},{\"id\":2,\"password\":\"123456\",\"username\":\"达人课\"}],\"msg\":\"获取用户列表成功\"}\n```\n\n输入：`localhost:8080/jsonresult/map`，返回 json 如下：\n\n```json\n{\"code\":\"0\",\"data\":{\"作者信息\":{\"id\":1,\"password\":\"\",\"username\":\"倪升武\"},\"CSDN地址\":null,\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"},\"msg\":\"操作成功！\"}\n```\n\n通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。\n\n## 4. 总结\n\n本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第03课：Spring Boot使用slf4j进行日志记录\n\n在开发中，我们经常使用 `System.out.println()` 来打印一些信息，但是这样不好，因为大量的使用 `System.out` 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。\n\n## 1. slf4j 介绍\n\n引用百度百科里的一段话：\n\n> SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。\n\n这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。\n\n正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：\n\n> 1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n\n“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n    private static final Logger logger = LoggerFactory.getLogger(Test.class);\n    // ……\n}\n```\n\n## 2. application.yml 中对日志的配置\n\nSpring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。`application.yml` 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 `application.properties` 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。\n\n我们看一下 application.yml 文件中对日志的配置：\n\n```xml\nlogging:\n  config: logback.xml\n  level:\n    com.itcodai.course03.dao: trace\n```\n\n`logging.config` 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 `logback.xml` 文件，关于日志的相关配置信息，都放在 `logback.xml` 文件中了。`logging.level` 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 `com.itcodai.course03.dao` 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。\n\n常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。\n\n## 3. logback.xml 配置文件解析\n\n在上面 `application.yml` 文件中，我们指定了日志配置文件 `logback.xml`，`logback.xml` 文件中主要用来做日志的相关配置。在 `logback.xml` 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：\n\n### 3.1 定义日志输出格式和存储路径\n\n```xml\n<configuration>\n	<property name=\"LOG_PATTERN\" value=\"%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\" />\n	<property name=\"FILE_PATH\" value=\"D:/logs/course03/demo.%d{yyyy-MM-dd}.%i.log\" />\n</configuration>\n```\n\n我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 `%date` 表示日期，`%thread` 表示线程名，`%-5level` 表示级别从左显示5个字符宽度，`%logger{36}`  表示 logger 名字最长36个字符，`%msg` 表示日志消息，`%n` 是换行符。\n\n然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。`%i` 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。\n\n### 3.2 定义控制台输出\n\n```xml\n<configuration>\n	<appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n		<encoder>\n            <!-- 按照上面配置的LOG_PATTERN来打印日志 -->\n			<pattern>${LOG_PATTERN}</pattern>\n		</encoder>\n	</appender>\n</configuration>\n```\n\n使用 `<appender>` 节点设置个控制台输出（`class=\"ch.qos.logback.core.ConsoleAppender\"`）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 `${}` 引用进来即可。\n\n### 3.3 定义日志文件的相关参数\n\n```xml\n<configuration>\n	<appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n		<rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n			<!-- 按照上面配置的FILE_PATH路径来保存日志 -->\n			<fileNamePattern>${FILE_PATH}</fileNamePattern>\n			<!-- 日志保存15天 -->\n			<maxHistory>15</maxHistory>\n			<timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\">\n				<!-- 单个日志文件的最大，超过则新建日志文件存储 -->\n				<maxFileSize>10MB</maxFileSize>\n			</timeBasedFileNamingAndTriggeringPolicy>\n		</rollingPolicy>\n\n		<encoder>\n			<!-- 按照上面配置的LOG_PATTERN来打印日志 -->\n			<pattern>${LOG_PATTERN}</pattern>\n		</encoder>\n	</appender>\n</configuration>\n```\n\n使用 `<appender>` 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。\n\n### 3.4 定义日志输出级别\n\n```xml\n<configuration>\n	<logger name=\"com.itcodai.course03\" level=\"INFO\" />\n	<root level=\"INFO\">\n		<appender-ref ref=\"CONSOLE\" />\n		<appender-ref ref=\"FILE\" />\n	</root>\n</configuration>\n```\n\n有了上面那些定义后，最后我们使用 `<logger>` 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 `<root>` 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。\n\n## 4. 使用Logger在项目中打印日志\n\n在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/test\")\npublic class TestController {\n\n    private final static Logger logger = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(\"/log\")\n    public String testLog() {\n        logger.debug(\"=====测试日志debug级别打印====\");\n        logger.info(\"======测试日志info级别打印=====\");\n        logger.error(\"=====测试日志error级别打印====\");\n        logger.warn(\"======测试日志warn级别打印=====\");\n\n        // 可以使用占位符打印出一些参数信息\n        String str1 = \"blog.itcodai.com\";\n        String str2 = \"blog.csdn.net/eson_15\";\n        logger.info(\"======倪升武的个人博客：{}；倪升武的CSDN博客：{}\", str1, str2);\n\n        return \"success\";\n    }\n}\n```\n\n启动该项目，在浏览器中输入 `localhost:8080/test/log` 后可以看到控制台的日志记录：\n\n> ======测试日志info级别打印=====\n> =====测试日志error级别打印====\n> ======测试日志warn级别打印=====\n> ======倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15\n\n因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\\logs\\course03\\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。\n\n## 5. 总结\n\n本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 `logback.xml` 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第04课：Spring Boot中的项目属性配置\n\n我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 `application.yml` 文件中。   \n\n## 1. 少量配置信息的情形\n\n举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：\n\n```xml\nserver:\n  port: 8001\n\n# 配置微服务的地址\nurl:\n  # 订单微服务的地址\n  orderUrl: http://localhost:8002\n```\n\n然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 `@Value` 注解来解决。在对应的类中加上一个属性，在属性上使用 `@Value` 注解即可获取到配置文件中的配置信息，如下：\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/test\")\npublic class ConfigController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class);\n\n    @Value(\"${url.orderUrl}\")\n    private String orderUrl;\n    \n    @RequestMapping(\"/config\")\n    public String testConfig() {\n        LOGGER.info(\"=====获取的订单服务地址为：{}\", orderUrl);\n        return \"success\";\n    }\n}\n```\n\n`@Value` 注解上通过 `${key}` 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 `localhost:8080/test/config` 请求服务后，可以看到控制台会打印出订单服务的地址：\n\n```\n=====获取的订单服务地址为：http://localhost:8002\n```\n\n说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。  \n\n## 2. 多个配置信息的情形\n\n这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 `@Value` 注解引入相应的微服务地址的话，太过于繁琐，也不科学。\n\n所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：\n\n```xml\n# 配置多个微服务的地址\nurl:\n  # 订单微服务的地址\n  orderUrl: http://localhost:8002\n  # 用户微服务的地址\n  userUrl: http://localhost:8003\n  # 购物车微服务的地址\n  shoppingUrl: http://localhost:8004\n```\n\n也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 `MicroServiceUrl` 类来专门保存微服务的 url，如下：\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"url\")\npublic class MicroServiceUrl {\n\n    private String orderUrl;\n    private String userUrl;\n    private String shoppingUrl;\n    // 省去get和set方法\n}\n```\n\n细心的朋友应该可以看到，使用 `@ConfigurationProperties` 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 `@Component` 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。\n\n需要注意的是，使用 `@ConfigurationProperties` 注解需要导入它的依赖：\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-configuration-processor</artifactId>\n	<optional>true</optional>\n</dependency>\n```\n\nOK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 `@Resource` 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：\n\n```java\n@RestController\n@RequestMapping(\"/test\")\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @Resource\n    private MicroServiceUrl microServiceUrl;\n    \n    @RequestMapping(\"/config\")\n    public String testConfig() {\n        LOGGER.info(\"=====获取的订单服务地址为：{}\", microServiceUrl.getOrderUrl());\n        LOGGER.info(\"=====获取的用户服务地址为：{}\", microServiceUrl.getUserUrl());\n        LOGGER.info(\"=====获取的购物车服务地址为：{}\", microServiceUrl.getShoppingUrl());\n\n        return \"success\";\n    }\n}\n```\n\n再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：\n\n```\n=====获取的订单服务地址为：http://localhost:8002\n=====获取的订单服务地址为：http://localhost:8002\n=====获取的用户服务地址为：http://localhost:8003\n=====获取的购物车服务地址为：http://localhost:8004\n```\n\n## 3. 指定项目配置文件\n\n我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。\n\n最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。\n\n我们新建两个配置文件： `application-dev.yml` 和 `application-pro.yml`，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.\n\n```xml\n# 开发环境配置文件\nserver:\n  port: 8001\n```\n\n```xml\n# 开发环境配置文件\nserver:\n  port: 8002\n```\n\n然后在 `application.yml` 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 `applicationn-dev.yml` 文件，如下：\n\n```xml\nspring:\n  profiles:\n    active:\n    - dev\n```\n\n这样就可以在开发的时候，指定读取  `application-dev.yml` 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 `application.yml` 中指定的文件改成 `application-pro.yml` 即可，然后使用 8002 端口访问，非常方便。\n\n## 4. 总结\n\n本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第05课：Spring Boot中的MVC支持\n\nSpring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 `@RestController`、 `@RequestMapping`、`@PathVariable`、`@RequestParam` 以及 `@RequestBody`。主要介绍这几个注解常用的使用方式和特点。  \n\n## 1. @RestController\n\n`@RestController` 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n\n可以看出， `@RestController` 注解包含了原来的 `@Controller` 和 `@ResponseBody` 注解，使用过 Spring 的朋友对 `@Controller` 注解已经非常了解了，这里不再赘述， `@ResponseBody` 注解是将返回的数据结构转换为 Json 格式。所以 `@RestController` 可以看作是 `@Controller` 和 `@ResponseBody` 的结合体，相当于偷个懒，我们使用 `@RestController` 之后就不用再使用 `@Controller` 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用`@RestController` 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用`@RestController`了，比如：\n\n```java\npublic String getUser() {\n	return \"user\";\n}\n```\n\n其实是需要返回到 user.html 页面的，如果使用 `@RestController` 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 `@Controller` 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。\n\n\n## 2. @RequestMapping\n\n`@RequestMapping` 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。\n\n该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。\n\n* value 属性：指定请求的实际地址，value 可以省略不写\n* method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET\n* produces属性：指定返回内容类型，如 produces = \"application/json; charset=UTF-8\"\n\n`@RequestMapping` 注解比较简单，举个例子：\n\n```java\n@RestController\n@RequestMapping(value = \"/test\", produces = \"application/json; charset=UTF-8\")\npublic class TestController {\n\n    @RequestMapping(value = \"/get\", method = RequestMethod.GET)\n    public String testGet() {\n        return \"success\";\n    }\n}\n```\n\n这个很简单，启动项目在浏览器中输入 `localhost:8080/test/get` 测试一下即可。\n\n针对四种不同的请求方式，是有相应注解的，不用每次在 `@RequestMapping` 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 `@GetMapping(\"/get\")` 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 `@PutMapping`、`@PostMapping` 和 `DeleteMapping`。\n\n## 3. @PathVariable\n\n`@PathVariable` 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 `@PathVariable` 注解。如下：\n\n```java\n@GetMapping(\"/user/{id}\")\npublic String testPathVariable(@PathVariable Integer id) {\n	System.out.println(\"获取到的id为：\" + id);\n	return \"success\";\n}\n```\n\n这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 `@PathVariable` 中的 value 属性来指定对应关系。如下：\n\n```java\n@RequestMapping(\"/user/{idd}\")\npublic String testPathVariable(@PathVariable(value = \"idd\") Integer id) {\n	System.out.println(\"获取到的id为：\" + id);\n	return \"success\";\n}\n```\n\n对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：`/xxx/{id}/user`。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：\n\n```java\n@GetMapping(\"/user/{idd}/{name}\")\n    public String testPathVariable(@PathVariable(value = \"idd\") Integer id, @PathVariable String name) {\n        System.out.println(\"获取到的id为：\" + id);\n        System.out.println(\"获取到的name为：\" + name);\n        return \"success\";\n    }\n```\n\n运行项目，在浏览器中请求 `localhost:8080/test/user/2/zhangsan` 可以看到控制台输出如下信息：\n\n```\n获取到的id为：2\n获取到的name为：zhangsan\n```\n\n所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。\n\n\n## 4. @RequestParam\n\n`@RequestParam` 注解顾名思义，也是获取请求参数的，上面我们介绍了 `@PathValiable` 注解也是获取请求参数的，那么 `@RequestParam` 和 `@PathVariable` 有什么不同呢？主要区别在于： `@PathValiable` 是从 url 模板中获取参数值， 即这种风格的 url：`http://localhost:8080/user/{id}` ；而 `@RequestParam` 是从 request 里面获取参数值，即这种风格的 url：`http://localhost:8080/user?id=1`  。我们使用该 url 带上参数 id 来测试一下如下代码：\n\n```java\n@GetMapping(\"/user\")\npublic String testRequestParam(@RequestParam Integer id) {\n	System.out.println(\"获取到的id为：\" + id);\n	return \"success\";\n}\n```\n\n可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：`http://localhost:8080/user?idd=1`\n\n```java\n@RequestMapping(\"/user\")\npublic String testRequestParam(@RequestParam(value = \"idd\", required = false) Integer id) {\n	System.out.println(\"获取到的id为：\" + id);\n	return \"success\";\n}\n```\n\n除了 value 属性外，还有个两个属性比较常用：\n\n* required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。\n* defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。\n\n从 url 中可以看出，`@RequestParam` 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 `@RequestParam` 来接收，用法和上面一样。\n\n```java\n@PostMapping(\"/form1\")\n    public String testForm(@RequestParam String username, @RequestParam String password) {\n        System.out.println(\"获取到的username为：\" + username);\n        System.out.println(\"获取到的password为：\" + password);\n        return \"success\";\n    }\n```\n\n我们使用 postman 来模拟一下表单提交，测试一下接口：\n\n![使用postman测试表单提交](https://img-blog.csdnimg.cn/20200215043749282.png)\n\n那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 `@RequestParam` 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。\n\n```java\npublic class User {\n	private String username;\n	private String password;\n	// set get\n}\n```\n\n使用实体接收的话，我们不能在前面加 `@RequestParam` 注解了，直接使用即可。\n\n```java\n@PostMapping(\"/form2\")\n    public String testForm(User user) {\n        System.out.println(\"获取到的username为：\" + user.getUsername());\n        System.out.println(\"获取到的password为：\" + user.getPassword());\n        return \"success\";\n    }\n```\n\n使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。\n\n\n## 5. @RequestBody\n\n`@RequestBody` 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 `@RequestBody` 接收会非常方便。例如：\n\n```java\npublic class User {\n	private String username;\n	private String password;\n	// set get\n}\n```\n\n```java\n@PostMapping(\"/user\")\npublic String testRequestBody(@RequestBody User user) {\n	System.out.println(\"获取到的username为：\" + user.getUsername());\n	System.out.println(\"获取到的password为：\" + user.getPassword());\n	return \"success\";\n}\n```\n\n我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。\n\n![使用Postman测试requestBody](https://img-blog.csdnimg.cn/20200215043853532.png)\n\n同时看一下后台控制台输出的日志：\n\n```\n获取到的username为：倪升武\n获取到的password为：123456\n```\n\n可以看出，`@RequestBody` 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。\n\n## 6. 总结\n\n本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 `@RestController`、 `@RequestMapping`、`@PathVariable`、 `@RequestParam` 和 `@RequestBody` 四个注解的使用方式，由于 `@RestController` 中集成了 `@ResponseBody` 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第06课：Spring Boot集成 Swagger2 展现在线接口文档\n\n## 1. Swagger 简介\n\n### 1.1 解决的问题\n\n随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。\n\n那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。\n\n### 1.2 Swagger 官方\n\n我们打开 [Swagger 官网](https://swagger.io/)，官方对 Swagger 的定义为：\n\n> The Best APIs are Built with Swagger Tools \n\n翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：\n\n![官方对swagger的定位](https://img-blog.csdnimg.cn/20200215043936444.png)\n\n本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。\n\n\n## 2. Swagger2 的 maven 依赖\n\n使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：\n\n```xml\n<dependency>\n	<groupId>io.springfox</groupId>\n	<artifactId>springfox-swagger2</artifactId>\n	<version>2.2.2</version>\n</dependency>\n<dependency>\n	<groupId>io.springfox</groupId>\n	<artifactId>springfox-swagger-ui</artifactId>\n	<version>2.2.2</version>\n</dependency>\n```\n\n## 3. Swagger2 的配置\n\n使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 `@Configuration` 注解外，还需要添加 `@EnableSwagger2` 注解。\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n * @author shengwu ni\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                // 指定构建api文档的详细信息的方法：apiInfo()\n                .apiInfo(apiInfo())\n                .select()\n                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口\n                .apis(RequestHandlerSelectors.basePackage(\"com.itcodai.course06.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 构建api文档的详细信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                // 设置页面标题\n                .title(\"Spring Boot集成Swagger2接口总览\")\n                // 设置接口描述\n                .description(\"跟武哥一起学Spring Boot第06课\")\n                // 设置联系方式\n                .contact(\"倪升武，\" + \"CSDN：http://blog.csdn.net/eson_15\")\n                // 设置版本\n                .version(\"1.0\")\n                // 构建\n                .build();\n    }\n}\n```\n\n在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 `localhost:8080/swagger-ui.html`，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。\n\n![swagger2页面](https://img-blog.csdnimg.cn/20200215044013383.png)\n\n结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。\n\n【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。\n\n![错误页面-倪升武的博客-图2](http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png)\n\n## 4. Swagger2 的使用\n\n上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。\n\n### 4.1 实体类注解\n\n本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 `@ApiModel` 和 `@ApiModelProperty` 注解，同时为后面的测试做准备。\n\n```java\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\n\n@ApiModel(value = \"用户实体类\")\npublic class User {\n\n    @ApiModelProperty(value = \"用户唯一标识\")\n    private Long id;\n\n    @ApiModelProperty(value = \"用户姓名\")\n    private String username;\n\n    @ApiModelProperty(value = \"用户密码\")\n    private String password;\n\n	// 省略set和get方法\n}\n```\n\n解释下 `@ApiModel` 和 `@ApiModelProperty` 注解：\n\n> `@ApiModel` 注解用于实体类，表示对类进行说明，用于参数用实体类接收。\n> `@ApiModelProperty` 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。\n\n该注解在在线 API 文档中的具体效果在下文说明。\n\n### 4.2 Controller 类中相关注解\n\n我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。\n\n```java\nimport com.itcodai.course06.entiy.JsonResult;\nimport com.itcodai.course06.entiy.User;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/swagger\")\n@Api(value = \"Swagger2 在线接口文档\")\npublic class TestController {\n\n    @GetMapping(\"/get/{id}\")\n    @ApiOperation(value = \"根据用户唯一标识获取用户信息\")\n    public JsonResult<User> getUserInfo(@PathVariable @ApiParam(value = \"用户唯一标识\") Long id) {\n        // 模拟数据库中根据id获取User信息\n        User user = new User(id, \"倪升武\", \"123456\");\n        return new JsonResult(user);\n    }\n}\n```\n\n我们来学习一下 `@Api` 、 `@ApiOperation` 和 `@ApiParam` 注解。\n\n> `@Api` 注解用于类上，表示标识这个类是 swagger 的资源。\n> `@ApiOperation` 注解用于方法，表示一个 http 请求的操作。\n> `@ApiParam` 注解用于参数上，用来标明参数信息。\n\n这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 `localhost:8080/swagger-ui.html` 看一下 Swagger 页面的接口状态。\n\n![swagger接口展示](https://img-blog.csdnimg.cn/20200215044156305.png)\n\n可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：\n\n![返回数据测试](https://img-blog.csdnimg.cn/20200215044226292.png)\n\n可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。\n\n```java\n@PostMapping(\"/insert\")\n    @ApiOperation(value = \"添加用户信息\")\n    public JsonResult<Void> insertUser(@RequestBody @ApiParam(value = \"用户信息\") User user) {\n        // 处理添加逻辑\n        return new JsonResult<>();\n    }\n```\n\n重启项目，在浏览器中输入 `localhost:8080/swagger-ui.html` 看一下效果：\n\n![swagger接口展示](https://img-blog.csdnimg.cn/20200215044256579.png)\n\n## 5. 总结\n\nOK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第07课：Spring Boot集成Thymeleaf模板引擎\n\n## 1. Thymeleaf 介绍\n\n> Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。  \n> Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。  \n\n以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。   \n\n什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：\n\n```html\n<div class=\"ui right aligned basic segment\">\n      <div class=\"ui orange basic label\" th:text=\"${blog.flag}\">静态原创信息</div>\n</div>\n<h2 class=\"ui center aligned header\" th:text=\"${blog.title}\">这是静态标题</h2>\n```\n\n类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，`th:text` 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 `th:text`），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。 \n\n## 2. 依赖导入\n\n在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：\n\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n## 3. Thymeleaf相关配置\n\n因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。\n\n```yml\nspring:\n  thymeleaf:\n    cache: false #关闭缓存\n```\n\n否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。\n\n## 4. Thymeleaf 的使用\n\n### 4.1 访问静态页面\n\n这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    这是404页面\n</body>\n</html>\n```\n\n我们再写一个 controller 来测试一下 404 和 500 页面：\n\n```java\n@Controller\n@RequestMapping(\"/thymeleaf\")\npublic class ThymeleafController {\n\n    @RequestMapping(\"/test404\")\n    public String test404() {\n        return \"index\";\n    }\n\n    @RequestMapping(\"/test500\")\n    public String test500() {\n        int i = 1 / 0;\n        return \"index\";\n    }\n}\n```\n\n> 当我们在浏览器中输入 `localhost:8080/thymeleaf/test400` 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。   \n> 当我们在浏览器中输入 `localhost:8088/thymeleaf/test505` 时，会抛出异常，然后会自动跳转到 500.html 显示。\n\n【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 `@RestController` 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 `@RestController` 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 `@RestController` 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 `@Controller` 注解。\n\n### 4.2 Thymeleaf 中处理对象\n\n我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：\n\n```java\npublic class Blogger {\n    private Long id;\n    private String name;\n    private String pass;\n	// 省去set和get\n}\n```\n\n然后在controller层中初始化一下：\n\n```java\n@GetMapping(\"/getBlogger\")\npublic String getBlogger(Model model) {\n	Blogger blogger = new Blogger(1L, \"倪升武\", \"123456\");\n	model.addAttribute(\"blogger\", blogger);\n	return \"blogger\";\n}\n```\n\n我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>博主信息</title>\n</head>\n<body>\n<form action=\"\" th:object=\"${blogger}\" >\n    用户编号：<input name=\"id\" th:value=\"${blogger.id}\"/><br>\n    用户姓名：<input type=\"text\" name=\"username\" th:value=\"${blogger.getName()}\" /><br>\n    登陆密码：<input type=\"text\" name=\"password\" th:value=\"*{pass}\" />\n</form>\n</body>\n</html>\n```\n\n可以看出，在 thymeleaf 模板中，使用 `th:object=\"${}\"` 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：\n\n> 使用 `th:value=\"*{属性名}\"`\n> 使用 `th:value=\"${对象.属性名}\"`，对象指的是上面使用 `th:object` 获取的对象\n> 使用 `th:value=\"${对象.get方法}\"`，对象指的是上面使用 `th:object` 获取的对象\n\n可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 `localhost:8080/thymeleaf/getBlogger` 来测试一下数据：\n\n![thymeleaf中处理对象](https://img-blog.csdnimg.cn/20200215044353803.jpg)\n\n### 4.3 Thymeleaf 中处理 List\n\n处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。\n\n```java\n@GetMapping(\"/getList\")\npublic String getList(Model model) {\n    Blogger blogger1 = new Blogger(1L, \"倪升武\", \"123456\");\n    Blogger blogger2 = new Blogger(2L, \"达人课\", \"123456\");\n    List<Blogger> list = new ArrayList<>();\n    list.add(blogger1);\n    list.add(blogger2);\n    model.addAttribute(\"list\", list);\n    return \"list\";\n}\n```\n\n接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>博主信息</title>\n</head>\n<body>\n<form action=\"\" th:each=\"blogger : ${list}\" >\n    用户编号：<input name=\"id\" th:value=\"${blogger.id}\"/><br>\n    用户姓名：<input type=\"text\" name=\"password\" th:value=\"${blogger.name}\"/><br>\n    登录密码：<input type=\"text\" name=\"username\" th:value=\"${blogger.getPass()}\"/>\n</form>\n</body>\n</html>\n```\n\n可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 `th:each` 进行遍历，`${}` 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 `${对象.属性名}` 来获取 list 中对象的属性值，也可以使用 `${对象.get方法}` 来获取，这点和上面处理对象信息是一样的，但是不能使用 `*{属性名}` 来获取对象中的属性，thymeleaf 模板获取不到。    \n\n### 4.4 其他常用 thymeleaf 操作\n\n我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：\n\n| 标签         | 功能                  | 例子                                                         |\n| ------------ | --------------------- | ------------------------------------------------------------ |\n| `th:value`   | 给属性赋值            | `<input th:value=\"${blog.name}\" /> `                         |\n| `th:style`   | 设置样式              | `th:style=\"\'display:\'+@{(${sitrue}?\'none\':\'inline-block\')} + \'\'\"` |\n| `th:onclick` | 点击事件              | `th:onclick=\"\'getInfo()\'\"`                                   |\n| `th:if`      | 条件判断              | `<a th:if=\"${userId == collect.userId}\" >`                   |\n| `th:href`    | 超链接                | `<a th:href=\"@{/blogger/login}\">Login</a> />`                |\n| `th:unless`  | 条件判断和`th:if`相反 | `<a th:href=\"@{/blogger/login}\" th:unless=${session.user != null}>Login</a>` |\n| `th:switch`  | 配合`th:case`         | `<div th:switch=\"${user.role}\">`                             |\n| `th:case`    | 配合`th:switch`       | `<p th:case=\"\'admin\'\">administator</p>`                      |\n| `th:src`     | 地址引入              | `<img alt=\"csdn logo\" th:src=\"@{/img/logo.png}\" />`          |\n| `th:action`  | 表单提交的地址        | `<form th:action=\"@{/blogger/update}\">`                      |\n\nThymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的[官方文档（v3.0）](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。\n\n## 5. 总结\n\nThymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第08课：Spring Boot中的全局异常处理\n\n\n在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。   \n针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。\n\n## 1. 定义返回的统一 json 结构\n\n前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。   \n这个统一的 json 结构这可以参考[第02课：Spring Boot 返回 JSON 数据及数据封装](https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a)中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：\n\n```java\npublic class JsonResult {\n    /**\n     * 异常码\n     */\n    protected String code;\n\n    /**\n     * 异常信息\n     */\n    protected String msg;\n	\n    public JsonResult() {\n        this.code = \"200\";\n        this.msg = \"操作成功\";\n    }\n    \n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n	// get set\n}\n```\n\n## 2. 处理系统异常\n\n新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 `@ControllerAdvice` 注解即可拦截项目中抛出的异常，如下：\n\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n	// 打印log\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    // ……\n}\n```\n\n我们点开 `@ControllerAdvice` 注解可以看到，`@ControllerAdvice` 注解包含了 `@Component` 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 `basePackages` 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。`@ResponseBody` 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。  \n在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 `@ExceptionHandler` 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。\n\n### 2.1 处理参数缺失异常\n\n在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。  \n\n参数缺失的时候，会抛出 `HttpMessageNotReadableException`，我们可以拦截该异常，做一个友好处理，如下：\n\n```java\n/**\n* 缺少请求参数异常\n* @param ex HttpMessageNotReadableException\n* @return\n*/\n@ExceptionHandler(MissingServletRequestParameterException.class)\n@ResponseStatus(value = HttpStatus.BAD_REQUEST)\npublic JsonResult handleHttpMessageNotReadableException(\n    MissingServletRequestParameterException ex) {\n    logger.error(\"缺少请求参数，{}\", ex.getMessage());\n    return new JsonResult(\"400\", \"缺少必要的请求参数\");\n}\n```\n\n我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。\n\n```java\n@RestController\n@RequestMapping(\"/exception\")\npublic class ExceptionController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);\n\n    @PostMapping(\"/test\")\n    public JsonResult test(@RequestParam(\"name\") String name,\n                           @RequestParam(\"pass\") String pass) {\n        logger.info(\"name：{}\", name);\n        logger.info(\"pass：{}\", pass);\n        return new JsonResult();\n    }\n}\n```\n\n然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：\n\n![缺失参数异常](https://img-blog.csdnimg.cn/2020021504443480.png)\n\n\n### 2.2 处理空指针异常\n\n空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？  \n先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。  \n还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。  \n对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：\n\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(\"空指针异常，{}\", ex.getMessage());\n        return new JsonResult(\"500\", \"空指针异常了\");\n    }\n}\n```\n\n这个我就不测试了，代码中 ExceptionController 有个 `testNullPointException` 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：\n\n```json\n{\"code\":\"500\",\"msg\":\"空指针异常了\"}\n```\n\n### 2.3 一劳永逸？\n\n当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：\n\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(\"系统异常：\", ex);\n        return new JsonResult(\"500\", \"系统发生异常，请联系管理员\");\n    }\n}\n```\n\n但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。\n\n## 3. 拦截自定义异常\n\n在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。\n\n### 3.1 定义异常信息\n\n由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：\n\n```java\n/**\n * 业务异常提示信息枚举类\n * @author shengwu ni\n */\npublic enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(\"102\", \"参数异常!\"),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"),\n    /** 500 : 一劳永逸的提示也可以在这定义 */\n    UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\");\n    // 还可以定义更多的业务异常\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n	// set get方法\n}\n```\n\n### 3.2 拦截自定义异常\n\n然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：\n\n```java\n/**\n * 自定义业务异常\n * @author shengwu ni\n */\npublic class BusinessErrorException extends RuntimeException {\n    \n    private static final long serialVersionUID = -7480022450501760611L;\n\n    /**\n     * 异常码\n     */\n    private String code;\n    /**\n     * 异常提示信息\n     */\n    private String message;\n\n    public BusinessErrorException(BusinessMsgEnum businessMsgEnum) {\n        this.code = businessMsgEnum.code();\n        this.message = businessMsgEnum.msg();\n    }\n	// get set方法\n}\n```\n\n在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。\n\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n}\n```\n\n在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：\n\n```java\n@RestController\n@RequestMapping(\"/exception\")\npublic class ExceptionController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);\n\n    @GetMapping(\"/business\")\n    public JsonResult testException() {\n        try {\n            int i = 1 / 0;\n        } catch (Exception e) {\n            throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n        }\n        return new JsonResult();\n    }\n}\n```\n\n运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：\n\n```json\n{\"code\":\"500\",\"msg\":\"系统发生异常，请联系管理员！\"}\n```\n\n## 4. 总结\n\n本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第09课：Spring Boot中的切面AOP处理\n\n## 1. 什么是AOP\n\nAOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？  \n\n对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！  \n\n这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。\n\n## 2. Spring Boot 中的 AOP 处理\n\n### 2.1 AOP 依赖\n\n使用AOP，首先需要引入AOP的依赖。\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### 2.2 实现 AOP 切面\n\nSpring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个`@Aspect`注解即可。`@Aspect` 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。`@Component` 注解让该类交给 Spring 来管理。\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n}\n```\n\n这里主要介绍几个常用的注解及使用：\n\n> 1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。  \n> 2.@Before：在做某件事之前做的事。  \n> 3.@After：在做某件事之后做的事。  \n> 4.@AfterReturning：在做某件事之后，对其返回值做增强处理。  \n> 5.@AfterThrowing：在做某件事抛出异常时，处理。\n\n#### 2.2.1 @Pointcut 注解\n\n`@Pointcut` 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    /**\n     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法\n     */\n    @Pointcut(\"execution(* com.itcodai.course09.controller..*.*(..))\")\n    public void pointCut() {}\n}\n```\n\n`@Pointcut` 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 `execution()`，另一个是使用 `annotation()`。  \n以 `execution(* com.itcodai.course09.controller..*.*(..)))` 表达式为例，语法如下：\n\n> `execution()` 为表达式主体  \n> 第一个 `*` 号的位置：表示返回值类型，`*` 表示所有类型  \n> 包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，`com.itcodai.course09.controller` 包、子包下所有类的方法  \n> 第二个 `*` 号的位置：表示类名，`*` 表示所有类  \n> `*(..)` ：这个星号表示方法名，`*` 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数\n\n`annotation()` 方式是针对某个注解来定义切面，比如我们对具有`@GetMapping`注解的方法做切面，可以如下定义切面：\n\n```java\n@Pointcut(\"@annotation(org.springframework.web.bind.annotation.GetMapping)\")\npublic void annotationCut() {}\n```\n\n然后使用该切面的话，就会切入注解是 `@GetMapping` 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 `@GetMapping`、`@PostMapping`、`@DeleteMapping` 等。所以这种按照注解的切入方式在实际项目中也很常用。\n\n#### 2.2.2 @Before 注解\n\n`@Before` 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法之前执行该方法\n     * @param joinPoint jointPoint\n     */\n    @Before(\"pointCut()\")\n    public void doBefore(JoinPoint joinPoint) {\n        logger.info(\"====doBefore方法进入了====\");\n\n        // 获取签名\n        Signature signature = joinPoint.getSignature();\n        // 获取切入的包名\n        String declaringTypeName = signature.getDeclaringTypeName();\n        // 获取即将执行的方法名\n        String funcName = signature.getName();\n        logger.info(\"即将执行方法为: {}，属于{}包\", funcName, declaringTypeName);\n        \n        // 也可以用来记录一些信息，比如获取请求的url和ip\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n        // 获取请求url\n        String url = request.getRequestURL().toString();\n        // 获取请求ip\n        String ip = request.getRemoteAddr();\n        logger.info(\"用户请求的url为：{}，ip地址为：{}\", url, ip);\n    }\n}\n```\n\nJointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 `joinPoint.getArgs()` 获取）等等。\n\n#### 2.2.3 @After 注解\n\n`@After` 注解和 `@Before`  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法\n     */\n    @Pointcut(\"execution(* com.itcodai.course09.controller..*.*(..))\")\n    public void pointCut() {}\n\n    /**\n     * 在上面定义的切面方法之后执行该方法\n     * @param joinPoint jointPoint\n     */\n    @After(\"pointCut()\")\n    public void doAfter(JoinPoint joinPoint) {\n\n        logger.info(\"====doAfter方法进入了====\");\n        Signature signature = joinPoint.getSignature();\n        String method = signature.getName();\n        logger.info(\"方法{}已经执行完\", method);\n    }\n}\n```\n\n到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：\n\n```java\n@RestController\n@RequestMapping(\"/aop\")\npublic class AopController {\n\n    @GetMapping(\"/{name}\")\n    public String testAop(@PathVariable String name) {\n        return \"Hello \" + name;\n    }\n}\n```\n\n启动项目，在浏览器中输入 `localhost:8080/aop/CSDN`，观察一下控制台的输出信息：\n\n```\n====doBefore方法进入了====  \n即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  \n用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1  \n====doAfter方法进入了====  \n方法testAop已经执行完\n```\n\n从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 `@Before` 和 `@After` 两个注解的实际作用。\n\n#### 2.2.4 @AfterReturning 注解\n\n`@AfterReturning` 注解和 `@After` 有些类似，区别在于 `@AfterReturning` 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强\n     * @param joinPoint joinPoint\n     * @param result result\n     */\n    @AfterReturning(pointcut = \"pointCut()\", returning = \"result\")\n    public void doAfterReturning(JoinPoint joinPoint, Object result) {\n\n        Signature signature = joinPoint.getSignature();\n        String classMethod = signature.getName();\n        logger.info(\"方法{}执行完毕，返回参数为：{}\", classMethod, result);\n        // 实际项目中可以根据业务做具体的返回值增强\n        logger.info(\"对返回参数进行业务上的增强：{}\", result + \"增强版\");\n    }\n}\n```\n\n需要注意的是：在 `@AfterReturning`注解 中，属性 `returning` 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 `doAfterReturning` 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：\n\n```\n方法testAop执行完毕，返回参数为：Hello CSDN  \n对返回参数进行业务上的增强：Hello CSDN增强版\n```\n\n#### 2.2.5 @AfterThrowing 注解\n\n顾名思义，`@AfterThrowing` 注解是当被切方法执行时抛出异常时，会进入 `@AfterThrowing` 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 `throwing` 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。\n\n```java\n/**\n * 使用AOP处理log\n * @author shengwu ni\n * @date 2018/05/04 20:24\n */\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法执行抛异常时，执行该方法\n     * @param joinPoint jointPoint\n     * @param ex ex\n     */\n    @AfterThrowing(pointcut = \"pointCut()\", throwing = \"ex\")\n    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {\n        Signature signature = joinPoint.getSignature();\n        String method = signature.getName();\n        // 处理异常的逻辑\n        logger.info(\"执行方法{}出错，异常为：{}\", method, ex);\n    }\n}\n```\n\n该方法我就不测试了，大家可以自行测试一下。\n\n## 3. 总结\n\n本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第10课：Spring Boot集成MyBatis\n\n## 1. MyBatis 介绍\n\n大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。\n\n## 2. MyBatis 的配置\n\n## 2.1 依赖导入\n\nSpring Boot 集成 MyBatis，需要导入 `mybatis-spring-boot-starter` 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：\n\n```xml\n<dependency>\n	<groupId>org.mybatis.spring.boot</groupId>\n	<artifactId>mybatis-spring-boot-starter</artifactId>\n	<version>1.3.2</version>\n</dependency>\n<dependency>\n	<groupId>mysql</groupId>\n	<artifactId>mysql-connector-java</artifactId>\n	<scope>runtime</scope>\n</dependency>\n```\n\n我们点开 `mybatis-spring-boot-starter` 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。\n\n```xml\n<!-- 省去其他 -->\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n</dependency>\n```\n\n## 2.2 properties.yml配置\n\n我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？\n\n```xml\n# 服务端口号\nserver:\n  port: 8080\n\n# 数据库地址\ndatasource:\n  url: localhost:3306/blog_test\n\nspring:\n  datasource: # 数据库配置\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://${datasource.url}?useSSL=false&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 10 # 最大连接池数\n      max-lifetime: 1770000\n\nmybatis:\n  # 指定别名设置的包为所有entity\n  type-aliases-package: com.itcodai.course10.entity\n  configuration:\n    map-underscore-to-camel-case: true # 驼峰命名规范\n  mapper-locations: # mapper映射文件位置\n    - classpath:mapper/*.xml\n```\n\n我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。  \n\n这里说明一下 `map-underscore-to-camel-case: true`， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：`user_name`， 那么在实体类中可以定义属性为 `userName` （甚至可以写成 `username`，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。\n\n## 3. 基于 xml 的整合\n\n使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：`classpath:mapper/*.xml`，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.itcodai.course10.dao.UserMapper\">\n  <resultMap id=\"BaseResultMap\" type=\"com.itcodai.course10.entity.User\">\n\n    <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\" />\n    <result column=\"user_name\" jdbcType=\"VARCHAR\" property=\"username\" />\n    <result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\" />\n  </resultMap>\n  \n   <select id=\"getUserByName\" resultType=\"User\" parameterType=\"String\">\n       select * from user where user_name = #{username}\n  </select>\n</mapper>\n```\n\n这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， `<resultMap>` 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。  \n\n实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：\n\n```java\nUser getUserByName(String username);\n```\n\n中间省略 service 的代码，我们写一个 Controller 来测试一下：\n\n```java\n@RestController\npublic class TestController {\n\n    @Resource\n    private UserService userService;\n    \n    @RequestMapping(\"/getUserByName/{name}\")\n    public User getUserByName(@PathVariable String name) {\n        return userService.getUserByName(name);\n    }\n}\n```\n\n启动项目，在浏览器中输入：`http://localhost:8080/getUserByName/CSDN` 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：\n\n```json\n{\"id\":2,\"username\":\"CSDN\",\"password\":\"123456\"}\n```\n\n这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 `@Mapper` 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 `@Mapper` 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加`@MaperScan` 注解，来扫描一个包下的所有 mapper。如下：\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.itcodai.course10.dao\")\npublic class Course10Application {\n\n	public static void main(String[] args) {\n		SpringApplication.run(Course10Application.class, args);\n	}\n}\n```\n\n这样的话，`com.itcodai.course10.dao` 包下的所有 mapper 都会被扫描到了。\n\n## 4. 基于注解的整合\n\n基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 `@Select`， `@Insert`， `@Update`， `Delete` 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：\n\n```java\n@Select(\"select * from user where id = #{id}\")\nUser getUser(Long id);\n```\n\n这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 `@Param` 注解来指定每一个参数的对应关系，如下：\n\n```java\n@Select(\"select * from user where id = #{id} and user_name=#{name}\")\nUser getUserByIdAndName(@Param(\"id\") Long id, @Param(\"name\") String username);\n```\n\n可以看出，`@Param` 指定的参数应该要和 sql 中 `#{}` 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。  \n\n有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 `@Results` 注解来解决。\n\n```java\n@Select(\"select * from user where id = #{id}\")\n@Results({\n        @Result(property = \"username\", column = \"user_name\"),\n        @Result(property = \"password\", column = \"password\")\n})\nUser getUser(Long id);\n```\n\n`@Results` 中的 `@Result` 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。  \n\n当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 `@ResultMap` 注解来替代 `@Results` 注解，如下：\n\n```java\n@Select(\"select * from user where id = #{id}\")\n@ResultMap(\"BaseResultMap\")\nUser getUser(Long id);\n```\n\n`@ResultMap` 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 `<resultMap>` 时对应的 id 值：\n\n```xml\n<resultMap id=\"BaseResultMap\" type=\"com.itcodai.course10.entity.User\">\n```\n\n这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。\n\n## 5. 总结\n\n本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第11课：Spring Boot事务配置管理\n\n## 1. 事务相关\n\n场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。  \n\n事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。\n\n事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。\n\n## 2. Spring Boot 事务配置\n\n### 2.1 依赖导入\n\n在 Spring Boot 中使用事务，需要导入 mysql 依赖：\n\n```xml\n<dependency>\n	<groupId>org.mybatis.spring.boot</groupId>\n	<artifactId>mybatis-spring-boot-starter</artifactId>\n	<version>1.3.2</version>\n</dependency>\n```\n\n导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 `@Transactional` 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。  \n\n### 2.2 事务的测试\n\n我们首先在数据库表中插入一条数据：\n\n|  id  | user_name | password |\n| :--: | :-------: | :------: |\n|  1   |  倪升武   |  123456  |\n\n然后我们写一个插入的 mapper：\n\n```java\npublic interface UserMapper {\n\n    @Insert(\"insert into user (user_name, password) values (#{username}, #{password})\")\n    Integer insertUser(User user);\n}\n```\n\nOK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。\n\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional\n    public void isertUser(User user) {\n        // 插入用户信息\n        userMapper.insertUser(user);\n        // 手动抛出异常\n        throw new RuntimeException();\n    }\n}\n```\n\n我们来测试一下：\n\n```java\n@RestController\npublic class TestController {\n\n    @Resource\n    private UserService userService;\n\n    @PostMapping(\"/adduser\")\n    public String addUser(@RequestBody User user) throws Exception {\n        if (null != user) {\n            userService.isertUser(user);\n            return \"success\";\n        } else {\n            return \"false\";\n        }\n    }\n}\n```\n\n我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……\n\n\n## 3. 常见问题总结\n\n从上面的内容中可以看出，Spring Boot 中使用事务非常简单，`@Transactional` 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。  \n\n这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。\n\n### 3.1 异常并没有被 ”捕获“ 到\n\n首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：\n\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n    \n    @Override\n    @Transactional\n    public void isertUser2(User user) throws Exception {\n        // 插入用户信息\n        userMapper.insertUser(user);\n        // 手动抛出异常\n        throw new SQLException(\"数据库异常\");\n    }\n}\n```\n\n我们看上面这个代码，其实并没有什么问题，手动抛出一个 `SQLException` 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。  \n\n那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 `@Transactional` 注解中使用 `rollbackFor` 属性来指定异常，比如 `@Transactional(rollbackFor = Exception.class)`，这样就没有问题了，所以在实际项目中，一定要指定异常。\n\n### 3.2 异常被 ”吃“ 掉\n\n这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try...catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：\n\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void isertUser3(User user) {\n        try {\n            // 插入用户信息\n            userMapper.insertUser(user);\n            // 手动抛出异常\n            throw new SQLException(\"数据库异常\");\n        } catch (Exception e) {\n			// 异常处理逻辑\n        }\n    }\n}\n```\n\n读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try...catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。  \n\n那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。\n\n### 3.3 事务的范围\n\n事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。  \n\n我来写个 demo：\n\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public synchronized void isertUser4(User user) {\n        // 实际中的具体业务……\n        userMapper.insertUser(user);\n    }\n}\n```\n\n可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。  \n\n但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。  \n\n从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。  \n\n这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。\n\n## 4. 总结\n\n本章主要总结了 Spring Boot 中如何使用事务，只要使用 `@Transactional` 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。\n\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第12课：Spring Boot中使用监听器\n\n## 1. 监听器介绍\n\n什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。\n\n## 2. Spring Boot中监听器的使用\n\nweb 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。\n\n### 2.1 监听Servlet上下文对象\n\n监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。  \n\n针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。\n\n下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：\n\n```java\n@Service\npublic class UserService {\n\n    /**\n     * 获取用户信息\n     * @return\n     */\n    public User getUser() {\n        // 实际中会根据具体的业务场景，从数据库中查询对应的信息\n        return new User(1L, \"倪升武\", \"123456\");\n    }\n}\n```\n\n然后写一个监听器，实现 `ApplicationListener<ContextRefreshedEvent>` 接口，重写 `onApplicationEvent` 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：\n\n```java\n/**\n * 使用ApplicationListener来初始化一些数据到application域中的监听器\n * @author shengni ni\n * @date 2018/07/05\n */\n@Component\npublic class MyServletContextListener implements ApplicationListener<ContextRefreshedEvent> {\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {\n        // 先获取到application上下文\n        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();\n        // 获取对应的service\n        UserService userService = applicationContext.getBean(UserService.class);\n        User user = userService.getUser();\n        // 获取application域对象，将查到的信息放到application域中\n        ServletContext application = applicationContext.getBean(ServletContext.class);\n        application.setAttribute(\"user\", user);\n    }\n}\n```\n\n正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。\n\n```java\n@RestController\n@RequestMapping(\"/listener\")\npublic class TestController {\n\n    @GetMapping(\"/user\")\n    public User getUser(HttpServletRequest request) {\n        ServletContext application = request.getServletContext();\n        return (User) application.getAttribute(\"user\");\n    }\n}\n```\n\n启动项目，在浏览器中输入 `http://localhost:8080/listener/user` 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。\n\n### 2.2 监听HTTP会话 Session对象\n\n监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。\n\n```java\n/**\n * 使用HttpSessionListener统计在线用户数的监听器\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyHttpSessionListener implements HttpSessionListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class);\n\n    /**\n     * 记录在线的用户数量\n     */\n    public Integer count = 0;\n\n    @Override\n    public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) {\n        logger.info(\"新用户上线了\");\n        count++;\n        httpSessionEvent.getSession().getServletContext().setAttribute(\"count\", count);\n    }\n\n    @Override\n    public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) {\n        logger.info(\"用户下线了\");\n        count--;\n        httpSessionEvent.getSession().getServletContext().setAttribute(\"count\", count);\n    }\n}\n```\n\n可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 `sessionCreated` 和 `sessionDestroyed` 方法，在 `sessionCreated` 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，`sessionDestroyed` 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。\n\n```java\n@RestController\n@RequestMapping(\"/listener\")\npublic class TestController {\n\n    /**\n     * 获取当前在线人数，该方法有bug\n     * @param request\n     * @return\n     */\n    @GetMapping(\"/total\")\n    public String getTotalUser(HttpServletRequest request) {\n        Integer count = (Integer) request.getSession().getServletContext().getAttribute(\"count\");\n        return \"当前在线人数：\" + count;\n    }\n}\n```\n\n该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 `localhost:8080/listener/total` 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：\n\n```java\n@GetMapping(\"/total2\")\npublic String getTotalUser(HttpServletRequest request, HttpServletResponse response) {\n    Cookie cookie;\n    try {\n        // 把sessionId记录在浏览器中\n        cookie = new Cookie(\"JSESSIONID\", URLEncoder.encode(request.getSession().getId(), \"utf-8\"));\n        cookie.setPath(\"/\");\n        //设置cookie有效期为2天，设置长一点\n        cookie.setMaxAge( 48*60 * 60);\n        response.addCookie(cookie);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n    Integer count = (Integer) request.getSession().getServletContext().getAttribute(\"count\");\n    return \"当前在线人数：\" + count;\n}\n```\n\n可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。\n\n### 2.3 监听客户端请求Servlet Request对象\n\n使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：\n\n```java\n/**\n * 使用ServletRequestListener获取访问信息\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyServletRequestListener implements ServletRequestListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class);\n\n    @Override\n    public void requestInitialized(ServletRequestEvent servletRequestEvent) {\n        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();\n        logger.info(\"session id为：{}\", request.getRequestedSessionId());\n        logger.info(\"request url为：{}\", request.getRequestURL());\n\n        request.setAttribute(\"name\", \"倪升武\");\n    }\n\n    @Override\n    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {\n\n        logger.info(\"request end\");\n        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();\n        logger.info(\"request域中保存的name值为：{}\", request.getAttribute(\"name\"));\n\n    }\n\n}\n```\n\n这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。\n\n```java\n@GetMapping(\"/request\")\npublic String getRequestInfo(HttpServletRequest request) {\n    System.out.println(\"requestListener中的初始化的name数据：\" + request.getAttribute(\"name\"));\n    return \"success\";\n}\n```\n\n## 3. Spring Boot中自定义事件监听\n\n在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。\n\n### 3.1 自定义事件\n\n自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：\n\n```java\n/**\n * 自定义事件\n * @author shengwu ni\n * @date 2018/07/05\n */\npublic class MyEvent extends ApplicationEvent {\n\n    private User user;\n\n    public MyEvent(Object source, User user) {\n        super(source);\n        this.user = user;\n    }\n\n    // 省去get、set方法\n}\n```\n\n### 3.2 自定义监听器\n\n接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 `ApplicationListener` 接口即可。如下：\n\n```java\n/**\n * 自定义监听器，监听MyEvent事件\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyEventListener implements ApplicationListener<MyEvent> {\n    @Override\n    public void onApplicationEvent(MyEvent myEvent) {\n        // 把事件中的信息获取到\n        User user = myEvent.getUser();\n        // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等\n        System.out.println(\"用户名：\" + user.getUsername());\n        System.out.println(\"密码：\" + user.getPassword());\n\n    }\n}\n```\n\n然后重写 `onApplicationEvent` 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。\n\nOK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：\n\n```java\n/**\n * UserService\n * @author shengwu ni\n */\n@Service\npublic class UserService {\n\n    @Resource\n    private ApplicationContext applicationContext;\n\n    /**\n     * 发布事件\n     * @return\n     */\n    public User getUser2() {\n        User user = new User(1L, \"倪升武\", \"123456\");\n        // 发布事件\n        MyEvent event = new MyEvent(this, user);\n        applicationContext.publishEvent(event);\n        return user;\n    }\n}\n```\n\n在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。\n\n最后，在 Controller 中写一个接口来测试一下：\n\n```java\n@GetMapping(\"/request\")\npublic String getRequestInfo(HttpServletRequest request) {\n    System.out.println(\"requestListener中的初始化的name数据：\" + request.getAttribute(\"name\"));\n    return \"success\";\n}\n```\n\n在浏览器中输入 `http://localhost:8080/listener/publish`，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。\n\n## 4. 总结\n\n本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第13课：Spring Boot中使用拦截器\n\n拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。\n\n## 1. 拦截器的快速使用\n\n使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。\n\n### 1.1 定义拦截器\n\n定义拦截器，只需要实现 `HandlerInterceptor` 接口，`HandlerInterceptor` 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： `preHandle(……)`、`postHandle(……)` 和 `afterCompletion(……)` 。\n\n> `preHandle(……)` 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 `preHandle(……)` 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。  \n> `postHandle(……)` 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。  \n> `afterCompletion(……)` 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 `preHandle(……)` 被成功执行后并且返回 true 才会被执行。  \n\n了解了该接口，接下来自定义一个拦截器。\n\n```java\n/**\n * 自定义拦截器\n * @author shengwu ni\n * @date 2018/08/03\n */\npublic class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\n        Method method = handlerMethod.getMethod();\n        String methodName = method.getName();\n        logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName);\n        // 返回true才会继续执行，返回false则取消当前请求\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\");\n    }\n}\n```\n\nOK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。\n\n### 1.2 配置拦截器\n\n在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 `addInterceptors` 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：\n\n```java\n@Configuration\npublic class MyInterceptorConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n        super.addInterceptors(registry);\n    }\n}\n```\n\n在该配置中重写 `addInterceptors` 方法，将我们上面自定义的拦截器添加进去，`addPathPatterns` 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：\n\n```java\n@Controller\n@RequestMapping(\"/interceptor\")\npublic class InterceptorController {\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        return \"hello\";\n    }\n}\n```\n\n让其跳转到 hello.html 页面，直接在 hello.html 中输出 `hello interceptor` 即可。启动项目，在浏览器中输入 `localhost:8080/interceptor/test` 看一下控制台的日志：\n\n```\n====拦截到了方法：test，在该方法执行之前执行====  \n执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  \n整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\n```\n\n可以看出拦截器已经生效，并能看出其执行顺序。\n\n### 1.3 解决静态资源被拦截问题\n\n上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。\n\n也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。\n\n如何放开呢？除了在 MyInterceptorConfig 配置类中重写 `addInterceptors` 方法外，还需要再重写一个方法：`addResourceHandlers`，将静态资源放开：\n\n```java\n/**\n * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问\n * @param registry\n */\n@Override\nprotected void addResourceHandlers(ResourceHandlerRegistry registry) {\n    registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\");\n    super.addResourceHandlers(registry);\n}\n```\n\n这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。\n\n我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 `addInterceptors` 方法，将自定义的拦截器添加进去即可，如下：\n\n```java\n@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\n这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。\n\n这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。\n\n## 2. 拦截器使用实例\n\n### 2.1 判断用户有没有登录\n\n一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 `preHandle` 方法，如下：\n\n```java\n@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n    HandlerMethod handlerMethod = (HandlerMethod) handler;\n    Method method = handlerMethod.getMethod();\n    String methodName = method.getName();\n    logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName);\n\n    // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token\n    String token = request.getParameter(\"token\");\n    if (null == token || \"\".equals(token)) {\n        logger.info(\"用户未登录，没有权限执行……请登录\");\n        return false;\n    }\n\n    // 返回true才会继续执行，返回false则取消当前请求\n    return true;\n}\n```\n\n重启项目，在浏览器中输入 `localhost:8080/interceptor/test` 后查看控制台日志，发现被拦截，如果在浏览器中输入 `localhost:8080/interceptor/test?token=123` 即可正常往下走。\n\n### 2.2 取消拦截操作\n\n根据上文，如果我要拦截所有 `/admin` 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 `/admin` 开头的，但是不能拦截，比如 `/admin/login` 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？\n\n是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：\n\n```java\n/**\n * 该注解用来指定某个方法不用拦截\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UnInterception {\n}\n```\n\n然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：\n\n```java\n@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n    HandlerMethod handlerMethod = (HandlerMethod) handler;\n    Method method = handlerMethod.getMethod();\n    String methodName = method.getName();\n    logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName);\n\n    // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截\n    // @UnInterception 是我们自定义的注解\n    UnInterception unInterception = method.getAnnotation(UnInterception.class);\n    if (null != unInterception) {\n        return true;\n    }\n    // 返回true才会继续执行，返回false则取消当前请求\n    return true;\n}\n```\n\nController 中的方法代码可以参见源码，重启项目在浏览器中输入 `http://localhost:8080/interceptor/test2?token=123` 测试一下，可以看出，加了该注解的方法不会被拦截。\n\n## 3. 总结\n\n本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第14课：Spring Boot 中集成Redis\n\n## 1. Redis 介绍\n\nRedis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。 \nNoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。 \nRedis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： \n\n![Redis使用场景](https://images.gitbook.cn/4258b9c0-9f93-11e8-a34f-d93da92347ea)\n\nRedis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。\n\n## 2. Redis 安装\n\n本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：\n\n* 安装 gcc 编译\n\n因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：\n\n```\nyum install gcc-c++\n```\n\n* 下载 redis\n\n有两种方式下载安装包，一种是去官网上下载（https://redis.io），然后将安装包考到 centos 中，另种方法是直接使用 wget 来下载：\n\n```\nwget http://download.redis.io/releases/redis-3.2.8.tar.gz\n```\n\n如果没有安装过 wget，可以通过如下命令安装：\n\n```\nyum install wget\n```\n\n* 解压安装\n\n解压安装包：\n\n```\ntar –vzxf redis-3.2.8.tar.gz\n```\n\n然后将解压的文件夹 redis-3.2.8 放到 `/usr/local/` 下，一般安装软件都放在 `/usr/local` 下。然后进入 `/usr/local/redis-3.2.8/` 文件夹下，执行 `make` 命令即可完成安装。\n【注】如果 make 失败，可以尝试如下命令：\n\n```\nmake MALLOC=libc\nmake install\n```\n\n* 修改配置文件\n\n安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。\n打开 redis 配置文件：`vi redis.conf`\n在命令模式下输入 `/bind` 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：\n\n```\nbind 0.0.0.0\n```\n\n使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。\n将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。\n\n* 启动 redis\n\n在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：\n\n```\nredis-server ./redis.conf\n```\n\n再启动 redis 客户端：\n\n```\nredis-cli\n```\n\n由于我们设置了密码，在启动客户端之后，输入 `auth 123456` 即可登录进入客户端。\n然后我们来测试一下，往 redis 中插入一个数据：\n\n```\nset name CSDN\n```\n\n然后来获取 name\n\n```\nget name\n```\n\n如果正常获取到 CSDN，则说明没有问题。\n\n## 3. Spring Boot 集成 Redis\n\n### 3.1 依赖导入\n\nSpring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<!--阿里巴巴fastjson -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.35</version>\n</dependency>\n```\n\n这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。\n\n### 3.2 Redis 配置\n\n导入了依赖之后，我们在 application.yml 文件里配置 redis：\n\n```yml\nserver:\n  port: 8080\nspring:\n  #redis相关配置\n  redis:\n    database: 5\n    # 配置redis的主机地址，需要修改成自己的\n    host: 192.168.48.190\n    port: 6379\n    password: 123456\n    timeout: 5000\n    jedis:\n      pool:\n        # 连接池中的最大空闲连接，默认值也是8。\n        max-idle: 500\n        # 连接池中的最小空闲连接，默认值也是0。\n        min-idle: 50\n        # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)\n        max-active: 1000\n        # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException\n        max-wait: 2000\n```\n\n### 3.3 常用 api 介绍\n\nSpring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。\n\n有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。\n\n#### 3.3.1 redis:string 类型\n\n新建一个 RedisService，注入 StringRedisTemplate，使用 `stringRedisTemplate.opsForValue()` 可以获取 `ValueOperations<String, String>` 对象，通过该对象即可读写 redis 数据库了。如下：\n\n```java\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis: string类型\n     * @param key key\n     * @param value value\n     */\n    public void setString(String key, String value){\n        ValueOperations<String, String> valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(key, value);\n    }\n\n    /**\n     * get redis: string类型\n     * @param key key\n     * @return\n     */\n    public String getString(String key){\n        return stringRedisTemplate.opsForValue().get(key);\n    }\n```\n\n该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n	@Resource\n	private RedisService redisService;\n\n	@Test\n	public void contextLoads() {\n        //测试redis的string类型\n        redisService.setString(\"weichat\",\"程序员私房菜\");\n        logger.info(\"我的微信公众号为：{}\", redisService.getString(\"weichat\"));\n\n        // 如果是个实体，我们可以使用json工具转成json字符串，\n        User user = new User(\"CSDN\", \"123456\");\n        redisService.setString(\"userInfo\", JSON.toJSONString(user));\n        logger.info(\"用户信息：{}\", redisService.getString(\"userInfo\"));\n    }\n}\n```\n\n先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：\n\n```\n我的微信公众号为：程序员私房菜\n用户信息：{\"password\":\"123456\",\"username\":\"CSDN\"}\n```\n\n#### 3.3.2 redis:hash 类型\n\nhash 类型其实原理和 string 一样的，但是有两个 key，使用 `stringRedisTemplate.opsForHash()` 可以获取 `HashOperations<String, Object, Object>` 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。\n\n```java\n@Service\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis: hash类型\n     * @param key key\n     * @param filedKey filedkey\n     * @param value value\n     */\n    public void setHash(String key, String filedKey, String value){\n        HashOperations<String, Object, Object> hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(key,filedKey, value);\n    }\n\n    /**\n     * get redis: hash类型\n     * @param key key\n     * @param filedkey filedkey\n     * @return\n     */\n    public String getHash(String key, String filedkey){\n        return (String) stringRedisTemplate.opsForHash().get(key, filedkey);\n    }\n}\n```\n\n可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：\n\n```java\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n	@Resource\n	private RedisService redisService;\n\n	@Test\n	public void contextLoads() {\n        //测试redis的hash类型\n        redisService.setHash(\"user\", \"name\", JSON.toJSONString(user));\n        logger.info(\"用户姓名：{}\", redisService.getHash(\"user\",\"name\"));\n    }\n}\n```\n\n#### 3.3.3 redis:list 类型\n\n使用 `stringRedisTemplate.opsForList()` 可以获取 `ListOperations<String, String> listOperations`  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。\n\n```java\n@Service\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis:list类型\n     * @param key key\n     * @param value value\n     * @return\n     */\n    public long setList(String key, String value){\n        ListOperations<String, String> listOperations = stringRedisTemplate.opsForList();\n        return listOperations.leftPush(key, value);\n    }\n\n    /**\n     * get redis:list类型\n     * @param key key\n     * @param start start\n     * @param end end\n     * @return\n     */\n    public List<String> getList(String key, long start, long end){\n        return stringRedisTemplate.opsForList().range(key, start, end);\n    }\n}\n```\n\n可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n	@Resource\n	private RedisService redisService;\n\n	@Test\n	public void contextLoads() {\n        //测试redis的list类型\n        redisService.setList(\"list\", \"football\");\n        redisService.setList(\"list\", \"basketball\");\n        List<String> valList = redisService.getList(\"list\",0,-1);\n        for(String value :valList){\n            logger.info(\"list中有：{}\", value);\n        }\n    }\n}\n```\n\n## 4. 总结\n\n本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第15课： Spring Boot中集成ActiveMQ\n\n## 1. JMS 和 ActiveMQ 介绍\n\n### 1.1 JMS 是啥\n\n百度百科的解释：\n\n> JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。\n\nJMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：\n\n> 连接工厂：ConnectionFactory  \n> JMS连接：Connection  \n> JMS会话：Session  \n> JMS目的：Destination  \n> JMS生产者：Producer  \n> JMS消费者：Consumer  \n> JMS消息两种类型：点对点和发布/订阅。  \n\n可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。\n\n### 1.2 ActiveMQ \n\nActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。   \n\n异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。\n\n## 2. ActiveMQ安装\n\n使用 ActiveMQ 首先需要去官网下载，官网地址为：http://activemq.apache.org/  \n本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 `activemq-all-5.15.3.jar`，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。\n\n在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。  \n消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费\n启动完成后，在浏览器中输入 `http://127.0.0.1:8161/admin/` 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：\n\n![activemq](https://images.gitbook.cn/cfb9c460-aa94-11e8-888f-df33be8ed191)\n\n我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？\n\n点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。\n\n发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。\n\n## 3. ActiveMQ集成\n\n### 3.1 依赖导入和配置\n\n在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：\n\n```xml\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n```\n\n然后在 application.yml 配置文件中，对 activemq 做一下配置：\n\n```yml\nspring:\n  activemq:\n  	# activemq url\n    broker-url: tcp://localhost:61616\n    in-memory: true\n    pool:\n      # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate\n      enabled: false\n```\n\n### 3.2 Queue 和 Topic 的创建\n\n首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：\n\n```java\n/**\n * activemq的配置\n * @author  shengwu ni\n */\n@Configuration\npublic class ActiveMqConfig {\n    /**\n     * 发布/订阅模式队列名称\n     */\n    public static final String TOPIC_NAME = \"activemq.topic\";\n    /**\n     * 点对点模式队列名称\n     */\n    public static final String QUEUE_NAME = \"activemq.queue\";\n\n    @Bean\n    public Destination topic() {\n        return new ActiveMQTopic(TOPIC_NAME);\n    }\n\n    @Bean\n    public Destination queue() {\n        return new ActiveMQQueue(QUEUE_NAME);\n    }\n}\n```\n\n可以看出创建 Queue 和 Topic 两种消息，分别使用 `new ActiveMQQueue` 和 `new ActiveMQTopic` 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。\n\n### 3.3 消息的发送接口\n\n在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：\n\n```java\n/**\n * 消息发送者\n * @author shengwu ni\n */\n@Service\npublic class MsgProducer {\n\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void sendMessage(Destination destination, String msg) {\n        jmsMessagingTemplate.convertAndSend(destination, msg);\n    }\n}\n```\n\n`convertAndSend` 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。\n\n\n### 3.4 点对点消息生产与消费\n\n#### 3.4.1 点对点消息的生产\n\n消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 `sendMessage` 即可成功生产一条消息。\n\n```java\n/**\n * ActiveMQ controller\n * @author shengwu ni\n */\n@RestController\n@RequestMapping(\"/activemq\")\npublic class ActiveMqController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);\n\n    @Resource\n    private MsgProducer producer;\n    @Resource\n    private Destination queue;\n\n    @GetMapping(\"/send/queue\")\n    public String sendQueueMessage() {\n\n        logger.info(\"===开始发送点对点消息===\");\n        producer.sendMessage(queue, \"Queue: hello activemq!\");\n        return \"success\";\n    }\n}\n```\n\n#### 3.4.2 点对点消息的消费\n\n点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。\n\n```java\n/**\n * 消息消费者\n * @author shengwu ni\n */\n@Service\npublic class QueueConsumer {\n\n    /**\n     * 接收点对点消息\n     * @param msg\n     */\n    @JmsListener(destination = ActiveMqConfig.QUEUE_NAME)\n    public void receiveQueueMsg(String msg) {\n        System.out.println(\"收到的消息为：\" + msg);\n    }\n}\n```\n\n可以看出，使用 `@JmsListener` 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。\n\n#### 3.4.3 测试一下\n\n启动项目，在浏览器中输入：`http://localhost:8081/activemq/send/queue`，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。\n\n```\n收到的消息为：Queue: hello activemq!\n```\n\n### 3.5 发布/订阅消息的生产和消费\n\n#### 3.5.1 发布/订阅消息的生产\n\n和点对点消息一样，我们注入 topic 并调用 producer 的 `sendMessage` 方法即可发送订阅消息，如下，不再赘述：\n\n```java\n@RestController\n@RequestMapping(\"/activemq\")\npublic class ActiveMqController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);\n\n    @Resource\n    private MsgProducer producer;\n    @Resource\n    private Destination topic;\n\n    @GetMapping(\"/send/topic\")\n    public String sendTopicMessage() {\n\n        logger.info(\"===开始发送订阅消息===\");\n        producer.sendMessage(topic, \"Topic: hello activemq!\");\n        return \"success\";\n    }\n}\n```\n\n#### 3.5.2 发布/订阅消息的消费\n\n发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：\n\n```yml\nspring:\n  jms:\n    pub-sub-domain: true\n```\n\n该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。\n\n比较好的解决办法是，我们定义一个工厂，`@JmsListener` 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：\n\n```java\n/**\n * activemq的配置\n *\n * @author shengwu ni\n */\n@Configuration\npublic class ActiveMqConfig {\n    // 省略其他内容\n\n    /**\n     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory\n     */\n    @Bean\n    public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) {\n        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true\n        factory.setPubSubDomain(true);\n        return factory;\n    }\n}\n```\n\n经过这样的配置之后，我们在消费的时候，在 `@JmsListener` 注解中指定这个容器工厂即可消费 topic 消息。如下：\n\n```java\n/**\n * Topic消息消费者\n * @author shengwu ni\n */\n@Service\npublic class TopicConsumer1 {\n\n    /**\n     * 接收订阅消息\n     * @param msg\n     */\n    @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = \"topicListenerContainer\")\n    public void receiveTopicMsg(String msg) {\n        System.out.println(\"收到的消息为：\" + msg);\n    }\n\n}\n```\n\n指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。\n\n#### 3.5.3 测试一下\n\n启动项目，在浏览器中输入：`http://localhost:8081/activemq/send/topic`，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。\n\n```\n收到的消息为：Topic: hello activemq!\n收到的消息为：Topic: hello activemq!\n```\n\n## 4. 总结\n\n本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第16课：Spring Boot中集成 Shiro\n\nShiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。\n\n## 1. Shiro 三大核心组件\n\nShiro 有三大核心的组件：`Subject`、`SecurityManager` 和 `Realm`。先来看一下它们之间的关系。\n\n![三大核心组件的关系](https://images.gitbook.cn/2dd0f5f0-af4a-11e8-a51c-93c39f2785b1)\n\n1. Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。\n\n> Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；   \n> Credentials：凭证。常见有密码，数字证书等等。\n\n说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。\n\n2. SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。\n\n3. Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。\n\n## 1. Shiro 身份和权限认证\n\n### 1.2 Shiro 身份认证\n\n我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：\n\n![认证过程](https://images.gitbook.cn/f21c53a0-af4f-11e8-a51c-93c39f2785b1)\n\nStep1：应用程序代码在调用 `Subject.login(token)` 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。 \n\nStep2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。 \n\nStep3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。\n\n### 1.3 Shiro 权限认证\n\n权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。\n\n> 权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利； \n> 角色（role）：指的是用户担任的的角色，一个角色可以有多个权限； \n> 用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。\n\n它们之间的的关系可以用下图来表示： \n\n![用户、角色和权限的关系](https://images.gitbook.cn/44a68bc0-af75-11e8-85ef-dd986da3511e)\n\n一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。\n\n## 2. Spring Boot 集成 Shiro 过程\n\n### 2.1 依赖导入\n\nSpring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：\n\n```xml\n<dependency>\n    <groupId>org.apache.shiro</groupId>\n    <artifactId>shiro-spring</artifactId>\n    <version>1.4.0</version>\n</dependency>\n```\n\n### 2.2 数据库表数据初始化\n\n这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。\n\n```sql\nCREATE TABLE `t_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `rolename` varchar(20) DEFAULT NULL COMMENT \'角色名称\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8\n\nCREATE TABLE `t_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'用户主键\',\n  `username` varchar(20) NOT NULL COMMENT \'用户名\',\n  `password` varchar(20) NOT NULL COMMENT \'密码\',\n  `role_id` int(11) DEFAULT NULL COMMENT \'外键关联role表\',\n  PRIMARY KEY (`id`),\n  KEY `role_id` (`role_id`),\n  CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8\n\nCREATE TABLE `t_permission` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `permissionname` varchar(50) NOT NULL COMMENT \'权限名\',\n  `role_id` int(11) DEFAULT NULL COMMENT \'外键关联role\',\n  PRIMARY KEY (`id`),\n  KEY `role_id` (`role_id`),\n  CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8\n```\n\n其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。\nt_user 表：\n\n|  id  | username | password | role_id |\n| :--: | :------: | :------: | :-----: |\n|  1   |  csdn1   |  123456  |    1    |\n|  2   |  csdn2   |  123456  |    2    |\n|  3   |  csdn3   |  123456  |    3    |\n\nt_role 表：\n\n|  id  | rolename |\n| :--: | :------: |\n|  1   |  admin   |\n|  2   | teacher  |\n|  3   | student  |\n\nt_permission 表：\n\n|  id  | permissionname | role_id |\n| :--: | :------------: | :-----: |\n|  1   |    `user:*`    |    1    |\n|  2   |  `student:*`   |    2    |\n\n解释一下这里的权限：`user:*`表示权限可以是 `user:create` 或者其他，`*` 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。\n\n### 2.2 自定义 Realm\n\n有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：\n\n> `doGetAuthenticationInfo()` 方法：用来验证当前登录的用户，获取认证信息   \n> `doGetAuthorizationInfo()` 方法：用来为当前登陆成功的用户授予权限和角色\n\n具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：\n\n```java\n/**\n * 自定义realm\n * @author shengwu ni\n */\npublic class MyRealm extends AuthorizingRealm {\n\n    @Resource\n    private UserService userService;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        // 获取用户名\n        String username = (String) principalCollection.getPrimaryPrincipal();\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        // 给该用户设置角色，角色信息存在t_role表中取\n        authorizationInfo.setRoles(userService.getRoles(username));\n        // 给该用户设置权限，权限信息存在t_permission表中取\n        authorizationInfo.setStringPermissions(userService.getPermissions(username));\n        return authorizationInfo;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释\n        String username = (String) authenticationToken.getPrincipal();\n        // 根据用户名从数据库中查询该用户\n        User user = userService.getByUsername(username);\n        if(user != null) {\n            // 把当前用户存到session中\n            SecurityUtils.getSubject().getSession().setAttribute(\"user\", user);\n            // 传入用户名和密码进行身份认证，并返回认证信息\n            AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"myRealm\");\n            return authcInfo;\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。\n\n### 2.3 Shiro 配置\n\n自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：\n\n配置自定义 realm：\n\n```java\n@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入自定义的realm\n     * @return MyRealm\n     */\n    @Bean\n    public MyRealm myAuthRealm() {\n        MyRealm myRealm = new MyRealm();\n        logger.info(\"====myRealm注册完成=====\");\n        return myRealm;\n    }\n}\n```\n\n配置安全管理器 SecurityManager：\n\n```java\n@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入安全管理器\n     * @return SecurityManager\n     */\n    @Bean\n    public SecurityManager securityManager() {\n        // 将自定义realm加进来\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm());\n        logger.info(\"====securityManager注册完成====\");\n        return securityManager;\n    }\n}\n```\n\n配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。\n\n配置 Shiro 过滤器：\n\n```java\n@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n    \n    /**\n     * 注入Shiro过滤器\n     * @param securityManager 安全管理器\n     * @return ShiroFilterFactoryBean\n     */\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {\n        // 定义shiroFactoryBean\n        ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean();\n\n        // 设置自定义的securityManager\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n\n        // 设置默认登录的url，身份认证失败会访问该url\n        shiroFilterFactoryBean.setLoginUrl(\"/login\");\n        // 设置成功之后要跳转的链接\n        shiroFilterFactoryBean.setSuccessUrl(\"/success\");\n        // 设置未授权界面，权限认证失败会访问该url\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\");\n\n        // LinkedHashMap是有序的，进行顺序拦截器配置\n        Map<String,String> filterChainMap = new LinkedHashMap<>();\n\n        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行\n        filterChainMap.put(\"/css/**\", \"anon\");\n        filterChainMap.put(\"/imgs/**\", \"anon\");\n        filterChainMap.put(\"/js/**\", \"anon\");\n        filterChainMap.put(\"/swagger-*/**\", \"anon\");\n        filterChainMap.put(\"/swagger-ui.html/**\", \"anon\");\n        // 登录url 放行\n        filterChainMap.put(\"/login\", \"anon\");\n\n        // “/user/admin” 开头的需要身份认证，authc表示要身份认证\n        filterChainMap.put(\"/user/admin*\", \"authc\");\n        // “/user/student” 开头的需要角色认证，是“admin”才允许\n        filterChainMap.put(\"/user/student*/**\", \"roles[admin]\");\n        // “/user/teacher” 开头的需要权限认证，是“user:create”才允许\n        filterChainMap.put(\"/user/teacher*/**\", \"perms[\\\"user:create\\\"]\");\n\n        // 配置logout过滤器\n        filterChainMap.put(\"/logout\", \"logout\");\n\n        // 设置shiroFilterFactoryBean的FilterChainDefinitionMap\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);\n        logger.info(\"====shiroFilterFactoryBean注册完成====\");\n        return shiroFilterFactoryBean;\n    }\n}\n```\n\n配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -> SecurityManager -> filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：\n\n> 默认登录的 url：身份认证失败会访问该 url\n> 认证成功之后要跳转的 url\n> 权限认证失败会访问该 url\n> 需要拦截或者放行的 url：这些都放在一个 map 中\n\n从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。\n\n|    Filter    |                             说明                             |\n| :----------: | :----------------------------------------------------------: |\n|     anon     |      开放权限，可以理解为匿名用户或游客，可以直接访问的      |\n|    authc     |                        需要身份认证的                        |\n|    logout    | 注销，执行后会直接跳转到 `shiroFilterFactoryBean.setLoginUrl();` 设置的 url，即登录页面 |\n| roles[admin] | 参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[\"admin，user\"]，当有多个参数时必须每个参数都通过才算通过 |\n| perms[user]  | 参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过 |\n\n### 2.4 使用 Shiro 进行认证\n\n到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：\n\n> 接口一： 使用 `http://localhost:8080/user/admin` 来验证身份认证\n> 接口二： 使用 `http://localhost:8080/user/student` 来验证角色认证\n> 接口三： 使用 `http://localhost:8080/user/teacher` 来验证权限认证\n> 接口四： 使用 `http://localhost:8080/user/login` 来实现用户登录\n\n然后来一下认证的流程：\n\n> 流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。\n> 流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。\n> 流程三： 访问接口二，测试角色认证是否成功。\n> 流程四： 访问接口三，测试权限认证是否成功。\n\n#### 2.4.1 身份、角色、权限认证接口\n\n```java\n@Controller\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    /**\n     * 身份认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(\"/admin\")\n    public String admin(HttpServletRequest request) {\n        Object user = request.getSession().getAttribute(\"user\");\n        return \"success\";\n    }\n\n    /**\n     * 角色认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(\"/student\")\n    public String student(HttpServletRequest request) {\n        return \"success\";\n    }\n\n    /**\n     * 权限认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(\"/teacher\")\n    public String teacher(HttpServletRequest request) {\n        return \"success\";\n    }\n}\n```\n\n这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。\n\n#### 2.4.2 用户登录接口\n\n```java\n@Controller\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    /**\n     * 用户登录接口\n     * @param user user\n     * @param request request\n     * @return string\n     */\n    @PostMapping(\"/login\")\n    public String login(User user, HttpServletRequest request) {\n\n        // 根据用户名和密码创建token\n        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());\n        // 获取subject认证主体\n        Subject subject = SecurityUtils.getSubject();\n        try{\n            // 开始认证，这一步会跳到我们自定义的realm中\n            subject.login(token);\n            request.getSession().setAttribute(\"user\", user);\n            return \"success\";\n        }catch(Exception e){\n            e.printStackTrace();\n            request.getSession().setAttribute(\"user\", user);\n            request.setAttribute(\"error\", \"用户名或密码错误！\");\n            return \"login\";\n        }\n    }\n}\n```\n\n我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 `subject.login(token)` 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 `doGetAuthenticationInfo` 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。\n\n#### 2.4.3 测试一下\n\n最后，启动项目，测试一下：\n浏览器请求 `http://localhost:8080/user/admin` 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 `/login` 接口，然后跳转到 `login.html` 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 `http://localhost:8080/user/student` 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 `http://localhost:8080/user/teacher` 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 `user:*`，满足配置中的 `user:create`，所以认证通过。\n\n接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。\n\n\n## 3. 总结\n\n本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第17课：Spring Boot中集成Lucence\n\n## 1. Lucence 和全文检索\n\nLucene 是什么？看一下百度百科：\n\n> Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》\n\n### 1.1 全文检索\n\n这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。  \n\n何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。   \n\n文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。 \n\n### 1.2 Lucene 建立索引的方式\n\n那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：\n\n> 文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.   \n> 文章2的内容为：He once lived in Shanghai.\n\n首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：\n\n> 文章1经过分词后的结果：`[Tom]` `[lives]` `[Guangzhou]` `[I]` `[live]` `[Guangzhou]`   \n> 文章2经过分词后的结果：`[He]` `[lives]` `[Shanghai]`\n\n然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：\n\n> 文章1经过处理后的结果：`[tom]` `[live]` `[guangzhou]` `[i]` `[live]` `[guangzhou]` \n> 文章2经过处理后的结果：`[he]` `[live]` `[shanghai]`\n\n最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：\n\n|  关键词   | 文章号[出现频率] | 出现位置 |\n| :-------: | :--------------: | :------: |\n| guangzhou |       1[2]       |   3,6    |\n|    he     |       2[1]       |    1     |\n|     i     |       1[1]       |    4     |\n|   live    |    1[2],2[1]     |  2,5,2   |\n| shanghai  |       2[1]       |    3     |\n|    tom    |       1[1]       |    1     |\n\n以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 \n搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。\n\n理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。\n\n## 2. Spring Boot 中集成 Lucence\n\n### 2.1 依赖导入\n\n首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：\n\n```xml\n<!-- Lucence核心包 -->\n<dependency>\n	<groupId>org.apache.lucene</groupId>\n	<artifactId>lucene-core</artifactId>\n	<version>5.3.1</version>\n</dependency>\n\n<!-- Lucene查询解析包 -->\n<dependency>\n	<groupId>org.apache.lucene</groupId>\n	<artifactId>lucene-queryparser</artifactId>\n	<version>5.3.1</version>\n</dependency>\n\n<!-- 常规的分词（英文） -->\n<dependency>\n	<groupId>org.apache.lucene</groupId>\n	<artifactId>lucene-analyzers-common</artifactId>\n	<version>5.3.1</version>\n</dependency>\n\n<!--支持分词高亮  -->\n<dependency>\n	<groupId>org.apache.lucene</groupId>\n	<artifactId>lucene-highlighter</artifactId>\n	<version>5.3.1</version>\n</dependency>\n\n<!--支持中文分词  -->\n<dependency>\n	<groupId>org.apache.lucene</groupId>\n	<artifactId>lucene-analyzers-smartcn</artifactId>\n	<version>5.3.1</version>\n</dependency>\n```\n\n最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。\n\n### 2.2 快速入门\n\n根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。\n\n#### 2.2.1 建立索引\n\n我们自己弄几个文件，放到 `D:\\lucene\\data` 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。\n\n```java\npublic class Indexer {\n\n    /**\n     * 写索引实例\n     */\n    private IndexWriter writer;\n\n    /**\n     * 构造方法，实例化IndexWriter\n     * @param indexDir\n     * @throws Exception\n     */\n    public Indexer(String indexDir) throws Exception {\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        //标准分词器，会自动去掉空格啊，is a the等单词\n        Analyzer analyzer = new StandardAnalyzer();\n        //将标准分词器配到写索引的配置中\n        IndexWriterConfig config = new IndexWriterConfig(analyzer);\n        //实例化写索引对象\n        writer = new IndexWriter(dir, config);\n    }\n}\n```\n\n在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。\n\n```java\n/**\n * 索引指定目录下的所有文件\n * @param dataDir\n * @return\n * @throws Exception\n */\npublic int indexAll(String dataDir) throws Exception {\n    // 获取该路径下的所有文件\n    File[] files = new File(dataDir).listFiles();\n    if (null != files) {\n        for (File file : files) {\n            //调用下面的indexFile方法，对每个文件进行索引\n            indexFile(file);\n        }\n    }\n    //返回索引的文件数\n    return writer.numDocs();\n}\n\n/**\n * 索引指定的文件\n * @param file\n * @throws Exception\n */\nprivate void indexFile(File file) throws Exception {\n    System.out.println(\"索引文件的路径：\" + file.getCanonicalPath());\n    //调用下面的getDocument方法，获取该文件的document\n    Document doc = getDocument(file);\n    //将doc添加到索引中\n    writer.addDocument(doc);\n}\n\n/**\n * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录\n * @param file\n * @return\n * @throws Exception\n */\nprivate Document getDocument(File file) throws Exception {\n    Document doc = new Document();\n    //开始添加字段\n    //添加内容\n    doc.add(new TextField(\"contents\", new FileReader(file)));\n    //添加文件名，并把这个字段存到索引文件里\n    doc.add(new TextField(\"fileName\", file.getName(), Field.Store.YES));\n    //添加文件路径\n    doc.add(new TextField(\"fullPath\", file.getCanonicalPath(), Field.Store.YES));\n    return doc;\n}\n```\n\n这样就建立好索引了，我们在该类中写一个 main 方法测试一下：\n\n```java\npublic static void main(String[] args) {\n        //索引保存到的路径\n        String indexDir = \"D:\\\\lucene\";\n        //需要索引的文件数据存放的目录\n        String dataDir = \"D:\\\\lucene\\\\data\";\n        Indexer indexer = null;\n        int indexedNum = 0;\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        try {\n            // 开始构建索引\n            indexer = new Indexer(indexDir);\n            indexedNum = indexer.indexAll(dataDir);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (null != indexer) {\n                    indexer.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"索引耗时\" + (endTime - startTime) + \"毫秒\");\n        System.out.println(\"共索引了\" + indexedNum + \"个文件\");\n    }\n```\n\n我搞了两个 tomcat 相关的文件放到 `D:\\lucene\\data` 下了，执行完之后，看到控制台输出：\n\n```\n索引文件的路径：D:\\lucene\\data\\catalina.properties\n索引文件的路径：D:\\lucene\\data\\logging.properties\n索引耗时882毫秒\n共索引了2个文件\n```\n\n然后我们去 `D:\\lucene\\` 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。\n\n####2.2.2 检索内容\n\n上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。\n\n```java\npublic class Searcher {\n\n    public static void search(String indexDir, String q) throws Exception {\n\n        //获取要查询的路径，也就是索引所在的位置\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        IndexReader reader = DirectoryReader.open(dir);\n        //构建IndexSearcher\n        IndexSearcher searcher = new IndexSearcher(reader);\n        //标准分词器，会自动去掉空格啊，is a the等单词\n        Analyzer analyzer = new StandardAnalyzer();\n        //查询解析器\n        QueryParser parser = new QueryParser(\"contents\", analyzer);\n        //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串\n        Query query = parser.parse(q);\n\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        //开始查询，查询前10条数据，将记录保存在docs中\n        TopDocs docs = searcher.search(query, 10);\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"匹配\" + q + \"共耗时\" + (endTime-startTime) + \"毫秒\");\n        System.out.println(\"查询到\" + docs.totalHits + \"条记录\");\n\n        //取出每条查询结果\n        for(ScoreDoc scoreDoc : docs.scoreDocs) {\n            //scoreDoc.doc相当于docID,根据这个docID来获取文档\n            Document doc = searcher.doc(scoreDoc.doc);\n            //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。\n            System.out.println(doc.get(\"fullPath\"));\n        }\n        reader.close();\n    }\n}\n```\n\nok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：\n\n```java\npublic static void main(String[] args) {\n    String indexDir = \"D:\\\\lucene\";\n    //查询这个字符串\n    String q = \"security\";\n    try {\n        search(indexDir, q);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n查一下 `security` 这个字符串，执行一下看控制台打印的结果：\n\n```\n匹配security共耗时23毫秒\n查询到1条记录\nD:\\lucene\\data\\catalina.properties\n```\n\n可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。\n\n### 2.3 中文分词检索高亮实战\n\n上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。\n\n#### 2.3.1 中文分词\n\n我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：\n\n```java\npublic class ChineseIndexer {\n\n    /**\n     * 存放索引的位置\n     */\n    private Directory dir;\n\n    //准备一下用来测试的数据\n    //用来标识文档\n    private Integer ids[] = {1, 2, 3};\n    private String citys[] = {\"上海\", \"南京\", \"青岛\"};\n    private String descs[] = {\n            \"上海是个繁华的城市。\",\n            \"南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。\",\n            \"青岛是一个美丽的城市。\"\n    };\n\n    /**\n     * 生成索引\n     * @param indexDir\n     * @throws Exception\n     */\n    public void index(String indexDir) throws Exception {\n        dir = FSDirectory.open(Paths.get(indexDir));\n        // 先调用 getWriter 获取IndexWriter对象\n        IndexWriter writer = getWriter();\n        for(int i = 0; i < ids.length; i++) {\n            Document doc = new Document();\n            // 把上面的数据都生成索引，分别用id、city和desc来标识\n            doc.add(new IntField(\"id\", ids[i], Field.Store.YES));\n            doc.add(new StringField(\"city\", citys[i], Field.Store.YES));\n            doc.add(new TextField(\"desc\", descs[i], Field.Store.YES));\n            //添加文档\n            writer.addDocument(doc);\n        }\n        //close了才真正写到文档中\n        writer.close();\n    }\n\n    /**\n     * 获取IndexWriter实例\n     * @return\n     * @throws Exception\n     */\n    private IndexWriter getWriter() throws Exception {\n        //使用中文分词器\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\n        //将中文分词器配到写索引的配置中\n        IndexWriterConfig config = new IndexWriterConfig(analyzer);\n        //实例化写索引对象\n        IndexWriter writer = new IndexWriter(dir, config);\n        return writer;\n    }\n\n    public static void main(String[] args) throws Exception {\n        new ChineseIndexer().index(\"D:\\\\lucene2\");\n    }\n}\n```\n\n这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。\n然后执行一下 main 方法，将索引保存到 `D:\\lucene2\\` 中。 \n\n#### 2.3.2 中文分词查询\n\n中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：\n\n```java\npublic class ChineseSearch {\n\n    private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class);\n\n    public static List<String> search(String indexDir, String q) throws Exception {\n\n        //获取要查询的路径，也就是索引所在的位置\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        //使用中文分词器\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\n        //由中文分词器初始化查询解析器\n        QueryParser parser = new QueryParser(\"desc\", analyzer);\n        //通过解析要查询的String，获取查询对象\n        Query query = parser.parse(q);\n\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        //开始查询，查询前10条数据，将记录保存在docs中\n        TopDocs docs = searcher.search(query, 10);\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        logger.info(\"匹配{}共耗时{}毫秒\", q, (endTime - startTime));\n        logger.info(\"查询到{}条记录\", docs.totalHits);\n\n        //如果不指定参数的话，默认是加粗，即<b><b/>\n        SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(\"<b><font color=red>\",\"</font></b>\");\n        //根据查询对象计算得分，会初始化一个查询结果最高的得分\n        QueryScorer scorer = new QueryScorer(query);\n        //根据这个得分计算出一个片段\n        Fragmenter fragmenter = new SimpleSpanFragmenter(scorer);\n        //将这个片段中的关键字用上面初始化好的高亮格式高亮\n        Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer);\n        //设置一下要显示的片段\n        highlighter.setTextFragmenter(fragmenter);\n\n        //取出每条查询结果\n        List<String> list = new ArrayList<>();\n        for(ScoreDoc scoreDoc : docs.scoreDocs) {\n            //scoreDoc.doc相当于docID,根据这个docID来获取文档\n            Document doc = searcher.doc(scoreDoc.doc);\n            logger.info(\"city:{}\", doc.get(\"city\"));\n            logger.info(\"desc:{}\", doc.get(\"desc\"));\n            String desc = doc.get(\"desc\");\n\n            //显示高亮\n            if(desc != null) {\n                TokenStream tokenStream = analyzer.tokenStream(\"desc\", new StringReader(desc));\n                String summary = highlighter.getBestFragment(tokenStream, desc);\n                logger.info(\"高亮后的desc:{}\", summary);\n                list.add(summary);\n            }\n        }\n        reader.close();\n        return list;\n    }\n}\n```\n\n每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。\n\n#### 2.3.3 测试一下\n\n这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：\n\n```java\n@Controller\n@RequestMapping(\"/lucene\")\npublic class IndexController {\n\n    @GetMapping(\"/test\")\n    public String test(Model model) {\n        // 索引所在的目录\n        String indexDir = \"D:\\\\lucene2\";\n        // 要查询的字符\n//        String q = \"南京文明\";\n        String q = \"南京文化\";\n        try {\n            List<String> list = ChineseSearch.search(indexDir, q);\n            model.addAttribute(\"list\", list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"result\";\n    }\n}\n```\n\n直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div th:each=\"desc : ${list}\">\n    <div th:utext=\"${desc}\"></div>\n</div>\n</body>\n</html>\n```\n\n这里注意一下，不能使用 `th:test`，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 `http://localhost:8080/lucene/test`，测试一下效果，我们搜索的是 “南京文化”。\n\n![南京文化](https://images.gitbook.cn/83b3f810-b377-11e8-88bf-23cb78d1fb4f)\n\n再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。\n\n![南京文明](https://images.gitbook.cn/8ef8a4a0-b377-11e8-911d-27cc5f059829)\n\n可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。\n\n## 3. 总结\n\n本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第18课：Spring Boot搭建实际项目开发中的架构\n\n前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。\n\n不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。\n\n从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。\n\n结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。\n\n![工程架构](https://images.gitbook.cn/6f23c980-b89e-11e8-87f1-559c9b456754)\n\n## 1. 统一的数据封装 \n\n由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：\n\n```java\n/**\n * 统一返回对象\n * @author shengwu ni\n * @param <T>\n */\npublic class JsonResult<T> {\n\n    private T data;\n    private String code;\n    private String msg;\n\n    /**\n     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！\n     */\n    public JsonResult() {\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 若没有数据返回，可以人为指定状态码和提示信息\n     * @param code\n     * @param msg\n     */\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    /**\n     * 有数据返回时，状态码为0，默认提示信息为：操作成功！\n     * @param data\n     */\n    public JsonResult(T data) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 有数据返回，状态码为0，人为指定提示信息\n     * @param data\n     * @param msg\n     */\n    public JsonResult(T data, String msg) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = msg;\n    }\n    \n    /**\n     * 使用自定义异常作为参数传递状态码和提示信息\n     * @param msgEnum\n     */\n    public JsonResult(BusinessMsgEnum msgEnum) {\n        this.code = msgEnum.code();\n        this.msg = msgEnum.msg();\n    }\n\n    // 省去get和set方法\n}\n```\n\n大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。\n\n## 2. json的处理\n\nJson 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。\n\n```java\n/**\n * jacksonConfig\n * @author shengwu ni\n */\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    @Primary\n    @ConditionalOnMissingBean(ObjectMapper.class)\n    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n        ObjectMapper objectMapper = builder.createXmlMapper(false).build();\n        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer<Object>() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(\"\");\n            }\n        });\n        return objectMapper;\n    }\n}\n```\n\n这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。\n\n## 3. swagger2在线可调式接口\n\n有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：\n\n```java\n/**\n * swagger配置\n * @author shengwu ni\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                // 指定构建api文档的详细信息的方法：apiInfo()\n                .apiInfo(apiInfo())\n                .select()\n                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口\n                .apis(RequestHandlerSelectors.basePackage(\"com.itcodai.course18.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 构建api文档的详细信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                // 设置页面标题\n                .title(\"Spring Boot搭建实际项目中开发的架构\")\n                // 设置接口描述\n                .description(\"跟武哥一起学Spring Boot第18课\")\n                // 设置联系方式\n                .contact(\"倪升武，\" + \"微信公众号：程序员私房菜\")\n                // 设置版本\n                .version(\"1.0\")\n                // 构建\n                .build();\n    }\n}\n```\n\n到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。\n\n```java\n@RestController\n@Api(value = \"用户信息接口\")\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    @GetMapping(\"/getUser/{id}\")\n    @ApiOperation(value = \"根据用户唯一标识获取用户信息\")\n    public JsonResult<User> getUserInfo(@PathVariable @ApiParam(value = \"用户唯一标识\") Long id) {\n        User user = new User(id, \"倪升武\", \"123456\");\n        return new JsonResult<>(user);\n    }\n}\n```\n\n然后启动项目，在浏览器中输入 `localhost:8080/swagger-ui.html` 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。\n\n## 4. 持久层集成\n\n每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。\n\n```yml\n# 服务端口号\nserver:\n  port: 8080\n\n# 数据库地址\ndatasource:\n  url: localhost:3306/blog_test\n\nspring:\n  datasource: # 数据库配置\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://${datasource.url}?useSSL=false&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 10 # 最大连接池数\n      max-lifetime: 1770000\n\nmybatis:\n  # 指定别名设置的包为所有entity\n  type-aliases-package: com.itcodai.course18.entity\n  configuration:\n    map-underscore-to-camel-case: true # 驼峰命名规范\n  mapper-locations: # mapper映射文件位置\n    - classpath:mapper/*.xml\n```\n\n配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。\n\n```java\npublic interface UserMapper {\n\n    @Select(\"select * from user where id = #{id}\")\n    @Results({\n            @Result(property = \"username\", column = \"user_name\"),\n            @Result(property = \"password\", column = \"password\")\n    })\n    User getUser(Long id);\n\n    @Select(\"select * from user where id = #{id} and user_name=#{name}\")\n    User getUserByIdAndName(@Param(\"id\") Long id, @Param(\"name\") String username);\n\n    @Select(\"select * from user\")\n    List<User> getAll();\n}\n```\n\n关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 `@MapperScan(\"com.itcodai.course18.dao\")`\n\n## 5. 拦截器\n\n拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。\n\n```java\npublic class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        logger.info(\"执行方法之前执行(Controller方法调用之前)\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\");\n    }\n}\n```\n\n然后将自定义的拦截器加入到拦截器配置中。\n\n```java\n@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor())\n                // 拦截所有url\n                .addPathPatterns(\"/**\")\n                // 放行swagger\n                .excludePathPatterns(\"/swagger-resources/**\");\n    }\n}\n```\n\n在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：\n\n> classpath:/static   \n> classpath:/public   \n> classpath:/resources   \n> classpath:/META-INF/resources  \n\n上面代码中配置的 `/**` 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。\n\n然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。\n\n## 6. 全局异常处理\n\n全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：\n\n```java\npublic enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(\"102\", \"参数异常!\"),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"),\n    /** 500 : 发生异常 */\n    UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\");\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public String code() {\n        return code;\n    }\n\n    public String msg() {\n        return msg;\n    }\n\n}\n```\n\n在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。\n\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(\"空指针异常，{}\", ex.getMessage());\n        return new JsonResult(\"500\", \"空指针异常了\");\n    }\n\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(\"系统异常：\", ex);\n        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n    }\n\n}\n```\n\n其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。\n在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。\n\n## 7. 总结\n\n本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n> 欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n\n# 附：作者信息\n\n本课程首发于 CSDN GitChat 达人课，该文档为课程详细笔记\n作者：倪升武（武哥）\n微信公众号：武哥聊编程\n二维码：\n\n![武哥聊编程](https://img-blog.csdnimg.cn/202002150421550.jpg)\n\n>版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途，否则追究法律责任。\n\n', 'http://cdn.alanliang.site/3b37b37055c1bf916df926d305f0f443.jpg', 2, 1, 0, 0, b'0', b'1', b'0', b'0', b'1', 2, 3, 5, 2, '2020-06-15 12:25:04', '2020-06-15 12:25:04');
INSERT INTO `t_article` VALUES (12, 'vue无法读取某个为null的属性的问题', 'vue无法读取某个为null的属性的问题', '<p>最近，用vue做页面数据绑定，打开控制台有时会冒出一片红色，如图：</p>\n<p><img src=\"http://cdn.alanliang.site/note/2020-04-25_172227.png\" alt=\"vue控制台报错\"></p>\n<p>虽然显示有错误，但是对页面一点影响都没有，页面照样正常渲染。但是，身为一个强迫症，实在受不了控制台有一行红色，然后就琢磨呗！</p>\n<p>从控制台的给出信息中可以知道，它说<code>cover</code>属性为空，不能读取。那没道理啊，在控制台打印这个属性是能够获取值的，如图：</p>\n<p><img src=\"http://cdn.alanliang.site/note/2020-04-25_171123.png\" alt=\"控制台打印\"></p>\n<p>而且这张图片在页面上也能正常显示。问题代码就出现在这里：</p>\n<pre><code class=\"lang-html\"> &lt;div class=&quot;bg-cover pd-header post-cover&quot; :style=&quot;{backgroundImage: &#39;url(&#39; + article.cover + &#39;)&#39; }&quot;&gt;\n</code></pre>\n<p>看这行代码，我想着是不是vue有特殊的机制，通过<code>article.cover</code>调用，<code>article</code>可能为空，所以就不能读取<code>cover</code>属性了？那我不通过<code>article.cover</code>调用，手动给<code>cover</code>赋值试一试，代码如下：</p>\n<pre><code class=\"lang-js\">data: {cover: null}\n</code></pre>\n<pre><code class=\"lang-js\">methods: {\n    getArticleById: function (id) {\n        axios({\n            url: &#39;/article?id=&#39; + id,\n            method: &#39;GET&#39;\n        }).then((result) =&gt; {\n            this.article = result.data;\n            this.title = this.article.title;\n        })\n    },\n</code></pre>\n<pre><code class=\"lang-html\">&lt;div class=&quot;bg-cover pd-header post-cover&quot; :style=&quot;{backgroundImage: &#39;url(&#39; + cover + &#39;)&#39; }&quot;&gt;\n</code></pre>\n<p>可以看到，在<code>data</code>中单独声明了<code>cover</code>属性，当通过异步获取到<code>article</code>时再赋值给<code>cover</code>，最后在数据绑定时直接使用<code>cover</code>。再次打开控制台，发现：</p>\n<p><img src=\"http://cdn.alanliang.site/note/2020-04-25_172227.png\" alt=\"vue控制台报错\"></p>\n<p><code>cover</code>属性确实不报错了，但是另一个属性<code>title</code>又报错了，给<code>title</code>属性手动赋值后，另一个属性又报错了，整个页面几十个属性总不能每一个都手动赋值吧，就算能解决，也懒得写。</p>\n<p>正当一筹莫展的时候，突然想到直接给在vue管理的整个div上对<code>article</code>进行判空行不行？那就试一试呗。代码如下：</p>\n<pre><code class=\"lang-html\">&lt;div id=&quot;app&quot; v-if=&quot;article != null&quot;&gt;\n    ...\n&lt;/div&gt;\n</code></pre>\n<p>没想到真解决了！如图：</p>\n<p><img src=\"http://cdn.alanliang.site/note/2020-04-25_172958.png\" alt=\"控制台信息\"></p>\n<p>可以看到vue没有再报错，这个红色的报错不是vue报的，而是另一个插件报的（还得继续努力啊！）</p>\n<p>由于刚入门vue，不懂vue的底层，暂时还搞不明白什么原因，在网上也暂时没找到贴切的答案，这样的办法应该不是最好的，等以后对vue有了更深刻的理解后，再回来康康吧！</p>\n', '\n\n最近，用vue做页面数据绑定，打开控制台有时会冒出一片红色，如图：\n\n![vue控制台报错](http://cdn.alanliang.site/note/2020-04-25_172227.png)\n\n虽然显示有错误，但是对页面一点影响都没有，页面照样正常渲染。但是，身为一个强迫症，实在受不了控制台有一行红色，然后就琢磨呗！\n\n从控制台的给出信息中可以知道，它说`cover`属性为空，不能读取。那没道理啊，在控制台打印这个属性是能够获取值的，如图：\n\n![控制台打印](http://cdn.alanliang.site/note/2020-04-25_171123.png)\n\n而且这张图片在页面上也能正常显示。问题代码就出现在这里：\n\n```html\n <div class=\"bg-cover pd-header post-cover\" :style=\"{backgroundImage: \'url(\' + article.cover + \')\' }\">\n```\n\n看这行代码，我想着是不是vue有特殊的机制，通过`article.cover`调用，`article`可能为空，所以就不能读取`cover`属性了？那我不通过`article.cover`调用，手动给`cover`赋值试一试，代码如下：\n\n```js\ndata: {cover: null}\n```\n\n```js\nmethods: {\n    getArticleById: function (id) {\n        axios({\n            url: \'/article?id=\' + id,\n            method: \'GET\'\n        }).then((result) => {\n            this.article = result.data;\n            this.title = this.article.title;\n        })\n    },\n```\n\n```html\n<div class=\"bg-cover pd-header post-cover\" :style=\"{backgroundImage: \'url(\' + cover + \')\' }\">\n```\n\n可以看到，在`data`中单独声明了`cover`属性，当通过异步获取到`article`时再赋值给`cover`，最后在数据绑定时直接使用`cover`。再次打开控制台，发现：\n\n![vue控制台报错](http://cdn.alanliang.site/note/2020-04-25_172227.png)\n\n`cover`属性确实不报错了，但是另一个属性`title`又报错了，给`title`属性手动赋值后，另一个属性又报错了，整个页面几十个属性总不能每一个都手动赋值吧，就算能解决，也懒得写。\n\n正当一筹莫展的时候，突然想到直接给在vue管理的整个div上对`article`进行判空行不行？那就试一试呗。代码如下：\n\n```html\n<div id=\"app\" v-if=\"article != null\">\n    ...\n</div>\n```\n\n没想到真解决了！如图：\n\n![控制台信息](http://cdn.alanliang.site/note/2020-04-25_172958.png)\n\n可以看到vue没有再报错，这个红色的报错不是vue报的，而是另一个插件报的（还得继续努力啊！）\n\n由于刚入门vue，不懂vue的底层，暂时还搞不明白什么原因，在网上也暂时没找到贴切的答案，这样的办法应该不是最好的，等以后对vue有了更深刻的理解后，再回来康康吧！', 'http://cdn.alanliang.site/note/2020-04-25_172227.png', 1, 2, 0, 0, b'0', b'1', b'0', b'0', b'1', 1, 3, 2, 2, '2020-06-15 12:34:05', '2020-06-15 12:34:05');
INSERT INTO `t_article` VALUES (13, 'Mybatis中两种级联方式的介绍和性能对比', '最近在做一个基于SpringBoot+MybatisPlus博客系统的项目，在管理后台需要列出所有文章，效果是这样的:', '<h2 id=\"h2-u57FAu672Cu4ECBu7ECD\"><a name=\"基本介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本介绍</h2><p>最近在做一个基于SpringBoot+MybatisPlus博客系统的项目，在管理后台需要列出所有文章，效果是这样的：</p>\n<p><img src=\"http://cdn.alanliang.site/note/1.png\" alt=\"avatar\"></p>\n<p>注意红色部分，查出文章的信息时，还需要查文章的分类和文章的标签。这很容易想到需要使用Mybatis的级联查询，但是在写mapper文件代码的时候，想到级联其实有两种方式：</p>\n<ul>\n<li>基于分层次查询的</li><li>基于SQL表连接的</li></ul>\n<p>这样说，大家可能会觉得云里雾里的，啥叫分层次的，啥又叫SQL表连接的，这里给出代码，想必平时使用过Mybatis的小伙伴就会明白了。</p>\n<ul>\n<li>基于分层次查询的</li></ul>\n<pre><code class=\"lang-xml\">&lt;resultMap id=&quot;resultMap1&quot; type=&quot;site.alanliang.geekblog.domain.Article&quot;&gt;\n    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;\n\n    &lt;association property=&quot;category&quot; column=&quot;category_id&quot;                 select=&quot;site.alanliang.geekblog.mapper.ArticleMapper.selectCategoryById&quot;/&gt;\n\n&lt;/resultMap&gt;\n\n&lt;select id=&quot;selectCategoryById&quot; resultType=&quot;site.alanliang.geekblog.domain.Category&quot;&gt;\n    select id, name from t_category where id = #{id}\n&lt;/select&gt;\n\n&lt;select id=&quot;selectArticleById1&quot; parameterType=&quot;long&quot; resultMap=&quot;resultMap1&quot;&gt;\n    select id, title, category_id from t_article where id = #{id}\n&lt;/select&gt;\n</code></pre>\n<ul>\n<li>基于SQL表连接的</li></ul>\n<pre><code class=\"lang-xml\">&lt;resultMap id=&quot;resultMap2&quot; type=&quot;site.alanliang.geekblog.domain.Article&quot;&gt;\n    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;\n\n    &lt;association property=&quot;category&quot; javaType=&quot;site.alanliang.geekblog.domain.Category&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;\n    &lt;/association&gt;\n\n&lt;/resultMap&gt;\n\n&lt;select id=&quot;selectArticleById2&quot; parameterType=&quot;long&quot; resultMap=&quot;resultMap2&quot;&gt;\n    select ta.id, ta.title, tc.id, tc.name\n    from t_article ta\n    inner join t_category tc\n    on ta.category_id = tc.id\n    where ta.id = #{aid}\n&lt;/select&gt;\n</code></pre>\n<p>注意association和select标签的区别。我平时比较粗心，根本没在意它们的区别，但是这次做项目的时候再次碰到，这次才引起了我的注意，也激起了我的好奇心，究竟它们的区别在哪呢？</p>\n<p>查过资料后，我终于明白了：</p>\n<p>分层次查询的方式是单表查询，首先发送1条SQL查询文章(Article)的信息，然后查询文章的分类(category)时再发送1条SQL，也就是查询1条文章记录需要发送2条SQL。</p>\n<p>基于SQL表连接的方式是多表查询，在这里也就是Article表和Category表连接查询，只需要发送1条SQL。</p>\n<p>我们做个测试，测试代码如下：</p>\n<pre><code class=\"lang-java\">@Autowired\nprivate ArticleMapper articleMapper;\n\n@Test\nvoid selectArticleById1(){\n    Article article = articleMapper.selectArticleById1(7L);\n    System.out.println(article);\n}\n\n@Test\nvoid selectArticleById2(){\n    Article article = articleMapper.selectArticleById2(7L);\n    System.out.println(article);\n}\n</code></pre>\n<p>测试结果如下：</p>\n<p><img src=\"http://cdn.alanliang.site/note/3.png\" alt=\"avatar\"></p>\n<p><img src=\"http://cdn.alanliang.site/note/4.png\" alt=\"avatar\"></p>\n<p>结果显而易见。</p>\n<h2 id=\"h2-u8FC7u7A0Bu5206u6790\"><a name=\"过程分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>过程分析</h2><ul>\n<li>基于分层次查询</li></ul>\n<p>我认为的大致过程是这样的。首先，测试中执行代码：</p>\n<pre><code class=\"lang-java\"> Article article = articleMapper.selectArticleById1(7L);\n</code></pre>\n<p>Mybatis会找到相应mapper文件中的这部分代码：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;selectArticleById1&quot; parameterType=&quot;long&quot; resultMap=&quot;resultMap1&quot;&gt;\n    select id, title, category_id from t_article where id = #{id}\n&lt;/select&gt;\n</code></pre>\n<p>Mybatis发送完这条SQL语句，查询到字段id，title和category_id。将字段id和title映射至resultMap1中的相应属性，category_id后面会用到（注意！SQL语句中不能缺少这个字段，否则将查不到对应的category）而resultMap1中代码：</p>\n<pre><code class=\"lang-xml\">&lt;resultMap id=&quot;resultMap1&quot; type=&quot;site.alanliang.geekblog.domain.Article&quot;&gt;\n    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;\n\n    &lt;association property=&quot;category&quot; column=&quot;category_id&quot;                 select=&quot;site.alanliang.geekblog.mapper.ArticleMapper.selectCategoryById&quot;/&gt;\n\n&lt;/resultMap&gt;\n</code></pre>\n<p>中可发现还需要映射的属性有category，因此此时Mybatis会根据column属性的值，也就是对应Article表中的字段名（外键）category_id，拿到之前查出来的 category_id（这里是7），然后在把id值传到select属性对应的语句中：</p>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;selectCategoryById&quot; resultType=&quot;site.alanliang.geekblog.domain.Category&quot;&gt;\n    select id, name from t_category where id = #{id}\n&lt;/select&gt;\n</code></pre>\n<p>接着发送这条SQL语句，返回结果后映射至category对象中id和name属性，最后完成所有属性的映射。</p>\n<ul>\n<li>基于SQL表连接</li></ul>\n<p>这个比较好理解，直接就是多表连接查询。需要注意的是，当两个表中存在字段名一样的时候，需要给表起别名，我这里Article和Category的主键名字都是id，所以分别起了别名ta和tc，否则没有办法映射，Mybatis会报错。</p>\n<h2 id=\"h2-u6027u80FDu5BF9u6BD4\"><a name=\"性能对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>性能对比</h2><p>首先我们先了解一下数据库表的结构和对应POJO对象：</p>\n<h3 id=\"h3--\"><a name=\"数据库表结构如下：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据库表结构如下：</h3><p><img src=\"http://cdn.alanliang.site/note/2.png\" alt=\"avatat\"></p>\n<h3 id=\"h3-pojo-article-\"><a name=\"POJO - Article(文章)如下：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>POJO - Article(文章)如下：</h3><pre><code class=\"lang-java\">@Data\n@TableName(&quot;t_article&quot;)\npublic class Article {\n    @TableId(type = IdType.AUTO)\n    private Long id;\n    ...\n    @TableField(exist = false)\n    private Category category;\n\n    @TableField(exist = false)\n    private List&lt;Tag&gt; tagList;\n}\n</code></pre>\n<h3 id=\"h3-pojo-category-\"><a name=\"POJO - Category(分类)如下：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>POJO - Category(分类)如下：</h3><pre><code class=\"lang-java\">@Data\n@TableName(&quot;t_category&quot;)\npublic class Category {\n    @TableId(type = IdType.AUTO)\n    private Long id;\n\n    private String name;\n    ...\n}\n</code></pre>\n<h3 id=\"h3-pojo-tag-\"><a name=\"POJO - Tag(标签)如下：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>POJO - Tag(标签)如下：</h3><pre><code class=\"lang-java\">@Data\n@TableName(&quot;t_tag&quot;)\npublic class Tag {\n    @TableId(type = IdType.AUTO)\n    private Long id;\n\n    private String name;\n\n    ...\n}\n</code></pre>\n<h3 id=\"h3-pojo-articletag-\"><a name=\"POJO - ArticleTag(文章标签关联)如下：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>POJO - ArticleTag(文章标签关联)如下：</h3><pre><code class=\"lang-java\">@Data\n@TableName(&quot;t_article_tag&quot;)\npublic class ArticleTag {\n    @TableId\n    private Long articleId;\n    @TableId\n    private Long tagId;\n}\n</code></pre>\n<p>需要特别说明一下的是，这里用到的<code><a href=\"https://github.com/Data\" title=\"&#64;Data\" class=\"at-link\">@Data</a></code>注解是一个叫lombok的插件提供的，使用这个注解作用在类上可以帮我们生成类的getter和setter方法等，因此代码中不需要写getter和setter。然后，为了简化，我把无关的属性剔除了。最后，<code><a href=\"https://github.com/TableName\" title=\"&#64;TableName\" class=\"at-link\">@TableName</a></code>、<code><a href=\"https://github.com/TableId\" title=\"&#64;TableId\" class=\"at-link\">@TableId</a></code>和 <code><a href=\"https://github.com/TableField\" title=\"&#64;TableField\" class=\"at-link\">@TableField</a></code>是MyBatisPlus提供的注解，其中<code><a href=\"https://github.com/TableName\" title=\"&#64;TableName\" class=\"at-link\">@TableName</a>(&quot;t_article&quot;)</code>指明该实体类(Article)对应数据库表t_article，<code><a href=\"https://github.com/TableId\" title=\"&#64;TableId\" class=\"at-link\">@TableId</a>(type = IdType.AUTO)</code>指定该属性(id)是对应表的注解，主键策略为ID自增。<code><a href=\"https://github.com/TableField\" title=\"&#64;TableField\" class=\"at-link\">@TableField</a>(exist = false)</code>指明该属性在表中没有对应的字段，详细说明可以查看MybatisPlus官方文档 <a href=\"https://mp.baomidou.com/guide/annotation.html\">https://mp.baomidou.com/guide/annotation.html</a></p>\n<p>从数据库结构中，我们很明显可以看到，文章(t_article)和分类(t_category)是多对一的关系，文章(t_article)和标签(t_tag)是一对多的关系，那么在配置文章的mapper文件(ArticleMapper)时可以这样配置，代码如下：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;site.alanliang.geekblog.mapper.ArticleMapper&quot;&gt;\n    &lt;resultMap id=&quot;adminListResultMap&quot; type=&quot;site.alanliang.geekblog.domain.Article&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n           ...\n        &lt;association property=&quot;category&quot; column=&quot;category_id&quot;\n                     select=&quot;site.alanliang.geekblog.mapper.CategoryMapper.selectByCid&quot;/&gt;\n        &lt;collection property=&quot;tagList&quot; column=&quot;id&quot; select=&quot;site.alanliang.geekblog.mapper.TagMapper.selectByArticleId&quot;/&gt;\n    &lt;/resultMap&gt;\n&lt;/mapper&gt;\n</code></pre>\n<p>其中\\&lt;association\\&gt;标签配置了Article与Category的级联关系，\\&lt;collection\\&gt;配置了Article与Tag的级联关系。说到级联我们先了解一下它的概念：</p>\n<p>级联是一个数据库实体的概念。比如文章就需要存在标签与之对应，这样就有了文章标签表，一篇文章可能有多个标签，这就是一对多的级联；除此之外，还有一对一的级联，比如身份证和公民是一对一的关系。</p>\n<p>级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统复杂度，同时降低系统的性能。</p>\n<p>Mybatis中有3种级联：</p>\n<ul>\n<li>鉴别器：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分。这里我们不讨论。</li><li>一对一（association）：比如学生证和学生就是一种一对一的级联，雇员和工牌表也是一种一对一级联。</li><li>一对多（collection）：比如班级和学生就是一种一对多的级联。</li></ul>\n<p>看到这里，有的小伙伴可能会疑惑，既然文章和分类是多对一关系，为啥用association？其实这里是站在文章的角度看的，一篇文章就对应一个分类，这不就是一对一级联关系了吗，但是站在分类的角度上看，一个分类有多篇文章，这就是一对多级联关系，在代码中就需要用到collection。总而言之，当POJO类中，其中一个属性是另外一个类的引用，这就需要association级联，而一个属性是一个集合的时候，这就需要collection级联。</p>\n<p>关键来了，前面提到，级联方式有两种，一种是分层查询，一种是连接查询。那么对t_article进行全表查询，而且还需要查询Article的category和tagList，那么究竟哪个更快呢？假设有100个Article，1个Article有1个Category，1个Article有3个Tag，那么根据N+1问题，查询所有数据需要201条SQL（查询所有Article只需要1条，而查询Article的Category和Tag分别需要100条），而连接查询只需要1条，但是将4个表连接起来查询（t_article，t_category，t_article_tag, t_tag）规模好像也不小，感觉也不会太快，本人弱鸡不懂SQL底层，所以没有直观感觉。只好做一个测试：</p>\n<ul>\n<li>分层查询</li></ul>\n<pre><code class=\"lang-xml\">&lt;resultMap id=&quot;resultMap1&quot; type=&quot;site.alanliang.geekblog.domain.Article&quot;&gt;\n    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;\n    &lt;association property=&quot;category&quot; column=&quot;category_id&quot;\n               select=&quot;site.alanliang.geekblog.mapper.ArticleMapper.selectCategoryById&quot;/&gt;\n    &lt;collection property=&quot;tagList&quot; column=&quot;id&quot;                          select=&quot;site.alanliang.geekblog.mapper.ArticleMapper.listTagsByArticleId&quot;/&gt;\n&lt;/resultMap&gt;\n\n&lt;select id=&quot;selectCategoryById&quot; resultType=&quot;site.alanliang.geekblog.domain.Category&quot;&gt;\n    select id, name from t_category where id = #{id}\n&lt;/select&gt;\n\n&lt;select id=&quot;listTagsByArticleId&quot; resultType=&quot;site.alanliang.geekblog.domain.Tag&quot;&gt;\n    select tt.id, tt.name\n    from t_tag tt\n    left join t_article_tag tat\n    on tt.id = tat.tag_id\n    where tat.article_id = #{articleId}\n&lt;/select&gt;\n\n&lt;select id=&quot;listArticles1&quot; resultMap=&quot;resultMap1&quot;&gt;\n    select id, title, category_id\n    from t_article\n&lt;/select&gt;\n</code></pre>\n<pre><code class=\"lang-java\">@Test\nvoid listArticles1(){\n    long startTime = System.currentTimeMillis();\n    List&lt;Article&gt; articles = articleMapper.listArticles1();\n    long endTime = System.currentTimeMillis();\n    System.out.println(&quot;-----执行时间为&quot;+(endTime-startTime)+&quot;ms-----&quot;);\n    System.out.println(articles);\n}\n</code></pre>\n<p>3次执行结果：</p>\n<pre><code>-----执行时间为146ms-----\n-----执行时间为143ms-----\n-----执行时间为140ms-----\n</code></pre><ul>\n<li>分层查询</li></ul>\n<pre><code class=\"lang-xml\">&lt;resultMap id=&quot;resultMap2&quot; type=&quot;site.alanliang.geekblog.domain.Article&quot;&gt;\n    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;\n    &lt;association property=&quot;category&quot; javaType=&quot;site.alanliang.geekblog.domain.Category&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;\n    &lt;/association&gt;\n    &lt;collection property=&quot;tagList&quot; ofType=&quot;site.alanliang.geekblog.domain.Tag&quot;&gt;\n        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;\n        &lt;id property=&quot;name&quot; column=&quot;name&quot;/&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n</code></pre>\n<pre><code class=\"lang-xml\">&lt;select id=&quot;listArticles2&quot; resultMap=&quot;resultMap2&quot;&gt;\n    select ta.id, ta.title, ta.type, ta.comments, ta.views, ta.likes, ta.published, ta.appreciable, ta.commentable, ta.top, ta.recommend, ta.create_time, ta.update_time,\n    tc.id, tc.name, tt.id, tt.name\n    from t_article ta\n    inner join t_category tc\n    on ta.category_id = tc.id\n    inner join t_article_tag tat\n    on ta.id = tat.article_id\n    inner join t_tag tt\n    on tat.tag_id = tt.id\n&lt;/select&gt;\n</code></pre>\n<pre><code class=\"lang-java\">@Test\nvoid listArticles2(){\n    long startTime = System.currentTimeMillis();\n    List&lt;Article&gt; articles = articleMapper.listArticles2();\n    long endTime = System.currentTimeMillis();\n    System.out.println(&quot;-----执行时间为&quot;+(endTime-startTime)+&quot;ms-----&quot;);\n    System.out.println(articles);\n}\n</code></pre>\n<pre><code>-----执行时间为99ms-----\n-----执行时间为112ms-----\n-----执行时间为97ms-----\n</code></pre><p>这里的数据确保了每个Article都只有1个Category，每个Article都至少有1个Tag。可以看出连接查询比分层查询快了50%左右。</p>\n<p>原来的数据是我项目里，记录总共大概只有二三十多条，为了进一步测试，所以再增加记录1000条。</p>\n<p>分层查询的时间分别是：</p>\n<pre><code>-----执行时间为2187ms-----\n-----执行时间为2275ms-----\n-----执行时间为2165ms-----\n</code></pre><p>连接查询的时间分别是：</p>\n<pre><code>-----执行时间为230ms-----\n-----执行时间为188ms-----\n-----执行时间为186ms-----\n</code></pre><p>这里的差距就很明显了，连接查询所需要的时间只需要分层查询的10%，可以看出需要查询所有数据，进行全表关联查询时，连接查询方式速度更快。但是连接查询有个很明显的缺点，就是SQL语句复杂，日后维护起来比较困难。</p>\n<h2 id=\"h2-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h2><ul>\n<li><p>分层查询</p>\n<p>优点：SQL语句简单，容易理解和维护；</p>\n<p>缺点：存在N+1问题，在进行大量数据查询时效率慢（当然这可以通过延迟加载和分页等进行优化）</p>\n</li><li><p>连接查询</p>\n<p>优点：消除了N+1问题，在进行大量数据查询时效率比较高</p>\n<p>缺点：SQL语句复杂，不易理解和维护。</p>\n</li></ul>\n<p>总而言之，连接查询一般用于那些比较简单且关联不多的场景下，在这种场景下效率更高。而分层查询获取关联数据十分便捷，但如果层次过多也会增加系统的复杂度，同时降低系统的性能，一般当级联的层级超过3层时就不考虑使用级联了，因为这样会造成多个对象的关联，导致系统的耦合、复杂和难以维护，在现实的使用过程中，要根据实际情况判断使用。按照我的理解，分层查询像一棵树的层次遍历，复杂度随着层次纵向增加而快速增加。而连接查询的复杂度随着表数量的增加而横向扩展。具体使用还需要结合实际情况。</p>\n<p>以上结论均基于个人的理解和总结，如果有不当之处还望指正！</p>\n', '\n##基本介绍\n\n最近在做一个基于SpringBoot+MybatisPlus博客系统的项目，在管理后台需要列出所有文章，效果是这样的：\n\n![avatar](http://cdn.alanliang.site/note/1.png)\n\n注意红色部分，查出文章的信息时，还需要查文章的分类和文章的标签。这很容易想到需要使用Mybatis的级联查询，但是在写mapper文件代码的时候，想到级联其实有两种方式：\n\n- 基于分层次查询的\n- 基于SQL表连接的\n\n这样说，大家可能会觉得云里雾里的，啥叫分层次的，啥又叫SQL表连接的，这里给出代码，想必平时使用过Mybatis的小伙伴就会明白了。\n\n- 基于分层次查询的\n\n```xml\n<resultMap id=\"resultMap1\" type=\"site.alanliang.geekblog.domain.Article\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"title\" column=\"title\"/>\n    \n    <association property=\"category\" column=\"category_id\"                 select=\"site.alanliang.geekblog.mapper.ArticleMapper.selectCategoryById\"/>\n    \n</resultMap>\n\n<select id=\"selectCategoryById\" resultType=\"site.alanliang.geekblog.domain.Category\">\n    select id, name from t_category where id = #{id}\n</select>\n\n<select id=\"selectArticleById1\" parameterType=\"long\" resultMap=\"resultMap1\">\n    select id, title, category_id from t_article where id = #{id}\n</select>\n```\n\n- 基于SQL表连接的\n\n```xml\n<resultMap id=\"resultMap2\" type=\"site.alanliang.geekblog.domain.Article\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"title\" column=\"title\"/>\n    \n    <association property=\"category\" javaType=\"site.alanliang.geekblog.domain.Category\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"name\" column=\"name\"/>\n    </association>\n    \n</resultMap>\n\n<select id=\"selectArticleById2\" parameterType=\"long\" resultMap=\"resultMap2\">\n    select ta.id, ta.title, tc.id, tc.name\n    from t_article ta\n    inner join t_category tc\n    on ta.category_id = tc.id\n    where ta.id = #{aid}\n</select>\n```\n\n注意association和select标签的区别。我平时比较粗心，根本没在意它们的区别，但是这次做项目的时候再次碰到，这次才引起了我的注意，也激起了我的好奇心，究竟它们的区别在哪呢？\n\n查过资料后，我终于明白了：\n\n分层次查询的方式是单表查询，首先发送1条SQL查询文章(Article)的信息，然后查询文章的分类(category)时再发送1条SQL，也就是查询1条文章记录需要发送2条SQL。\n\n基于SQL表连接的方式是多表查询，在这里也就是Article表和Category表连接查询，只需要发送1条SQL。\n\n我们做个测试，测试代码如下：\n\n```java\n@Autowired\nprivate ArticleMapper articleMapper;\n\n@Test\nvoid selectArticleById1(){\n    Article article = articleMapper.selectArticleById1(7L);\n    System.out.println(article);\n}\n\n@Test\nvoid selectArticleById2(){\n    Article article = articleMapper.selectArticleById2(7L);\n    System.out.println(article);\n}\n```\n\n测试结果如下：\n\n![avatar](http://cdn.alanliang.site/note/3.png)\n\n![avatar](http://cdn.alanliang.site/note/4.png)\n\n结果显而易见。\n\n## 过程分析\n\n- 基于分层次查询\n\n我认为的大致过程是这样的。首先，测试中执行代码：\n\n```java\n Article article = articleMapper.selectArticleById1(7L);\n```\n\nMybatis会找到相应mapper文件中的这部分代码：\n\n```xml\n<select id=\"selectArticleById1\" parameterType=\"long\" resultMap=\"resultMap1\">\n    select id, title, category_id from t_article where id = #{id}\n</select>\n```\n\nMybatis发送完这条SQL语句，查询到字段id，title和category_id。将字段id和title映射至resultMap1中的相应属性，category_id后面会用到（注意！SQL语句中不能缺少这个字段，否则将查不到对应的category）而resultMap1中代码：\n\n```xml\n<resultMap id=\"resultMap1\" type=\"site.alanliang.geekblog.domain.Article\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"title\" column=\"title\"/>\n    \n    <association property=\"category\" column=\"category_id\"                 select=\"site.alanliang.geekblog.mapper.ArticleMapper.selectCategoryById\"/>\n    \n</resultMap>\n```\n\n中可发现还需要映射的属性有category，因此此时Mybatis会根据column属性的值，也就是对应Article表中的字段名（外键）category_id，拿到之前查出来的 category_id（这里是7），然后在把id值传到select属性对应的语句中：\n\n```xml\n<select id=\"selectCategoryById\" resultType=\"site.alanliang.geekblog.domain.Category\">\n    select id, name from t_category where id = #{id}\n</select>\n```\n\n接着发送这条SQL语句，返回结果后映射至category对象中id和name属性，最后完成所有属性的映射。\n\n- 基于SQL表连接\n\n这个比较好理解，直接就是多表连接查询。需要注意的是，当两个表中存在字段名一样的时候，需要给表起别名，我这里Article和Category的主键名字都是id，所以分别起了别名ta和tc，否则没有办法映射，Mybatis会报错。\n\n##性能对比\n\n首先我们先了解一下数据库表的结构和对应POJO对象：\n\n###数据库表结构如下：\n\n![avatat](http://cdn.alanliang.site/note/2.png)\n\n###POJO - Article(文章)如下：\n\n```java\n@Data\n@TableName(\"t_article\")\npublic class Article {\n    @TableId(type = IdType.AUTO)\n    private Long id;\n	...\n    @TableField(exist = false)\n    private Category category;\n    \n    @TableField(exist = false)\n    private List<Tag> tagList;\n}\n\n```\n\n### POJO - Category(分类)如下：\n\n```java\n@Data\n@TableName(\"t_category\")\npublic class Category {\n    @TableId(type = IdType.AUTO)\n    private Long id;\n    \n    private String name;\n    ...\n}\n\n```\n\n### POJO - Tag(标签)如下：\n\n```java\n@Data\n@TableName(\"t_tag\")\npublic class Tag {\n    @TableId(type = IdType.AUTO)\n    private Long id;\n\n    private String name;\n	\n    ...\n}\n\n```\n\n### POJO - ArticleTag(文章标签关联)如下：\n\n```java\n@Data\n@TableName(\"t_article_tag\")\npublic class ArticleTag {\n    @TableId\n    private Long articleId;\n    @TableId\n    private Long tagId;\n}\n\n```\n\n需要特别说明一下的是，这里用到的`@Data`注解是一个叫lombok的插件提供的，使用这个注解作用在类上可以帮我们生成类的getter和setter方法等，因此代码中不需要写getter和setter。然后，为了简化，我把无关的属性剔除了。最后，`@TableName`、`@TableId`和 `@TableField`是MyBatisPlus提供的注解，其中`@TableName(\"t_article\")`指明该实体类(Article)对应数据库表t_article，`@TableId(type = IdType.AUTO)`指定该属性(id)是对应表的注解，主键策略为ID自增。`@TableField(exist = false)`指明该属性在表中没有对应的字段，详细说明可以查看MybatisPlus官方文档 https://mp.baomidou.com/guide/annotation.html\n\n从数据库结构中，我们很明显可以看到，文章(t_article)和分类(t_category)是多对一的关系，文章(t_article)和标签(t_tag)是一对多的关系，那么在配置文章的mapper文件(ArticleMapper)时可以这样配置，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"site.alanliang.geekblog.mapper.ArticleMapper\">\n    <resultMap id=\"adminListResultMap\" type=\"site.alanliang.geekblog.domain.Article\">\n        <id property=\"id\" column=\"id\"/>\n       	...\n        <association property=\"category\" column=\"category_id\"\n                     select=\"site.alanliang.geekblog.mapper.CategoryMapper.selectByCid\"/>\n        <collection property=\"tagList\" column=\"id\" select=\"site.alanliang.geekblog.mapper.TagMapper.selectByArticleId\"/>\n    </resultMap>\n</mapper>\n```\n\n其中\\<association\\>标签配置了Article与Category的级联关系，\\<collection\\>配置了Article与Tag的级联关系。说到级联我们先了解一下它的概念：\n\n级联是一个数据库实体的概念。比如文章就需要存在标签与之对应，这样就有了文章标签表，一篇文章可能有多个标签，这就是一对多的级联；除此之外，还有一对一的级联，比如身份证和公民是一对一的关系。\n\n级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统复杂度，同时降低系统的性能。\n\nMybatis中有3种级联：\n\n- 鉴别器：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分。这里我们不讨论。\n- 一对一（association）：比如学生证和学生就是一种一对一的级联，雇员和工牌表也是一种一对一级联。\n- 一对多（collection）：比如班级和学生就是一种一对多的级联。\n\n看到这里，有的小伙伴可能会疑惑，既然文章和分类是多对一关系，为啥用association？其实这里是站在文章的角度看的，一篇文章就对应一个分类，这不就是一对一级联关系了吗，但是站在分类的角度上看，一个分类有多篇文章，这就是一对多级联关系，在代码中就需要用到collection。总而言之，当POJO类中，其中一个属性是另外一个类的引用，这就需要association级联，而一个属性是一个集合的时候，这就需要collection级联。\n\n关键来了，前面提到，级联方式有两种，一种是分层查询，一种是连接查询。那么对t_article进行全表查询，而且还需要查询Article的category和tagList，那么究竟哪个更快呢？假设有100个Article，1个Article有1个Category，1个Article有3个Tag，那么根据N+1问题，查询所有数据需要201条SQL（查询所有Article只需要1条，而查询Article的Category和Tag分别需要100条），而连接查询只需要1条，但是将4个表连接起来查询（t_article，t_category，t_article_tag, t_tag）规模好像也不小，感觉也不会太快，本人弱鸡不懂SQL底层，所以没有直观感觉。只好做一个测试：\n\n- 分层查询\n\n```xml\n<resultMap id=\"resultMap1\" type=\"site.alanliang.geekblog.domain.Article\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"title\" column=\"title\"/>\n    <association property=\"category\" column=\"category_id\"\n               select=\"site.alanliang.geekblog.mapper.ArticleMapper.selectCategoryById\"/>\n    <collection property=\"tagList\" column=\"id\" 		             	select=\"site.alanliang.geekblog.mapper.ArticleMapper.listTagsByArticleId\"/>\n</resultMap>\n\n<select id=\"selectCategoryById\" resultType=\"site.alanliang.geekblog.domain.Category\">\n    select id, name from t_category where id = #{id}\n</select>\n\n<select id=\"listTagsByArticleId\" resultType=\"site.alanliang.geekblog.domain.Tag\">\n    select tt.id, tt.name\n    from t_tag tt\n    left join t_article_tag tat\n    on tt.id = tat.tag_id\n    where tat.article_id = #{articleId}\n</select>\n\n<select id=\"listArticles1\" resultMap=\"resultMap1\">\n    select id, title, category_id\n    from t_article\n</select>\n```\n\n```java\n@Test\nvoid listArticles1(){\n    long startTime = System.currentTimeMillis();\n    List<Article> articles = articleMapper.listArticles1();\n    long endTime = System.currentTimeMillis();\n    System.out.println(\"-----执行时间为\"+(endTime-startTime)+\"ms-----\");\n    System.out.println(articles);\n}\n```\n\n3次执行结果：\n\n```\n-----执行时间为146ms-----\n-----执行时间为143ms-----\n-----执行时间为140ms-----\n```\n\n- 分层查询\n\n```xml\n<resultMap id=\"resultMap2\" type=\"site.alanliang.geekblog.domain.Article\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"title\" column=\"title\"/>\n    <association property=\"category\" javaType=\"site.alanliang.geekblog.domain.Category\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"name\" column=\"name\"/>\n    </association>\n    <collection property=\"tagList\" ofType=\"site.alanliang.geekblog.domain.Tag\">\n        <id property=\"id\" column=\"id\"/>\n        <id property=\"name\" column=\"name\"/>\n    </collection>\n</resultMap>\n```\n\n```xml\n<select id=\"listArticles2\" resultMap=\"resultMap2\">\n    select ta.id, ta.title, ta.type, ta.comments, ta.views, ta.likes, ta.published, ta.appreciable, ta.commentable, ta.top, ta.recommend, ta.create_time, ta.update_time,\n    tc.id, tc.name, tt.id, tt.name\n    from t_article ta\n    inner join t_category tc\n    on ta.category_id = tc.id\n    inner join t_article_tag tat\n    on ta.id = tat.article_id\n    inner join t_tag tt\n    on tat.tag_id = tt.id\n</select>\n```\n\n```java\n@Test\nvoid listArticles2(){\n    long startTime = System.currentTimeMillis();\n    List<Article> articles = articleMapper.listArticles2();\n    long endTime = System.currentTimeMillis();\n    System.out.println(\"-----执行时间为\"+(endTime-startTime)+\"ms-----\");\n    System.out.println(articles);\n}\n```\n\n```\n-----执行时间为99ms-----\n-----执行时间为112ms-----\n-----执行时间为97ms-----\n```\n\n这里的数据确保了每个Article都只有1个Category，每个Article都至少有1个Tag。可以看出连接查询比分层查询快了50%左右。\n\n原来的数据是我项目里，记录总共大概只有二三十多条，为了进一步测试，所以再增加记录1000条。\n\n分层查询的时间分别是：\n\n```\n-----执行时间为2187ms-----\n-----执行时间为2275ms-----\n-----执行时间为2165ms-----\n```\n\n连接查询的时间分别是：\n\n```\n-----执行时间为230ms-----\n-----执行时间为188ms-----\n-----执行时间为186ms-----\n```\n\n这里的差距就很明显了，连接查询所需要的时间只需要分层查询的10%，可以看出需要查询所有数据，进行全表关联查询时，连接查询方式速度更快。但是连接查询有个很明显的缺点，就是SQL语句复杂，日后维护起来比较困难。\n\n## 总结\n\n- 分层查询\n\n  优点：SQL语句简单，容易理解和维护；\n\n  缺点：存在N+1问题，在进行大量数据查询时效率慢（当然这可以通过延迟加载和分页等进行优化）\n\n- 连接查询\n\n  优点：消除了N+1问题，在进行大量数据查询时效率比较高\n\n  缺点：SQL语句复杂，不易理解和维护。\n\n总而言之，连接查询一般用于那些比较简单且关联不多的场景下，在这种场景下效率更高。而分层查询获取关联数据十分便捷，但如果层次过多也会增加系统的复杂度，同时降低系统的性能，一般当级联的层级超过3层时就不考虑使用级联了，因为这样会造成多个对象的关联，导致系统的耦合、复杂和难以维护，在现实的使用过程中，要根据实际情况判断使用。按照我的理解，分层查询像一棵树的层次遍历，复杂度随着层次纵向增加而快速增加。而连接查询的复杂度随着表数量的增加而横向扩展。具体使用还需要结合实际情况。\n\n以上结论均基于个人的理解和总结，如果有不当之处还望指正！\n\n', 'http://cdn.alanliang.site/landscape5.jpg', 1, 0, 0, 0, b'0', b'1', b'1', b'0', b'1', 4, 3, 6, 2, '2020-06-15 16:03:02', '2020-06-15 16:03:02');

-- ----------------------------
-- Table structure for t_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag`;
CREATE TABLE `t_article_tag`  (
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `tag_id` bigint(20) NOT NULL COMMENT '标签ID',
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE,
  INDEX `fk_tag_tagid`(`tag_id`) USING BTREE,
  CONSTRAINT `fk_article_articleid` FOREIGN KEY (`article_id`) REFERENCES `t_article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_tag_tagid` FOREIGN KEY (`tag_id`) REFERENCES `t_tag` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_article_tag
-- ----------------------------
INSERT INTO `t_article_tag` VALUES (1, 12);
INSERT INTO `t_article_tag` VALUES (2, 12);
INSERT INTO `t_article_tag` VALUES (3, 12);
INSERT INTO `t_article_tag` VALUES (4, 12);
INSERT INTO `t_article_tag` VALUES (5, 12);
INSERT INTO `t_article_tag` VALUES (6, 12);
INSERT INTO `t_article_tag` VALUES (7, 12);
INSERT INTO `t_article_tag` VALUES (8, 12);
INSERT INTO `t_article_tag` VALUES (9, 12);
INSERT INTO `t_article_tag` VALUES (10, 12);
INSERT INTO `t_article_tag` VALUES (11, 12);
INSERT INTO `t_article_tag` VALUES (13, 12);
INSERT INTO `t_article_tag` VALUES (1, 13);
INSERT INTO `t_article_tag` VALUES (7, 13);
INSERT INTO `t_article_tag` VALUES (1, 14);
INSERT INTO `t_article_tag` VALUES (8, 14);
INSERT INTO `t_article_tag` VALUES (9, 14);
INSERT INTO `t_article_tag` VALUES (1, 15);
INSERT INTO `t_article_tag` VALUES (3, 15);
INSERT INTO `t_article_tag` VALUES (4, 15);
INSERT INTO `t_article_tag` VALUES (5, 15);
INSERT INTO `t_article_tag` VALUES (6, 15);
INSERT INTO `t_article_tag` VALUES (10, 15);
INSERT INTO `t_article_tag` VALUES (13, 15);
INSERT INTO `t_article_tag` VALUES (1, 16);
INSERT INTO `t_article_tag` VALUES (2, 17);
INSERT INTO `t_article_tag` VALUES (2, 18);
INSERT INTO `t_article_tag` VALUES (3, 19);
INSERT INTO `t_article_tag` VALUES (4, 20);
INSERT INTO `t_article_tag` VALUES (5, 21);
INSERT INTO `t_article_tag` VALUES (6, 22);
INSERT INTO `t_article_tag` VALUES (7, 23);
INSERT INTO `t_article_tag` VALUES (9, 24);
INSERT INTO `t_article_tag` VALUES (10, 25);
INSERT INTO `t_article_tag` VALUES (11, 25);
INSERT INTO `t_article_tag` VALUES (10, 26);
INSERT INTO `t_article_tag` VALUES (12, 27);

-- ----------------------------
-- Table structure for t_category
-- ----------------------------
DROP TABLE IF EXISTS `t_category`;
CREATE TABLE `t_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名称',
  `display` bit(1) NULL DEFAULT NULL COMMENT '是否前台显示',
  `introduction` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `color` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '颜色',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_t_category_name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_category
-- ----------------------------
INSERT INTO `t_category` VALUES (1, '读书笔记', b'1', '-', '#D5F5E3', '2020-06-14 19:34:04', '2020-06-14 19:34:04');
INSERT INTO `t_category` VALUES (2, '错误日志', b'1', '-', '#E8F8F5', '2020-06-14 19:34:33', '2020-06-14 19:34:33');
INSERT INTO `t_category` VALUES (3, '项目总结', b'1', '-', '#82E0AA', '2020-06-14 19:34:53', '2020-06-14 19:34:53');
INSERT INTO `t_category` VALUES (4, '工具技巧', b'1', '-', '#A3E4D7', '2020-06-14 19:35:10', '2020-06-14 19:35:10');
INSERT INTO `t_category` VALUES (5, '他人优秀笔记', b'1', '-', '#FEF9E7', '2020-06-14 19:35:30', '2020-06-14 19:35:30');
INSERT INTO `t_category` VALUES (6, '思考感悟', b'1', '-', '#85C1E9', '2020-06-14 19:35:42', '2020-06-14 19:35:42');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `pid` bigint(20) NOT NULL COMMENT '父级评论ID',
  `article_id` bigint(20) NULL DEFAULT NULL COMMENT '文章ID',
  `visitor_id` bigint(20) NULL DEFAULT NULL COMMENT '访客ID',
  `user_id` bigint(20) NULL DEFAULT NULL COMMENT '用户ID',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '审核状态[0:审核未过, 1:等待审核, 2:审核通过]',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `browser` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `os` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '系统',
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'IP来源',
  `request_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '请求IP',
  `parent_nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '父级评论昵称',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_comment_article`(`article_id`) USING BTREE,
  INDEX `fk_comment_user`(`user_id`) USING BTREE,
  INDEX `fk_comment_visitor`(`visitor_id`) USING BTREE,
  INDEX `idx_comment_createTime`(`create_time`) USING BTREE,
  CONSTRAINT `fk_comment_article` FOREIGN KEY (`article_id`) REFERENCES `t_article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_comment_user` FOREIGN KEY (`user_id`) REFERENCES `sys_user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_comment_visitor` FOREIGN KEY (`visitor_id`) REFERENCES `t_visitor` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (1, 0, 9, 7, NULL, '这是一条正儿八经的评论！', 1, '2020-06-15 16:20:20', 'Chrome 8', 'Windows 10', '内网IP', '0:0:0:0:0:0:0:1', '');
INSERT INTO `t_comment` VALUES (2, 1, 9, 8, NULL, '这也是一条正儿八经的回复！', 1, '2020-06-15 16:35:59', 'Chrome 8', 'Windows 10', '内网IP', '0:0:0:0:0:0:0:1', '张三');

-- ----------------------------
-- Table structure for t_link
-- ----------------------------
DROP TABLE IF EXISTS `t_link`;
CREATE TABLE `t_link`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `introduction` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `link` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '网址',
  `sort` smallint(4) NULL DEFAULT NULL COMMENT '排序值',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '审核状态[0:审核未过, 1:等待审核, 2:审核通过',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_link_sort`(`sort`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 24 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_link
-- ----------------------------
INSERT INTO `t_link` VALUES (21, '码酱', 'http://image.luokangyuan.com/1_qq_27922023.jpg', '我不是大佬，只是在追寻大佬的脚步', 'http://luokangyuan.com/', 1, 2, '2020-06-15 16:51:19', '2020-06-15 16:51:19');
INSERT INTO `t_link` VALUES (22, '码农', 'http://static.blinkfox.com/20190601.png', '这里不隐含扭曲的价值观，而是整合并充盈正能量', 'https://www.90c.vip/', 2, 2, '2020-06-15 16:52:42', '2020-06-15 16:52:42');
INSERT INTO `t_link` VALUES (23, '洪卫の博客', 'http://static.blinkfox.com/2019/11/23/avatar2.png', '凭寄狂夫书一纸，信在成都万里桥。', 'https://sunhwee.com/', 3, 2, '2020-06-15 16:53:55', '2020-06-15 16:53:55');

-- ----------------------------
-- Table structure for t_message
-- ----------------------------
DROP TABLE IF EXISTS `t_message`;
CREATE TABLE `t_message`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `pid` bigint(20) NOT NULL COMMENT '父级留言ID',
  `user_id` bigint(20) NULL DEFAULT NULL COMMENT '用户ID(用户或者访客)',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '内容',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `link` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '网址',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '审核状态[0:审核未过, 1:等待审核, 2:审核通过',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `browser` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `os` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '系统',
  `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'IP来源',
  `request_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '请求IP',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_message_email`(`email`) USING BTREE,
  INDEX `idx_message_createTime`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 47 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_message
-- ----------------------------
INSERT INTO `t_message` VALUES (44, 0, NULL, '这是一条正儿八经的留言！', '李四', 'http://www.alanliang.site', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', 'm13415418397@163.com', 1, '2020-06-15 16:42:00', 'Chrome 8', 'Windows 10', '内网IP', '0:0:0:0:0:0:0:1');
INSERT INTO `t_message` VALUES (45, 0, NULL, '这也是一条正儿八经的留言！', '张三', '', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', '1114173646@qq.com', 1, '2020-06-15 16:45:05', 'Chrome 8', 'Windows 10', '内网IP', '0:0:0:0:0:0:0:1');
INSERT INTO `t_message` VALUES (46, 0, NULL, '测试评论1！', '王五', '', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', 'm18600000001@163com', 1, '2020-06-15 16:47:46', 'Chrome 8', 'Windows 10', '内网IP', '0:0:0:0:0:0:0:1');

-- ----------------------------
-- Table structure for t_photo
-- ----------------------------
DROP TABLE IF EXISTS `t_photo`;
CREATE TABLE `t_photo`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `sort` smallint(4) NULL DEFAULT NULL COMMENT '排序值',
  `display` bit(1) NULL DEFAULT NULL COMMENT '是否前台显示',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_photo_sort`(`sort`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_photo
-- ----------------------------
INSERT INTO `t_photo` VALUES (9, 'http://cdn.alanliang.site/note/oilpainting1.jpg', '油画1', 1, b'1', '2020-06-15 16:55:15', '2020-06-15 16:55:15');
INSERT INTO `t_photo` VALUES (10, 'http://cdn.alanliang.site/note/oilpainting2.jpg', '油画2', 2, b'1', '2020-06-15 16:55:36', '2020-06-15 16:55:36');
INSERT INTO `t_photo` VALUES (11, 'http://cdn.alanliang.site/note/oilpainting3.jpg', '油画3', 3, b'1', '2020-06-15 16:55:50', '2020-06-15 16:55:50');
INSERT INTO `t_photo` VALUES (12, 'http://cdn.alanliang.site/note/oilpainting4.jpg', '油画4', 4, b'1', '2020-06-15 16:56:08', '2020-06-15 16:56:08');
INSERT INTO `t_photo` VALUES (13, 'http://cdn.alanliang.site/note/oilpainting5.jpg', '油画5', 5, b'1', '2020-06-15 16:56:30', '2020-06-15 16:56:30');
INSERT INTO `t_photo` VALUES (14, 'http://cdn.alanliang.site/note/oilpainting6.jpg', '油画6', 6, b'1', '2020-06-15 16:56:43', '2020-06-15 16:56:43');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名称',
  `color` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '颜色',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_t_tag_name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 28 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (12, 'JavaEE', '#D5F5E3', '2020-06-14 19:39:08', '2020-06-14 19:39:08');
INSERT INTO `t_tag` VALUES (13, 'Spring', '#E8F8F5', '2020-06-14 19:40:03', '2020-06-15 08:55:32');
INSERT INTO `t_tag` VALUES (14, 'SpringMVC', '#82E0AA', '2020-06-15 08:54:38', '2020-06-15 08:55:57');
INSERT INTO `t_tag` VALUES (15, 'Mybatis', '#A3E4D7', '2020-06-15 08:54:38', '2020-06-15 08:57:10');
INSERT INTO `t_tag` VALUES (16, 'Redis', '#FEF9E7', '2020-06-15 08:54:38', '2020-06-15 08:57:22');
INSERT INTO `t_tag` VALUES (17, '设计模式', '#F9E79F', '2020-06-15 10:45:55', '2020-06-15 10:51:50');
INSERT INTO `t_tag` VALUES (18, '反射技术', '#F8C471', '2020-06-15 10:45:55', '2020-06-15 10:52:06');
INSERT INTO `t_tag` VALUES (19, ' MyBatis核心组件', '#F9EBEA', '2020-06-15 11:02:52', '2020-06-15 11:27:41');
INSERT INTO `t_tag` VALUES (20, 'Mybatis配置', '#85C1E9', '2020-06-15 11:05:28', '2020-06-15 11:27:52');
INSERT INTO `t_tag` VALUES (21, 'Mybatis映射器', '#19CAAD', '2020-06-15 11:08:33', '2020-06-15 11:28:02');
INSERT INTO `t_tag` VALUES (22, 'Mybatis动态SQL', '#8CC7B5', '2020-06-15 11:22:20', '2020-06-15 11:28:11');
INSERT INTO `t_tag` VALUES (23, '装配Bean', '#A0EEE1', '2020-06-15 11:32:09', '2020-06-15 11:50:33');
INSERT INTO `t_tag` VALUES (24, 'SpringMVC组件开发', '#BEE7E9', '2020-06-15 11:50:17', '2020-06-15 11:50:42');
INSERT INTO `t_tag` VALUES (25, 'SpringBoot', '#BEEDC7', '2020-06-15 11:56:47', '2020-06-15 12:03:19');
INSERT INTO `t_tag` VALUES (26, 'SpringSecurity', '#00CCFF', '2020-06-15 11:56:47', '2020-06-15 12:04:57');
INSERT INTO `t_tag` VALUES (27, 'Vue', '#D5F5E3', '2020-06-15 12:34:05', '2020-06-15 12:34:05');

-- ----------------------------
-- Table structure for t_visitor
-- ----------------------------
DROP TABLE IF EXISTS `t_visitor`;
CREATE TABLE `t_visitor`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `link` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '网址',
  `status` tinyint(2) NULL DEFAULT NULL COMMENT '启用状态[0:停用, 1:启用]',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_visitor_username`(`username`) USING BTREE,
  UNIQUE INDEX `idx_visitor_email`(`email`) USING BTREE,
  UNIQUE INDEX `idx_nickname`(`nickname`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_visitor
-- ----------------------------
INSERT INTO `t_visitor` VALUES (7, 'visitor001', 'e10adc3949ba59abbe56e057f20f883e', '张三', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', '1114173646@qq.com', '', 1, '2020-06-15 16:19:34', '2020-06-15 16:19:34');
INSERT INTO `t_visitor` VALUES (8, 'visitor002', 'e10adc3949ba59abbe56e057f20f883e', '李四', 'https://gravatar.loli.net/avatar/f2c02ce7474e4b228a576f7e47f00bd1?d=mp&v=1.3.10', 'm13415418397@163.com', '', 1, '2020-06-15 16:35:02', '2020-06-15 16:35:02');

SET FOREIGN_KEY_CHECKS = 1;
